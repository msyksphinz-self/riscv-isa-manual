\begin{comment}
\chapter{``C'' Standard Extension for Compressed Instructions, Version
2.0}
\end{comment}
\chapter{圧縮命令のための``C''標準拡張, Version 2.0}
\label{compressed}

\begin{comment}
This chapter describes the current proposal for the RISC-V
standard compressed instruction-set extension, named ``C'', which
reduces static and dynamic code size by adding short 16-bit
instruction encodings for common operations.  The C extension can be
added to any of the base ISAs (RV32, RV64, RV128), and we use the
generic term ``RVC'' to cover any of these.  Typically, 50\%--60\% of
the RISC-V instructions in a program can be replaced with RVC
instructions, resulting in a 25\%--30\% code-size reduction.
\end{comment}

本章では、RISC-V標準の圧縮命令セット拡張の現在の提案について説明します。
この拡張は、``C''と名付けられており、一般的な操作に対して短い16ビットの命令エンコーディングを追加することで、
スタティックおよびダイナミックなコードサイズを削減します。
C拡張は、基本ISA(RV32, RV64, RV128)のいずれにも追加することができ、これらを総称して``RVC''と呼んでいます。
一般的に、プログラム中のRISC-V命令の50\%～60\%をRVC命令に置き換えることで、
コードサイズを25\%～30\%削減することができます。

\begin{comment}
\section{Overview}
\end{comment}
\section{概要}

\begin{comment}
RVC uses a simple compression scheme that offers shorter 16-bit
versions of common 32-bit RISC-V instructions when:
\begin{tightlist}
	\item the immediate or address offset is small, or
	\item one of the registers is the zero register ({\tt x0}), the
      ABI link register ({\tt x1}), or the ABI stack pointer ({\tt
        x2}), or
	\item the destination register and the first source register are
      identical, or
	\item the registers used are the 8 most popular ones.
\end{tightlist}
\end{comment}

RVCは、一般的な32ビットRISC-V命令を16ビットに短縮して提供するシンプルな圧縮方式を採用しています:
\begin{tightlist}
\item 即値もしくはアドレスオフセットが短い、もしくは
\item いずれかのレジスタが、ゼロレジスタ({\tt x0}), ABI リンクレジスタ({\tt x1}), ABI スタックポインタ({\tt x2}) のいずれかである場合、もしくは
\item 書き込みレジスタと最初のソースレジスタが同一である、または
\item 使用されているレジスタが8つの最も一般的なものである
\end{tightlist}

\begin{comment}
The C extension is compatible with all other standard instruction
extensions.  The C extension allows 16-bit instructions to be freely
intermixed with 32-bit instructions, with the latter now able to start
on any 16-bit boundary, i.e., IALIGN=16.  With the addition of the C
extension, no instructions can raise instruction-address-misaligned
exceptions.
\end{comment}

C拡張は、他のすべての標準的な命令拡張と互換性があります。
C拡張により、16ビット命令と32ビット命令を自由に混在させることができるようになり、
32ビット命令は任意の16ビット境界で開始できるようになりました(IALIGN=16)。
C拡張の追加により、命令-アドレス-ミスアラインドの例外を発生させることができる命令はなくなりました。

\begin{commentary}
\begin{comment}
Removing the 32-bit alignment constraint on the original 32-bit
instructions allows significantly greater code density.
\end{comment}
オリジナルの32ビット命令の32ビットアライメント制約を取り除くことで、
コード密度を大幅に向上させることができます。
\end{commentary}

\begin{comment}
The compressed instruction encodings are mostly common across RV32C,
RV64C, and RV128C, but as shown in Table~\ref{rvcopcodemap}, a few
opcodes are used for different purposes depending on base ISA width.
For example, the wider address-space RV64C and RV128C variants require
additional opcodes to compress loads and stores of 64-bit integer
values, while RV32C uses the same opcodes to compress loads and stores
of single-precision floating-point values.  Similarly, RV128C requires
additional opcodes to capture loads and stores of 128-bit integer
values, while these same opcodes are used for loads and stores of
double-precision floating-point values in RV32C and RV64C.  If the C
extension is implemented, the appropriate compressed floating-point
load and store instructions must be provided whenever the relevant
standard floating-point extension (F and/or D) is also implemented.
In addition, RV32C includes a compressed jump and link instruction to
compress short-range subroutine calls, where the same opcode is used
to compress ADDIW for RV64C and RV128C.
\end{comment}

圧縮命令のエンコーディングは、RV32C、RV64C、RV128Cでほぼ共通ですが、
表~\ref{rvcopcodemap}に示すように、いくつかのオペコードはベースISA幅に応じて異なる目的で使用されます。
例えば、アドレス空間の広いRV64CとRV128Cでは、64ビット整数値のロード/ストアを圧縮するために追加のオペコードが必要ですが、
RV32Cでは、単精度浮動小数点値のロード/ストアを圧縮するために同じオペコードを使用します。
同様に、RV128Cでは128ビット整数値のロードとストアをキャプチャするために追加のオペコードが必要ですが、
RV32CとRV64Cでは倍精度浮動小数点値のロードとストアに同じオペコードが使用されます。
C 拡張機能が実装されている場合、関連する標準浮動小数点拡張機能 (F または D) が実装されている場合は、
適切な圧縮浮動小数点ロード/ストア命令を提供する必要があります。
さらに、RV32Cには、短距離のサブルーチン呼び出しを圧縮するための圧縮されたジャンプとリンク命令が含まれており、
RV64CとRV128CのADDIWを圧縮するために同じオペコードが使用されています。

\begin{commentary}
\begin{comment}
Double-precision loads and stores are a significant fraction of static
and dynamic instructions, hence the motivation to include them in the
RV32C and RV64C encoding.
\end{comment}

倍精度のロードとストアは、静的命令と動的命令の中でかなりの割合を占めているため、
RV32CとRV64Cのエンコーディングに含める動機となりました。

\begin{comment}
Although single-precision loads and stores are not a significant
source of static or dynamic compression for benchmarks compiled for
the currently supported ABIs, for microcontrollers that only provide
hardware single-precision floating-point units and have an ABI that
only supports single-precision floating-point numbers, the
single-precision loads and stores will be used at least as frequently
as double-precision loads and stores in the measured benchmarks.
Hence, the motivation to provide compressed support for these in
RV32C.
\end{comment}

単精度のロード・ストアは、現在サポートされてい る ABI でコンパイルされたベンチマークでは、
静的および動的な圧縮の重要な原因とは なりませんが、ハードウェアに単精度浮動小数点ユニッ トしか備えておらず、
単精度浮動小数点数のみをサポートす る ABI を持つマイクロコントローラでは、
測定されたベ ンチマークにおいて、単精度のロード・ストアは、少なくとも 倍精度のロード・ストアと同じ頻度で使用されます。
そのため、RV32Cではこれらを圧縮してサポートすることになりました。

\begin{comment}
Short-range subroutine calls are more likely in small binaries for
microcontrollers, hence the motivation to include these in RV32C.
\end{comment}

短距離のサブルーチンコールは、マイクロコントローラ用の小さなバイナリでは、
より頻繁に使用されるため、RV32Cにこれらを含めることが動機となっています。

\begin{comment}
Although reusing opcodes for different purposes for different base
register widths adds some complexity to documentation, the impact on
implementation complexity is small even for designs that support
multiple base ISA register widths.  The compressed floating-point load
and store variants use the same instruction format with the same
register specifiers as the wider integer loads and stores.
\end{comment}

ベース・レジスタ幅が異なる目的でオペコードを再利用すると、ドキュメントが多少複雑になりますが、
複数のベースISAレジスタ幅をサポートするデザインでも、実装の複雑さに与える影響は小さいです。
圧縮された浮動小数点のロード／ストア・バリアントは、
幅の広い整数のロード／ストアと同じレジスタ指定子を持つ同じ命令フォーマットを使用します。
\end{commentary}

\begin{comment}
RVC was designed under the constraint that each RVC instruction
expands into a single 32-bit instruction in either the base ISA
(RV32I/E, RV64I, or RV128I) or the F and D standard extensions where
present.  Adopting this constraint has two main benefits:
\end{comment}

RVCは、ベースISA(RV32I/E、RV64I、RV128I)またはFとDの標準的な拡張機能(存在する場合)において、
各RVC命令が1つの32ビット命令に拡張されるという制約の下で設計されました。
この制約を採用することで、主に2つのメリットがあります。

\begin{tightlist}
  \begin{comment}
\item Hardware designs can simply expand RVC instructions during
  decode, simplifying verification and minimizing modifications to
  existing microarchitectures.
  \end{comment}
\item ハードウェア設計では、デコード時にRVC命令を拡張するだけで、
  検証が容易になり、既存のマイクロアーキテクチャの変更を最小限に抑えることができます。
  \begin{comment}
\item Compilers can be unaware of the RVC extension and leave code
  compression to the assembler and linker, although a
  compression-aware compiler will generally be able to produce better
  results.
  \end{comment}
\item コンパイラは RVC 拡張を意識せず、コードの圧縮をアセンブラやリンカに任せることができますが、
  圧縮を意識したコンパイラの方が一般的に良い結果を得ることができます。
\end{tightlist}

\begin{commentary}
\begin{comment}
We felt the multiple complexity reductions of a simple one-one mapping
between C and base IFD instructions far outweighed the potential gains
of a slightly denser encoding that added additional instructions only
supported in the C extension, or that allowed encoding of multiple IFD
instructions in one C instruction.
\end{comment}
C言語とベースのIFD命令を1対1で対応させることで、複数の複雑さを軽減することができましたが、
C言語の拡張機能でしかサポートされていない命令を追加したり、
1つのC言語命令で複数のIFD命令をエンコードできるようにするなど、
多少高密度なエンコーディングを行うことで得られる潜在的な利益をはるかに上回ると考えました。
\end{commentary}

\begin{comment}
It is important to note that the C extension is not designed to be a
stand-alone ISA, and is meant to be used alongside a base ISA.
\end{comment}

C拡張は単独のISAとして設計されているわけではなく、
ベースとなるISAと一緒に使用することを前提としていることに注意してください。

\begin{commentary}
\begin{comment}
Variable-length instruction sets have long been used to improve code
density.  For example, the IBM Stretch~\cite{stretch}, developed in
the late 1950s, had an ISA with 32-bit and 64-bit instructions, where
some of the 32-bit instructions were compressed versions of the full
64-bit instructions.  Stretch also employed the concept of limiting
the set of registers that were addressable in some of the shorter
instruction formats, with short branch instructions that could only
refer to one of the index registers.  The later IBM 360
architecture~\cite{ibm360} supported a simple variable-length
instruction encoding with 16-bit, 32-bit, or 48-bit instruction
formats.
\end{comment}

コード密度を向上させるために、可変長の命令セットが使われてきました。
例えば、1950年代後半に開発されたIBMのStretchは、32ビットと64ビットの命令を持つISAを持ち、
32ビットの命令の一部は64ビットの完全な命令を圧縮したものでした。
Stretchでは、短い命令形式の中でアドレス可能なレジスタを限定するというコンセプトを採用し、
インデックスレジスタのいずれかを参照するだけの短い分岐命令も用意されていました。
後期のIBM 360アーキテクチャ~\cite{ibm360}では、16ビット、32ビット、48ビットの3種類の命令形式で、
シンプルな可変長の命令エンコーディングをサポートしていました。

\begin{comment}
In 1963, CDC introduced the Cray-designed CDC 6600~\cite{cdc6600}, a
precursor to RISC architectures, that introduced a register-rich
load-store architecture with instructions of two lengths, 15-bits and
30-bits.  The later Cray-1 design used a very similar instruction
format, with 16-bit and 32-bit instruction lengths.
\end{comment}

1963年、CDC社はRISCアーキテクチャの先駆けとなるCray設計のCDC6600~\cite{cdc6600}を発表し、
15ビットと30ビットの2種類の長さの命令を持つレジスタリッチロードストアアーキテクチャを導入しました。
後のCray-1では、16ビットと32ビットの2種類の命令長を持つ、よく似た命令形式が採用されました。

\begin{comment}
The initial RISC ISAs from the 1980s all picked performance over code
size, which was reasonable for a workstation environment, but not for
embedded systems. Hence, both ARM and MIPS subsequently made versions
of the ISAs that offered smaller code size by offering an alternative
16-bit wide instruction set instead of the standard 32-bit wide
instructions.  The compressed RISC ISAs reduced code size relative to
their starting points by about 25--30\%, yielding code that was
significantly \emph{smaller} than 80x86.  This result surprised some,
as their intuition was that the variable-length CISC ISA should be
smaller than RISC ISAs that offered only 16-bit and 32-bit formats.
\end{comment}

1980年代に登場した初期のRISC ISAは、いずれもコードサイズよりも性能を重視しており、
これはワークステーション環境では合理的でしたが、組み込みシステムには適していませんでした。
そこで、ARM社とMIPS社は、標準的な32ビット幅の命令セットの代わりに、
16ビット幅の命令セットを提供することで、コードサイズを小さくしたバージョンのISAを開発しました。
圧縮されたRISC ISAでは、コードサイズが約25～30\%削減され、80x86よりも大幅に小さいコードが得られました。
可変長のCISC ISAは、16ビットと32ビットしかないRISC ISAよりも小さいはずだと思っていたので、この結果には驚きました。

\begin{comment}
Since the original RISC ISAs did not leave sufficient opcode space
free to include these unplanned compressed instructions, they were
instead developed as complete new ISAs.  This meant compilers needed
different code generators for the separate compressed ISAs.  The first
compressed RISC ISA extensions (e.g., ARM Thumb and MIPS16) used only
a fixed 16-bit instruction size, which gave good reductions in static
code size but caused an increase in dynamic instruction count, which
led to lower performance compared to the original fixed-width 32-bit
instruction size.  This led to the development of a second generation
of compressed RISC ISA designs with mixed 16-bit and 32-bit
instruction lengths (e.g., ARM Thumb2, microMIPS, PowerPC VLE), so
that performance was similar to pure 32-bit instructions but with
significant code size savings.  Unfortunately, these different
generations of compressed ISAs are incompatible with each other and
with the original uncompressed ISA, leading to significant complexity
in documentation, implementations, and software tools support.
\end{comment}

当初のRISC ISAでは、このような予定外の圧縮命令を組み込むための十分なオペコードスペースが確保されていなかったため、
まったく新しいISAとして開発されました。
そのため、コンパイラにはそれぞれの圧縮ISAに対応したコードジェネレータが必要となりました。
最初の圧縮RISC ISA拡張(ARM ThumbやMIPS16など)は、固定の16ビット命令サイズのみを使用していたため、
静的なコードサイズの削減には成功しましたが、動的な命令数の増加を招き、元の固定幅32ビット命令サイズに比べて性能が低下してしまいました。
このため、16ビットと32ビットの命令長を混在させた第2世代の圧縮RISC ISAデザイン(ARM Thumb2、microMIPS、PowerPC VLEなど)が開発され、
純粋な32ビット命令と同等の性能を持ちながら、コードサイズを大幅に削減することができるようになりました。
残念ながら、これらの異なる世代の圧縮ISAは、相互に、そしてオリジナルの非圧縮ISAとの互換性がないため、
ドキュメント、実装、ソフトウェアツールのサポートが非常に複雑になっています。

\begin{comment}
Of the commonly used 64-bit ISAs, only PowerPC and microMIPS currently
supports a compressed instruction format.  It is surprising that the
most popular 64-bit ISA for mobile platforms (ARM v8) does not include
a compressed instruction format given that static code size and
dynamic instruction fetch bandwidth are important metrics.  Although
static code size is not a major concern in larger systems, instruction
fetch bandwidth can be a major bottleneck in servers running
commercial workloads, which often have a large instruction working
set.
\end{comment}

一般的に使用されている64ビットISAのうち、現在、圧縮命令フォーマットをサポートしているのはPowerPCとmicroMIPSのみです。
静的コードサイズと動的命令フェッチ帯域幅が重要な指標であるにもかかわらず、モバイルプラットフォームで最も普及している
64ビットISA(ARM v8)に圧縮命令フォーマットが含まれていないのは驚くべきことです。
大規模なシステムでは、静的なコードサイズはあまり気になりませんが、大きな命令ワークセットを持つことが多い商用ワークロードを
実行しているサーバーでは、命令フェッチ帯域幅が大きなボトルネックになることがあります。

\begin{comment}
Benefiting from 25 years of hindsight, RISC-V was designed to support
compressed instructions from the outset, leaving enough opcode
space for RVC to be added as a simple extension on top of the base ISA
(along with many other extensions).  The philosophy of RVC is to
reduce code size for embedded applications \emph{and} to improve
performance and energy-efficiency for all applications due to fewer
misses in the instruction cache. Waterman shows that RVC fetches
25\%-30\% fewer instruction bits, which reduces instruction cache
misses by 20\%-25\%, or roughly the same performance impact as
doubling the instruction cache size~\cite{waterman-ms}.
\end{comment}

25年の時を経て、RISC-Vは当初から圧縮命令をサポートするように設計されており、
ベースISAの上に単純な拡張機能としてRVCを追加できるだけの十分なオペコードスペースを残しています(他の多くの拡張機能とともに)。
RVCの目的は、組み込みアプリケーションのコードサイズを縮小し、命令キャッシュのミスを減らすことで、
すべてのアプリケーションのパフォーマンスとエネルギー効率を向上させることにあります。
Watermanは、RVCがフェッチする命令ビット数を25\%～30\%削減することで、
命令キャッシュのミスを20\%～25\%削減することができたと発表しています。
\end{commentary}

\begin{comment}
\section{Compressed Instruction Formats}
\end{comment}
\section{圧縮命令フォーマット}

\begin{comment}
Table~\ref{rvc-formats} shows the nine compressed instruction
formats. CR, CI, and CSS can use any of the 32 RVI registers, but CIW,
CL, CS, CA, and CB are limited to just 8 of them. Table~\ref{registers}
lists these popular registers, which correspond to registers {\tt x8}
to {\tt x15}.  Note that there is a
separate version of load and store instructions that use the stack
pointer as the base address register, since saving to and restoring
from the stack are so prevalent, and that they use the CI and CSS
formats to allow access to all 32 data registers. CIW supplies an
8-bit immediate for the ADDI4SPN instruction.
\end{comment}

表~\ref{rvc-formats}には、9つの圧縮命令フォーマットが示されています。
CR、CI、CSSは32本のRVIレジスタのうち、どのレジスタでも使用できますが、
CIW、CL、CS、CA、CBは8本に限られます。
表~\ref{registers}には、これらの一般的なレジスターがリストアップされており、これらはレジスター{\tt x8}から{\tt x15}に対応しています。
スタックへの保存やスタックからの復元が非常に多いため、スタックポインタをベースアドレスレジスタとして使用するロード命令とストア命令には別バージョンがあり、
32本のデータレジスタすべてにアクセスできるようにCIとCSSのフォーマットを使用していることに注意してください。
CIWはADDI4SPN命令に8ビットの即値を供給します。

\begin{commentary}
\begin{comment}
The RISC-V ABI was changed to make the frequently used registers map
to registers {\tt x8}--{\tt x15}.  This simplifies the decompression
decoder by having a contiguous naturally aligned set of register
numbers, and is also compatible with the RV32E base ISA,
which only has 16 integer registers.
\end{comment}
RISC-VのABIが変更され、頻繁に使用されるレジスタがレジスタ{\tt x8}--{\tt x15}にマッピングされるようになりました。
これにより、自然にアラインされた連続したレジスタ番号を持つことになり、命令デコーダが簡素化されます。
また、16本の整数レジスタしか持たないRV32EベースISAとの互換性もあります。
\end{commentary}

\begin{comment}
Compressed register-based floating-point loads and stores also use the
CL and CS formats respectively, with the eight registers mapping to
{\tt f8} to {\tt f15}.
\end{comment}

圧縮レジスタベースの浮動小数点ロード/ストアも、それぞれCLとCSフォーマットを採用しており、
8つのレジスタは、{\tt f8}～{\tt f15}にマッピングされています。

\begin{commentary}
\begin{comment}
The standard RISC-V calling convention maps the most frequently used
floating-point registers to registers {\tt f8} to {\tt f15}, which
allows the same register decompression decoding as for integer
register numbers.
\end{comment}
標準的なRISC-Vの呼び出し規則では、最も頻繁に使用される浮動小数点レジスタをレジスタ{\tt f8}～{\tt f15}にマッピングし、
整数レジスタ番号の場合と同様のレジスタ展開デコードを可能にしています。
\end{commentary}

\begin{comment}
The formats were designed to keep bits for the two register source
specifiers in the same place in all instructions, while the
destination register field can move.  When the full 5-bit destination
register specifier is present, it is in the same place as in the
32-bit RISC-V encoding.  Where immediates are
sign-extended, the sign-extension is always from bit 12.  Immediate
fields have been scrambled, as in the base specification, to reduce
the number of immediate muxes required.
\end{comment}
このフォーマットは、2つのレジスタソース指定子のビットをすべての命令で同じ場所に保つように設計されていますが、
一方で書き込みレジスタフィールドは移動可能です。
完全な5ビットの書き込みレジスタ指定子が存在する場合、それは32ビットRISC-Vエンコーディングと同じ場所にあります。
即値が符号拡張されている場合、符号拡張は常にビット12から行われます。
即値フィールドは、基本仕様と同様にスクランブルされており、必要な即値マルチプレクサの数を減らしています。

\begin{commentary}
\begin{comment}
The immediate fields are scrambled in the instruction formats instead
of in sequential order so that as many bits as possible are in the
same position in every instruction, thereby simplifying
implementations. For example, immediate bits 17---10 are always sourced from
the same instruction bit positions.  Five other immediate bits (5, 4,
3, 1, and 0) have just two source instruction bits, while four (9, 7,
6, and 2) have three sources and one (8) has four sources.
\end{comment}
即値フィールドは、順序ではなく命令形式でスクランブルされており、
どの命令でも同じ位置にできるだけ多くのビットが配置されるようになっており、実装が容易になっています。
例えば、即値ビット17--10は、常に同じ命令のビット位置から供給されます。
他の5つの即値ビット(5, 4, 3, 1, 0)の2つの命令ビットの場所から供給されますが、
4つの即値ビット(9, 7, 6, 2)は3つ、
1つの即値ビット(8）は4つのソースを持っています。
\end{commentary}

\begin{comment}
For many RVC instructions, zero-valued immediates are disallowed and
{\tt x0} is not a valid 5-bit register specifier.  These restrictions
free up encoding space for other instructions requiring fewer operand
bits.
\end{comment}

また、多くの RVC 命令では、0 値の即値は認められず、{\tt x0} は 5 ビットのレジスタ指定としては有効ではありません。
これらの制限により、より少ないオペランドビットを必要とする他の命令のためのエンコーディングスペースが確保されます。

\newcommand{\rdprime}{rd\,$'$}
\newcommand{\rsoneprime}{rs1\,$'$}
\newcommand{\rstwoprime}{rs2\,$'$}

\begin{table}[h]
{
\begin{small}
\begin{center}
\begin{tabular}{c c p{0in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}p{0.05in}}
& & & & & & & & & \\
Format  &  Meaning                  &
\instbit{15} &
\instbit{14} &
\instbit{13} &
\multicolumn{1}{c}{\instbit{12}} &
\instbit{11} &
\instbit{10} &
\instbit{9} &
\instbit{8} &
\instbit{7} &
\instbit{6} &
\multicolumn{1}{r}{\instbit{5}} &
\instbit{4} &
\instbit{3} &
\instbit{2} &
\instbit{1} &
\instbit{0} \\
\cline{3-18}

CR & Register &
\multicolumn{4}{|c|}{funct4} &
\multicolumn{5}{c|}{rd/rs1} &
\multicolumn{5}{c|}{rs2} &
\multicolumn{2}{c|}{op} \\
\cline{3-18}

CI & Immediate &
\multicolumn{3}{|c|}{funct3} &
\multicolumn{1}{c|}{imm} &
\multicolumn{5}{c|}{rd/rs1} &
\multicolumn{5}{c|}{imm} &
\multicolumn{2}{c|}{op} \\
\cline{3-18}

CSS & Stack-relative Store &
\multicolumn{3}{|c|}{funct3} &
\multicolumn{6}{c|}{imm} &
\multicolumn{5}{c|}{rs2} &
\multicolumn{2}{c|}{op} \\
\cline{3-18}

CIW & Wide Immediate &
\multicolumn{3}{|c|}{funct3} &
\multicolumn{8}{c|}{imm} &
\multicolumn{3}{c|}{\rdprime} &
\multicolumn{2}{c|}{op} \\
\cline{3-18}

CL & Load &
\multicolumn{3}{|c|}{funct3} &
\multicolumn{3}{c|}{imm} &
\multicolumn{3}{c|}{\rsoneprime} &
\multicolumn{2}{c|}{imm} &
\multicolumn{3}{c|}{\rdprime} &
\multicolumn{2}{c|}{op} \\
\cline{3-18}

CS & Store &
\multicolumn{3}{|c|}{funct3} &
\multicolumn{3}{c|}{imm} &
\multicolumn{3}{c|}{\rsoneprime} &
\multicolumn{2}{c|}{imm} &
\multicolumn{3}{c|}{\rstwoprime} &
\multicolumn{2}{c|}{op} \\
\cline{3-18}

CA & Arithmetic &
\multicolumn{6}{|c|}{funct6} &
\multicolumn{3}{c|}{\rdprime/\rsoneprime} &
\multicolumn{2}{c|}{funct2} &
\multicolumn{3}{c|}{\rstwoprime} &
\multicolumn{2}{c|}{op} \\
\cline{3-18}

CB & Branch/Arithmetic &
\multicolumn{3}{|c|}{funct3} &
\multicolumn{3}{c|}{offset} &
\multicolumn{3}{c|}{\rdprime/\rsoneprime} &
\multicolumn{5}{c|}{offset} &
\multicolumn{2}{c|}{op} \\
\cline{3-18}

CJ & Jump &
\multicolumn{3}{|c|}{funct3} &
\multicolumn{11}{c|}{jump target} &
\multicolumn{2}{c|}{op} \\
\cline{3-18}

\end{tabular}
\end{center}
\end{small}
}
\begin{comment}
\caption{Compressed 16-bit RVC instruction formats.}
\end{comment}
\caption{圧縮された16ビットのRVC命令フォーマット}
\label{rvc-formats}
\end{table}

\begin{comment}
\begin{table}[H]
{
\begin{center}
\begin{tabular}{l|c|c|c|c|c|c|c|c|}
\cline{2-9}
RVC Register Number  & 000 & 001 & 010 & 011 & 100 & 101 & 110 & 111
\\ \cline{2-9}
Integer Register Number & {\tt x8} & {\tt x9} & {\tt x10} & {\tt x11} & {\tt x12} & {\tt x13} & {\tt x14}  & {\tt x15} \\ \cline{2-9}
Integer Register ABI Name    & {\tt s0}  &  {\tt s1} &  {\tt a0} &  {\tt a1} &  {\tt a2} &  {\tt a3} & {\tt a4}  & {\tt a5} \\ \cline{2-9}
Floating-Point Register Number & {\tt f8} & {\tt f9} & {\tt f10} & {\tt f11} & {\tt f12} & {\tt f13} & {\tt f14}  & {\tt f15} \\ \cline{2-9}
Floating-Point Register ABI Name    & {\tt fs0}  &  {\tt fs1} &  {\tt fa0} &  {\tt fa1} &  {\tt fa2} &  {\tt fa3} & {\tt fa4}  & {\tt fa5} \\ \cline{2-9}
\end{tabular}
\end{center}
}
\caption{Registers specified by the three-bit {\em \rsoneprime}, {\em \rstwoprime}, and {\em \rdprime} fields of the CIW, CL, CS, CA, and CB formats.}
\label{registers}
\end{table}
\end{comment}

\begin{table}[H]
{
\begin{center}
\begin{tabular}{l|c|c|c|c|c|c|c|c|}
\cline{2-9}
RVCレジスタ番号  & 000 & 001 & 010 & 011 & 100 & 101 & 110 & 111
\\ \cline{2-9}
整数レジスタ番号 & {\tt x8} & {\tt x9} & {\tt x10} & {\tt x11} & {\tt x12} & {\tt x13} & {\tt x14}  & {\tt x15} \\ \cline{2-9}
整数レジスタABI名    & {\tt s0}  &  {\tt s1} &  {\tt a0} &  {\tt a1} &  {\tt a2} &  {\tt a3} & {\tt a4}  & {\tt a5} \\ \cline{2-9}
浮動小数点レジスタ番号 & {\tt f8} & {\tt f9} & {\tt f10} & {\tt f11} & {\tt f12} & {\tt f13} & {\tt f14}  & {\tt f15} \\ \cline{2-9}
浮動小数点レジスタABI名    & {\tt fs0}  &  {\tt fs1} &  {\tt fa0} &  {\tt fa1} &  {\tt fa2} &  {\tt fa3} & {\tt fa4}  & {\tt fa5} \\ \cline{2-9}
\end{tabular}
\end{center}
}
\caption{CIW, CL, CS, CA, CBフォーマットから指定される{\em \rsoneprime}, {\em \rstwoprime}, {\em \rdprime} の3ビットのレジスタ指定子}
\label{registers}
\end{table}

\begin{comment}
\section{Load and Store Instructions}
\end{comment}
\section{ロードストア命令}

\begin{comment}
To increase the reach of 16-bit instructions, data-transfer
instructions use zero-extended immediates that are scaled by the size
of the data in bytes: $\times$4 for words, $\times$8 for double words,
and $\times$16 for quad words.
\end{comment}
16ビット命令のアドレス領域を伸ばすために、データ転送命令はデータ転送サイズに応じてスケールした
ゼロ拡張即値を使用しています: ワード転送の場合は$\times$4、ダブルワード転送の場合は$\times$8、
4倍ワード転送の場合は$\times$16となっています。

\begin{comment}
RVC provides two variants of loads and stores.  One uses the ABI stack
pointer, {\tt x2}, as the base address and can target any data register.  The
other can reference one of 8 base address registers and one of 8 data
registers.
\end{comment}
RVCは2種類のロードストア命令を用意しています。
1つはABIのスタックポインタ{\tt x2}をベースアドレスとして任意のデータレジスタを
ターゲットとするものです。
もう一つは8つのベースアドレスレジスタと8つのデータレジスタのみ使用可能なロードストア命令です。

\begin{comment}
\subsection*{Stack-Pointer-Based Loads and Stores}
\end{comment}
\subsection*{スタックポインタベースロードストア命令}

\begin{center}
\begin{tabular}{S@{}W@{}T@{}T@{}Y}
\\
\instbitrange{15}{13} &
\multicolumn{1}{c}{\instbit{12}} &
\instbitrange{11}{7} &
\instbitrange{6}{2} &
\instbitrange{1}{0} \\
\hline
\multicolumn{1}{|c|}{funct3} &
\multicolumn{1}{c|}{imm} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{imm} &
\multicolumn{1}{c|}{op} \\
\hline
3 & 1 & 5 & 5 & 2 \\
C.LWSP & offset[5] & dest$\neq$0 & offset[4:2$\vert$7:6] & C2 \\
C.LDSP & offset[5] & dest$\neq$0 & offset[4:3$\vert$8:6] & C2 \\
C.LQSP & offset[5] & dest$\neq$0 & offset[4$\vert$9:6] & C2 \\
C.FLWSP& offset[5] & dest        & offset[4:2$\vert$7:6] & C2 \\
C.FLDSP& offset[5] & dest        & offset[4:3$\vert$8:6] & C2 \\
\end{tabular}
\end{center}
\begin{comment}
These instructions use the CI format.
\end{comment}
この命令はCIフォーマットを使用しています。

\begin{comment}
C.LWSP loads a 32-bit value from memory into register {\em rd}.  It computes
an effective address by adding the {\em zero}-extended offset, scaled by 4, to
the stack pointer, {\tt x2}.  It expands to {\tt lw rd, offset(x2)}.
C.LWSP is only valid when $\textit{rd}{\neq}\texttt{x0}$;
the code points with $\textit{rd}{=}\texttt{x0}$ are reserved.
\end{comment}
C.LWSPは32ビットの値をメモリからレジスタ{\em rd}にロードします。
この命令は{\em ゼロ}拡張したオフセットを4倍し、スタックポインタ{\tt x2}を加算して実効アドレスを算出します。
この命令は{\tt lw rd, offset(x2)}に展開されます。
C.LWSPは$\textit{rd}{neq}\texttt{x0}$のときのみ有効で、$\textit{rd}{=}texttt{x0}$のコードポイントは予約されています。

\begin{comment}
C.LDSP is an RV64C/RV128C-only instruction that loads a 64-bit value from memory into
register {\em rd}.  It computes its effective address by adding the
zero-extended offset, scaled by 8, to the stack pointer, {\tt x2}.
It expands to {\tt ld rd, offset(x2)}.
C.LDSP is only valid when $\textit{rd}{\neq}\texttt{x0}$;
the code points with $\textit{rd}{=}\texttt{x0}$ are reserved.
\end{comment}
C.LDSPはRV64C/RV128C限定の命令で、64ビットの値をメモリからレジスタ{\em rd}にロードします。
この命令は{\em ゼロ}拡張したオフセットを8倍し、スタックポインタ{\tt x2}を加算して実効アドレスを算出します。
この命令は{\tt ld rd, offset(x2)}に展開されます。
C.LDSPは$\textit{rd}{neq}\texttt{x0}$のときのみ有効で、$\textit{rd}{=}texttt{x0}$のコードポイントは予約されています。

\begin{comment}
C.LQSP is an RV128C-only instruction that loads a 128-bit value from memory
into register {\em rd}.  It computes its effective address by adding the
zero-extended offset, scaled by 16, to the stack pointer, {\tt x2}.
It expands to {\tt lq rd, offset(x2)}.
C.LQSP is only valid when $\textit{rd}{\neq}\texttt{x0}$;
the code points with $\textit{rd}{=}\texttt{x0}$ are reserved.
\end{comment}
C.LQSPはRV128C限定の命令で、128ビットの値をメモリからレジスタ{\em rd}にロードします。
この命令はゼロ拡張したオフセットを16倍し、スタックポインタ{\tt x2}を加算して実効アドレスを算出します。
この命令は{\tt lq rd, offset(x2)}に展開されます。
C.LDSPは$\textit{rd}{neq}\texttt{x0}$のときのみ有効で、$\textit{rd}{=}texttt{x0}$のコードポイントは予約されています。

\begin{comment}
C.FLWSP is an RV32FC-only instruction that loads a single-precision
floating-point value from memory into floating-point register {\em rd}. It
computes its effective address by adding the {\em zero}-extended offset,
scaled by 4, to the stack pointer, {\tt x2}.  It expands to {\tt flw rd,
offset(x2)}.
\end{comment}
C.FLWSPはRV32FC限定の命令で、メモリから単精度浮動小数点値を浮動小数点レジスタ{\em rd}にロードします。
この命令はゼロ拡張したオフセットを4倍し、スタックポインタ{\tt x2}を加算して実効アドレスを算出します。
この命令は{\tt flw rd, offset(x2)}に展開されます。

\begin{comment}
C.FLDSP is an RV32DC/RV64DC-only instruction that loads a double-precision
floating-point value from memory into floating-point register {\em rd}. It
computes its effective address by adding the {\em zero}-extended offset,
scaled by 8, to the stack pointer, {\tt x2}.  It expands to {\tt fld rd,
offset(x2)}.
\end{comment}
C.FLDSPはRV32DC/RV64DC限定の命令で、メモリから倍精度浮動小数点値を浮動小数点レジスタ{\em rd}にロードします。
この命令はゼロ拡張したオフセットを8倍し、スタックポインタ{\tt x2}を加算して実効アドレスを算出します。
この命令は{\tt fld rd, offset(x2)}に展開されます。

\begin{center}
\begin{tabular}{S@{}M@{}T@{}Y}
\\
\instbitrange{15}{13} &
\instbitrange{12}{7} &
\instbitrange{6}{2} &
\instbitrange{1}{0} \\
\hline
\multicolumn{1}{|c|}{funct3} &
\multicolumn{1}{c|}{imm} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{op} \\
\hline
3 & 6 & 5 & 2 \\
C.SWSP & offset[5:2$\vert$7:6] & src & C2 \\
C.SDSP & offset[5:3$\vert$8:6] & src & C2 \\
C.SQSP & offset[5:4$\vert$9:6] & src & C2 \\
C.FSWSP& offset[5:2$\vert$7:6] & src & C2 \\
C.FSDSP& offset[5:3$\vert$8:6] & src & C2 \\
\end{tabular}
\end{center}
\begin{comment}
These instructions use the CSS format.
\end{comment}
この命令はCSSフォーマットを使用します。

\begin{comment}
C.SWSP stores a 32-bit value in register {\em rs2} to memory.  It computes
an effective address by adding the {\em zero}-extended offset, scaled by 4, to
the stack pointer, {\tt x2}.
It expands to {\tt sw rs2, offset(x2)}.
\end{comment}
C.SWSPは{\em rs2}レジスタに格納されている32ビットの値をメモリにストアします。
{\em ゼロ}拡張されたオフセットを4倍し、スタックポインタ{\tt x2}と加算して実効アドレスを算出します。
この命令は{\tt sw rs2, offset(x2)}に展開されます。

\begin{comment}
C.SDSP is an RV64C/RV128C-only instruction that stores a 64-bit value in register
{\em rs2} to memory.  It computes an effective address by adding the {\em
zero}-extended offset, scaled by 8, to the stack pointer, {\tt x2}.
It expands to {\tt sd rs2, offset(x2)}.
\end{comment}
C.SDSPはRV64C/RV128C限定命令で{\em rs2}レジスタに格納されている64ビットの値をメモリにストアします。
{\em ゼロ}拡張されたオフセットを8倍し、スタックポインタ{\tt x2}と加算して実効アドレスを算出します。
この命令は{\tt sd rs2, offset(x2)}に展開されます。

\begin{comment}
C.SQSP is an RV128C-only instruction that stores a 128-bit value in register
{\em rs2} to memory.  It computes an effective address by adding the {\em
zero}-extended offset, scaled by 16, to the stack pointer, {\tt x2}.
It expands to {\tt sq rs2, offset(x2)}.
\end{comment}
C.SQSPはRV128C限定命令で{\em rs2}レジスタに格納されている128ビットの値をメモリにストアします。
{\em ゼロ}拡張されたオフセットを16倍し、スタックポインタ{\tt x2}と加算して実効アドレスを算出します。
この命令は{\tt sq rs2, offset(x2)}に展開されます。

\begin{comment}
C.FSWSP is an RV32FC-only instruction that stores a single-precision
floating-point value in floating-point register {\em rs2} to memory.  It
computes an effective address by adding the {\em zero}-extended offset, scaled
by 4, to the stack pointer, {\tt x2}.  It expands to {\tt fsw rs2,
offset(x2)}.
\end{comment}
C.FSWSPは浮動小数点レジスタ{\em rs2}に格納されている32ビット単精度浮動小数点値をメモリにストアします。
{\em ゼロ}拡張されたオフセットを4倍し、スタックポインタ{\tt x2}と加算して実効アドレスを算出します。
この命令は{\tt fsw rs2, offset(x2)}に展開されます。

\begin{comment}
C.FSDSP is an RV32DC/RV64DC-only instruction that stores a double-precision
floating-point value in floating-point register {\em rs2} to memory.  It
computes an effective address by adding the {\em zero}-extended offset, scaled
by 8, to the stack pointer, {\tt x2}.  It expands to {\tt fsd rs2,
offset(x2)}.
\end{comment}
C.FSDSPは浮動小数点レジスタ{\em rs2}に格納されている64ビット倍精度浮動小数点値をメモリにストアします。
{\em ゼロ}拡張されたオフセットを8倍し、スタックポインタ{\tt x2}と加算して実効アドレスを算出します。
この命令は{\tt fsd rs2, offset(x2)}に展開されます。

\begin{commentary}
\begin{comment}
Register save/restore code at function entry/exit represents a
significant portion of static code size.  The stack-pointer-based
compressed loads and stores in RVC are effective at reducing the
save/restore static code size by a factor of 2 while improving
performance by reducing dynamic instruction bandwidth.
\end{comment}
関数の入出力時に発生するレジスタの保存/復元コードは、静的コードサイズのかなりの部分を占めています。
RVCのスタックポインタベースの圧縮ロード/ストアは、保存/復元のスタティックコードサイズを2分の1に削減し、
動的命令のバンド幅を削減することでパフォーマンスを向上させる効果があります。

\begin{comment}
A common mechanism used in other ISAs to further reduce
save/restore code size is load-multiple and store-multiple
instructions.  We considered adopting these for RISC-V but noted the
following drawbacks to these instructions:
\end{comment}
保存/復元のコードサイズをさらに小さくするために、他のISAでよく使われているメカニズムが、複数ロード命令と複数ストア命令です。
RISC-Vでも採用を検討しましたが、これらの命令には以下のような欠点がありました。

\begin{comment}
\begin{itemize}
\item These instructions complicate processor implementations.
\item For virtual memory systems, some data accesses could be
      resident in physical memory and some could not, which requires a
      new restart mechanism for partially executed instructions.
\item Unlike the rest of the RVC instructions, there is no IFD
      equivalent to Load Multiple and Store Multiple.
\item Unlike the rest of the RVC instructions, the compiler would
      have to be aware of these instructions to both generate the
      instructions and to allocate registers in an order to maximize
      the chances of the them being saved and stored, since they would
      be saved and restored in sequential order.
\item Simple microarchitectural implementations will constrain how
      other instructions can be scheduled around the load and store
      multiple instructions, leading to a potential performance loss.
\item The desire for sequential register allocation might conflict with
      the featured registers selected for the CIW, CL, CS, CA, and CB formats.
\end{itemize}
\end{comment}
\begin{itemize}
\item これらの命令はプロセッサの実装を複雑にする。
\item また、仮想メモリシステムでは、物理メモリに常駐するデータアクセスとそうでないデータアクセスがあるため、
  部分的に実行された命令のリスタート機構が新たに必要になります。
\item RVCの他の命令とは異なり、複数ロード命令と複数ストア命令に相当するIFDはありません。
\item RVCの他の命令とは異なり、これらの命令は順次保存/復元されるため、コンパイラはこれらの命令を意識して命令を生成し、
  保存/復元される可能性が最大になるような順序でレジスタを割り当てる必要があります。
\item 単純なマイクロアーキテクチャの実装では、
  複数のロード/ストア命令の周りに他の命令をどのようにスケジューリングするかが制限され、
  性能が低下する可能性があります。
\item また、レジスタを順次割り当てたいという要望は、CIW、CL、CS、CA、CBの
  各フォーマットで選択された機能付きレジスターと相反する可能性があります。
\end{itemize}

\begin{comment}
Furthermore, much of the gains can be realized in software by replacing
prologue and epilogue code with subroutine calls to common
prologue and epilogue code, a technique described in
Section 5.6 of~\cite{waterman-phd}.
\end{comment}
さらに、プロローグとエピローグのコードを、共通のプロローグとエピローグのコードへのサブルーチンコールに置き換えることで、
ソフトウェアで多くの利益を実現することができます。
この技法は~\cite{waterman-phd}の5.6節で説明されています。

\begin{comment}
While reasonable architects might come to different conclusions, we
decided to omit load and store multiple and instead use the
software-only approach of calling save/restore millicode routines to
attain the greatest code size reduction.
\end{comment}
アーキテクトによって結論は異なるかもしれませんが、私たちは複数ロードストアを省き、
代わりに保存/復元のミリコードルーチンを呼び出すというソフトウェアのみのアプローチを用いて、
最大のコードサイズ削減を実現することにしました。
\end{commentary}

\begin{comment}
\subsection*{Register-Based Loads and Stores}
\end{comment}
\subsection*{レジスタベースのロード・ストア命令}

\begin{center}
\begin{tabular}{S@{}S@{}S@{}Y@{}S@{}Y}
\\
\instbitrange{15}{13} &
\instbitrange{12}{10} &
\instbitrange{9}{7} &
\instbitrange{6}{5} &
\instbitrange{4}{2} &
\instbitrange{1}{0} \\
\hline
\multicolumn{1}{|c|}{funct3} &
\multicolumn{1}{c|}{imm} &
\multicolumn{1}{c|}{\rsoneprime} &
\multicolumn{1}{c|}{imm} &
\multicolumn{1}{c|}{\rdprime} &
\multicolumn{1}{c|}{op} \\
\hline
3 & 3 & 3 & 2 & 3 & 2 \\
C.LW & offset[5:3] & base & offset[2$\vert$6] & dest & C0 \\
C.LD & offset[5:3] & base & offset[7:6] & dest & C0 \\
C.LQ & offset[5$\vert$4$\vert$8] & base & offset[7:6] & dest & C0 \\
C.FLW& offset[5:3] & base & offset[2$\vert$6] & dest & C0 \\
C.FLD& offset[5:3] & base & offset[7:6] & dest & C0 \\
\end{tabular}
\end{center}
\begin{comment}
These instructions use the CL format.
\end{comment}
これらの命令はCLフォーマットを使用します。

\begin{comment}
C.LW loads a 32-bit value from memory into register {\em \rdprime}.  It computes
an effective address by adding the {\em zero}-extended offset, scaled by 4, to
the base address in register {\em \rsoneprime}.
It expands to {\tt lw \rdprime, offset(\rsoneprime)}.
\end{comment}
C.LWはメモリから32ビットの値をレジスタにロードして{\em \rdprime}レジスタに格納します。
レジスタのベースアドレスに、{\em ゼロ拡張}された即値を4倍に拡張されたオフセットを加えて実効アドレスを算出します。
この命令は{\tt lw \rdprime, offset(\rsoneprime)} に展開されます。

\begin{comment}
C.LD is an RV64C/RV128C-only instruction that loads a 64-bit value from memory into
register {\em \rdprime}.  It computes an effective address by adding the {\em
zero}-extended offset, scaled by 8, to the base address in register {\em
\rsoneprime}.
It expands to {\tt ld \rdprime, offset(\rsoneprime)}.
\end{comment}
C.LDはRV64C/RV128C限定の命令で、メモリから64ビットの値をレジスタにロードして{\em \rdprime}に格納します。
レジスタのベースアドレスに、{\em ゼロ拡張}された即値を8倍に拡張されたオフセットを加えて実効アドレスを算出します。
この命令は{\tt ld \rdprime, offset(\rsoneprime)} に展開されます。

\begin{comment}
C.LQ is an RV128C-only instruction that loads a 128-bit value from memory into
register {\em \rdprime}.  It computes an effective address by adding the {\em
zero}-extended offset, scaled by 16, to the base address in register {\em
\rsoneprime}.
It expands to {\tt lq \rdprime, offset(\rsoneprime)}.
\end{comment}
C.LQはRV128C限定の命令で、メモリから128ビットの値をレジスタにロードして{\em \rdprime}に格納します。
レジスタのベースアドレスに、{\em ゼロ拡張}された即値を16倍に拡張されたオフセットを加えて実効アドレスを算出します。
この命令は{\tt lq \rdprime, offset(\rsoneprime)} に展開されます。

\begin{comment}
C.FLW is an RV32FC-only instruction that loads a single-precision
floating-point value from memory into floating-point register {\em \rdprime}.  It
computes an effective address by adding the {\em zero}-extended offset, scaled
by 4, to the base address in register {\em \rsoneprime}.  It expands to {\tt flw
\rdprime, offset(\rsoneprime)}.
\end{comment}
C.FLWはRV32FC限定の命令で、メモリから単精度浮動小数点値をロードして浮動小数点レジスタ{\em \rdprime}に格納します。
レジスタのベースアドレスに、{\em ゼロ拡張}された即値を4倍に拡張されたオフセットを加えて実効アドレスを算出します。
この命令は{\tt flw \rdprime, offset(\rsoneprime)} に展開されます。

\begin{comment}
C.FLD is an RV32DC/RV64DC-only instruction that loads a double-precision
floating-point value from memory into floating-point register {\em \rdprime}.  It
computes an effective address by adding the {\em zero}-extended offset, scaled
by 8, to the base address in register {\em \rsoneprime}.  It expands to {\tt fld
\rdprime, offset(\rsoneprime)}.
\end{comment}
C.FLDはRV32DC/RV64DC限定の命令で、メモリから倍精度浮動小数点値をロードして浮動小数点レジスタ{\em \rdprime}に格納します。
レジスタのベースアドレスに、{\em ゼロ拡張}された即値を8倍に拡張されたオフセットを加えて実効アドレスを算出します。
これは、{\tt fld \rdprime, offset(\rsoneprime)} に展開されます。

\begin{center}
\begin{tabular}{S@{}S@{}S@{}Y@{}S@{}Y}
\\
\instbitrange{15}{13} &
\instbitrange{12}{10} &
\instbitrange{9}{7} &
\instbitrange{6}{5} &
\instbitrange{4}{2} &
\instbitrange{1}{0} \\
\hline
\multicolumn{1}{|c|}{funct3} &
\multicolumn{1}{c|}{imm} &
\multicolumn{1}{c|}{\rsoneprime} &
\multicolumn{1}{c|}{imm} &
\multicolumn{1}{c|}{\rstwoprime} &
\multicolumn{1}{c|}{op} \\
\hline
3 & 3 & 3 & 2 & 3 & 2 \\
C.SW & offset[5:3] & base & offset[2$\vert$6] & src & C0 \\
C.SD & offset[5:3] & base & offset[7:6] & src & C0 \\
C.SQ & offset[5$\vert$4$\vert$8] & base & offset[7:6] & src & C0 \\
C.FSW& offset[5:3] & base & offset[2$\vert$6] & src & C0 \\
C.FSD& offset[5:3] & base & offset[7:6] & src & C0 \\
\end{tabular}
\end{center}
\begin{comment}
These instructions use the CS format.
\end{comment}
これらの命令はCSフォーマットを使用します。

\begin{comment}
C.SW stores a 32-bit value in register {\em \rstwoprime} to memory.  It computes an
effective address by adding the {\em zero}-extended offset, scaled by 4, to
the base address in register {\em \rsoneprime}.
It expands to {\tt sw \rstwoprime, offset(\rsoneprime)}.
\end{comment}
C.SW命令はレジスタ{\em \rstwoprime}の32ビット値をメモリにストアします。
レジスタのベースアドレス{\em \rsoneprime}に{\em ゼロ拡張}された即値を4倍に拡張されたオフセットを加算して実効アドレスを算出します。
この命令は{\tt sw \rstwoprime, offset(\rsoneprime)}に展開されます。

\begin{comment}
C.SD is an RV64C/RV128C-only instruction that stores a 64-bit value in
register {\em \rstwoprime} to memory.  It computes an effective address by adding
the {\em zero}-extended offset, scaled by 8, to the base address in register
{\em \rsoneprime}.
It expands to {\tt sd \rstwoprime, offset(\rsoneprime)}.
\end{comment}
C.SDはRV64C/RV128C限定の命令で、レジスタ{\em \rstwoprime}の64ビット値をメモリにストアします。
レジスタのベースアドレス{\em \rsoneprime}に{\em ゼロ拡張}された即値を8倍に拡張されたオフセットを加算して実効アドレスを算出します。
この命令は{\tt sd \rstwoprime, offset(\rsoneprime)}に展開されます。

\begin{comment}
C.SQ is an RV128C-only instruction that stores a 128-bit value in register
{\em \rstwoprime} to memory.  It computes an effective address by adding the {\em
zero}-extended offset, scaled by 16, to the base address in register {\em
\rsoneprime}.
It expands to {\tt sq \rstwoprime, offset(\rsoneprime)}.
\end{comment}
C.SQはRV128C限定の命令で、レジスタ{\em \rstwoprime}の128ビット値をメモリにストアします。
レジスタのベースアドレス{\em \rsoneprime}に{\em ゼロ拡張}された即値を16倍に拡張されたオフセットを加算して実効アドレスを算出します。
この命令は{\tt sq \rstwoprime, offset(\rsoneprime)}に展開されます。

\begin{comment}
C.FSW is an RV32FC-only instruction that stores a single-precision
floating-point value in floating-point register {\em \rstwoprime} to memory.  It
computes an effective address by adding the {\em zero}-extended offset, scaled
by 4, to the base address in register {\em \rsoneprime}.  It expands to {\tt fsw
\rstwoprime, offset(\rsoneprime)}.
\end{comment}
C.FSWはRV32FC限定の命令で、浮動小数点レジスタ{\em \rstwoprime}の単精度浮動小数点値をメモリにストアします。
レジスタのベースアドレス{\em \rsoneprime}に{\em ゼロ拡張}された即値を4倍に拡張されたオフセットを加算して実効アドレスを算出します。
この命令は{\tt fsw \rstwoprime, offset(\rsoneprime)}に展開されます。

\begin{comment}
C.FSD is an RV32DC/RV64DC-only instruction that stores a double-precision
floating-point value in floating-point register {\em \rstwoprime} to memory.  It
computes an effective address by adding the {\em zero}-extended offset, scaled
by 8, to the base address in register {\em \rsoneprime}.  It expands to {\tt fsd
\rstwoprime, offset(\rsoneprime)}.
\end{comment}
C.FSDはRV32DC/RV64DC限定の命令で、浮動小数点レジスタ{\em \rstwoprime}の倍精度浮動小数点値をメモリにストアします。
レジスタのベースアドレス{\em \rsoneprime}に{\em ゼロ拡張}された即値を8倍に拡張されたオフセットを加算して実効アドレスを算出します。
この命令は{\tt fsd \rstwoprime, offset(\rsoneprime)}に展開されます。

\begin{comment}
\section{Control Transfer Instructions}
\end{comment}
\section{制御転送命令}

\begin{comment}
RVC provides unconditional jump instructions and conditional branch
instructions. As with base RVI instructions, the offsets of all RVC
control transfer instruction are in multiples of 2 bytes.
\end{comment}
RVCは、無条件のジャンプ命令と条件付きの分岐命令を提供します。
RVIの基本命令と同様に、すべてのRVC制御転送命令のオフセットは2バイトの倍数です。

\begin{center}
\begin{tabular}{S@{}L@{}Y}
\\
\instbitrange{15}{13} &
\instbitrange{12}{2} &
\instbitrange{1}{0} \\
\hline
\multicolumn{1}{|c|}{funct3} &
\multicolumn{1}{c|}{imm} &
\multicolumn{1}{c|}{op} \\
\hline
3 & 11 & 2 \\
C.J & offset[11$\vert$4$\vert$9:8$\vert$10$\vert$6$\vert$7$\vert$3:1$\vert$5] & C1 \\
C.JAL & offset[11$\vert$4$\vert$9:8$\vert$10$\vert$6$\vert$7$\vert$3:1$\vert$5] & C1 \\
\end{tabular}
\end{center}
\begin{comment}
These instructions use the CJ format.
\end{comment}
これらの命令はCJフォーマットを使用しています。

\begin{comment}
C.J performs an unconditional control transfer.  The offset is sign-extended and
added to the {\tt pc} to form the jump target address.  C.J can therefore target
a $\pm$\wunits{2}{KiB} range.  C.J expands to {\tt jal x0, offset}.
\end{comment}
C.Jは無条件の制御転送を行います。
オフセットは符号拡張され、{\tt pc}に加算されてジャンプターゲットアドレスとなります。
このため、C.Jは$pm$\wunits{2}{KiB}の範囲をターゲットにすることができます。
C.Jは{\tt jal x0, offset}に展開されます。

\begin{comment}
C.JAL is an RV32C-only instruction that performs the same operation as C.J,
but additionally writes the address of the instruction following the jump
({\tt pc}+2) to the link register, {\tt x1}.  C.JAL expands to {\tt jal x1,
offset}.
\end{comment}
C.JALはRV32C専用命令で、C.Jと同様の動作を行いますが、ジャンプ後の命令({\tt pc}+2)のアドレスをリンクレジスタ{\tt x1}に書き込む機能を持っています。
C.JALは{\tt jal x1, offset}に展開されます。


\begin{center}
\begin{tabular}{E@{}T@{}T@{}Y}
\\
\instbitrange{15}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{2} &
\instbitrange{1}{0} \\
\hline
\multicolumn{1}{|c|}{funct4} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{op} \\
\hline
4 & 5 & 5 & 2 \\
C.JR & src$\neq$0 & 0 & C2 \\
C.JALR & src$\neq$0 & 0 & C2 \\
\end{tabular}
\end{center}
\begin{comment}
These instructions use the CR format.
\end{comment}
これらの命令はCRフォーマットに展開されます。

\begin{comment}
C.JR (jump register) performs an unconditional control transfer to
the address in register {\em rs1}.  C.JR expands to {\tt jalr x0, 0(rs1)}.
C.JR is only valid when $\textit{rs1}{\neq}\texttt{x0}$; the code point
with $\textit{rs1}{=}\texttt{x0}$ is reserved.
\end{comment}
C.JR (jump register)は、無条件でレジスタ {\em rs1} のアドレスへの制御転送を行います。
C.JR は {\tt jalr x0, 0(rs1)} に展開されます。
C.JRは、$\textit{rs1}{\neq}\texttt{x0}$ のときのみ有効で、$\textit{rs1}{=}\texttt{x0}$のコードポイントは予約されています。

\begin{comment}
C.JALR (jump and link register) performs the same operation as C.JR,
but additionally writes the address of the instruction following the
jump ({\tt pc}+2) to the link register, {\tt x1}.  C.JALR expands to
{\tt jalr x1, 0(rs1)}.
C.JALR is only valid when $\textit{rs1}{\neq}\texttt{x0}$; the code point
with $\textit{rs1}{=}\texttt{x0}$ corresponds to the C.EBREAK instruction.
\end{comment}
C.JALR(jump and link register)は、C.JRと同じ動作をしますが、ジャンプの次の命令({\tt pc}+2)のアドレスをリンクレジスタ({\tt x1})に追加で書き込みます。
C.JALRは、{\tt jalr x1, 0(rs1)}に展開されます。
C.JALRは、$\textit{rs1}{=}\texttt{x0}$のときのみ有効で、$\textit{rs1}{=}\texttt{x0}$のコードポイントがC.EBREAK命令に相当します。

\begin{commentary}
\begin{comment}
Strictly speaking, C.JALR does not expand exactly to a base RVI
instruction as the value added to the PC to form the link address is 2
rather than 4 as in the base ISA, but supporting both offsets of 2 and
4 bytes is only a very minor change to the base microarchitecture.
\end{comment}
厳密に言えば、C.JALRはベースRVI命令と同じようには拡張されません。
リンクアドレスを形成するためにPCに追加される値は、ベースISAの4ではなく2となりますが、
2バイトと4バイトの両方のオフセットをサポートすることは、ベースマイクロアーキテクチャに対する非常に小さな変更にすぎません。
\end{commentary}

\begin{center}
\begin{tabular}{S@{}S@{}S@{}T@{}Y}
\\
\instbitrange{15}{13} &
\instbitrange{12}{10} &
\instbitrange{9}{7} &
\instbitrange{6}{2} &
\instbitrange{1}{0} \\
\hline
\multicolumn{1}{|c|}{funct3} &
\multicolumn{1}{c|}{imm} &
\multicolumn{1}{c|}{\rsoneprime} &
\multicolumn{1}{c|}{imm} &
\multicolumn{1}{c|}{op} \\
\hline
3 & 3 & 3 & 5 & 2 \\
C.BEQZ & offset[8$\vert$4:3] & src & offset[7:6$\vert$2:1$\vert$5] & C1 \\
C.BNEZ & offset[8$\vert$4:3] & src & offset[7:6$\vert$2:1$\vert$5] & C1 \\
\end{tabular}
\end{center}
\begin{comment}
These instructions use the CB format.
\end{comment}
これらの命令はCBフォーマットを使用します。

\begin{comment}
C.BEQZ performs conditional control transfers.  The offset is sign-extended
and added to the {\tt pc} to form the branch target address.  It can
therefore target a $\pm$\wunits{256}{B} range.  C.BEQZ takes the branch if the
value in register {\em \rsoneprime} is zero.  It expands to {\tt beq \rsoneprime, x0,
offset}.
\end{comment}
C.BEQZは条件付きの制御転送を行います。
オフセットは符号拡張され、分岐先のアドレスに加算されます。
このため、$\pm$\wunits{256}{B}の範囲をターゲットにすることができます。
C.BEQZは、レジスタの値が0の場合に分岐します。
この命令は{\tt beq \rsoneprime, x0, offset}のように展開されます。

\begin{comment}
C.BNEZ is defined analogously, but it takes the branch if {\em \rsoneprime} contains
a nonzero value.  It expands to {\tt bne \rsoneprime, x0, offset}.
\end{comment}
C.BNEZも同様に定義されていますが、{\em \rsoneprime}が0以外の値を含んでいる場合に分岐します。
C.BNEZは{\tt bne \rsoneprime, x0, offset}に展開されます。

\begin{comment}
\section{Integer Computational Instructions}
\end{comment}
\section{整数算術演算命令}

\begin{comment}
RVC provides several instructions for integer arithmetic and constant generation.
\end{comment}
RVCはいくつかの整数算術演算と定数生成のための命令を用意しています。

\begin{comment}
\subsection*{Integer Constant-Generation Instructions}
\end{comment}
\subsection*{整数定数生成命令}

\begin{comment}
The two constant-generation instructions both use the CI instruction
format and can target any integer register.
\end{comment}
2つの定数生成命令はどちらもCIフォーマットを使用しており、任意の整数レジスタをターゲットとすることができます。

\vspace{-0.4in}
\begin{center}
\begin{tabular}{S@{}W@{}T@{}T@{}Y}
\\
\instbitrange{15}{13} &
\multicolumn{1}{c}{\instbit{12}} &
\instbitrange{11}{7} &
\instbitrange{6}{2} &
\instbitrange{1}{0} \\
\hline
\multicolumn{1}{|c|}{funct3} &
\multicolumn{1}{c|}{imm[5]} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{imm[4:0]} &
\multicolumn{1}{c|}{op} \\
\hline
3 & 1 & 5 & 5 & 2 \\
C.LI     & imm[5] & dest$\neq$0 & imm[4:0] & C1 \\
C.LUI    & nzimm[17] & $\textrm{dest}{\neq}{\left\{0,2\right\}}$ & nzimm[16:12] & C1 \\
\end{tabular}
\end{center}
\begin{comment}
C.LI loads the sign-extended 6-bit immediate, {\em imm}, into
register {\em rd}.
C.LI expands into {\tt addi rd, x0, imm}.
C.LI is only valid when {\em rd}$\neq${\tt x0};
the code points with {\em rd}={\tt x0} encode HINTs.
\end{comment}
C.LIは、符号拡張された6ビットの即値データである{\em imm}をレジスタ{\em rd}にロードします。
C.LIは、{\tt addi rd, x0, imm}に展開されます。
C.LIは、{\em rd}$\neq${\tt x0}の時のみ有効で、{\em rd}={\tt x0}のコードポイントはHINT命令にエンコードされます。

\begin{comment}
C.LUI loads the non-zero 6-bit immediate field into bits 17--12 of the
destination register, clears the bottom 12 bits, and sign-extends bit
17 into all higher bits of the destination.
C.LUI expands into {\tt lui rd, nzimm}.
C.LUI is only valid when
$\textit{rd}{\neq}{\left\{\texttt{x0},\texttt{x2}\right\}}$,
and when the immediate is not equal to zero.
The code points with {\em nzimm}=0 are reserved; the remaining code points
with {\em rd}={\tt x0} are HINTs; and the remaining code points with
{\em rd}={\tt x2} correspond to the C.ADDI16SP instruction.
\end{comment}
C.LUIは、非ゼロの6ビット即値フィールドを書き込みレジスタのビット17--12にロードし、下位12ビットをクリアして、ビット17をデスティネーションのすべての上位ビットに符号拡張します。
C.LUIは{\tt lui rd, nzimm}に展開されます。
C.LUIは、$\textit{rd}{\neq}{\left\{\texttt{x0},\texttt{x2}\right\}}$のとき、即値が0でないときのみ有効です。
{\em nzimm}=0のコードポイントは予約されています。
{\em rd}={\tt x0}のコードポイントはHINT、{\em rd}={\tt x2}のコードポイントはC.ADDI16SP命令に対応しています。

\begin{comment}
\subsection*{Integer Register-Immediate Operations}
\end{comment}
\subsection*{整数レジスタ-即値演算}

\begin{comment}
These integer register-immediate operations are encoded in the CI
format and perform operations on an integer register and
a 6-bit immediate.
\end{comment}
これらの整数レジスタ-即値演算は、CIフォーマットでエンコードされ、整数レジスタと6ビット即値の演算を行います。

\vspace{-0.4in}
\begin{center}
\begin{tabular}{S@{}W@{}T@{}T@{}Y}
\\
\instbitrange{15}{13} &
\multicolumn{1}{c}{\instbit{12}} &
\instbitrange{11}{7} &
\instbitrange{6}{2} &
\instbitrange{1}{0} \\
\hline
\multicolumn{1}{|c|}{funct3} &
\multicolumn{1}{c|}{imm[5]} &
\multicolumn{1}{c|}{rd/rs1} &
\multicolumn{1}{c|}{imm[4:0]} &
\multicolumn{1}{c|}{op} \\
\hline
3 & 1 & 5 & 5 & 2 \\
C.ADDI     & nzimm[5] & dest$\neq$0 & nzimm[4:0] & C1 \\
C.ADDIW    & imm[5]   & dest$\neq$0 & imm[4:0] & C1 \\
C.ADDI16SP & nzimm[9] & 2 & nzimm[4$\vert$6$\vert$8:7$\vert$5] & C1 \\
\end{tabular}
\end{center}

\begin{comment}
C.ADDI adds the non-zero sign-extended 6-bit immediate to the value in
register {\em rd} then writes the result to {\em rd}.  C.ADDI expands
into {\tt addi rd, rd, nzimm}.
C.ADDI is only valid when {\em rd}$\neq${\tt x0} and {\em nzimm}$\neq$0.
The code points with {\em rd}={\tt x0} encode the C.NOP instruction;
the remaining code points with {\em nzimm}=0 encode HINTs.
\end{comment}
C.ADDIは、0ではない符号拡張された6ビットの即値を、レジスタ{\em rd}の値に加算し、その結果を{\em rd}に書き込みます。
C.ADDIは、{\tt addi rd, rd, nzimm}に展開されます。
{\em rd}={\tt x0}のC.ADDIは、C.NOP命令を表します。
また、C.NOP命令のコードポイントのうち、{\em nzimm}=0のコードポイントはHINTを表します。

\begin{comment}
C.ADDIW is an RV64C/RV128C-only instruction that performs the same
computation but produces a 32-bit result, then sign-extends result to
64 bits.  C.ADDIW expands into {\tt addiw rd, rd, imm}.  The
immediate can be zero for C.ADDIW, where this corresponds to {\tt
sext.w rd}.  C.ADDIW is only valid when {\em rd}$\neq${\tt x0};
the code points with {\em rd}={\tt x0} are reserved.
\end{comment}
C.ADDIWはRV64C/RV128C専用の命令で、同じ計算をして32ビットの結果を生成し、その結果を符号拡張して64ビットにします。
C.ADDIWは{\tt addiw rd, rd, imm}に展開されます。
C.ADDIWの場合、即値が0になることもあり、その場合は{\tt sext.w rd}に対応します。
C.ADDIWは、C.ADDIWのコードポイントのうち、{\em rd}$\neq${\tt x0}のときのみ有効で、
{\em rd}={\tt x0} のコードポイントは予約されています。

\begin{comment}
C.ADDI16SP shares the opcode with C.LUI, but has a destination field
of {\tt x2}. C.ADDI16SP adds the non-zero sign-extended 6-bit immediate to
the value in the stack pointer ({\tt sp}={\tt x2}), where the
immediate is scaled to represent multiples of 16 in the range
(-512,496). C.ADDI16SP is used to adjust the stack pointer in procedure
prologues and epilogues.  It expands into {\tt addi x2, x2, nzimm}.
C.ADDI16SP is only valid when {\em nzimm}$\neq$0;
the code point with {\em nzimm}=0 is reserved.
\end{comment}
C.ADDI16SPはC.LUIとオペコードを共有しますが、書き込みレジスタフィールドは{\tt x2}となります。
C.ADDI16SPは、非ゼロの符号拡張された6ビットの即値をスタックポインタの値({\tt sp}={\tt x2})に加算します。
即値は、(-512,496)の範囲で16の倍数を表すようにスケーリングされます。
C.ADDI16SPは、プロローグやエピローグのスタックポインタの調整に使用されます。
この命令は{\tt addi x2, x2, nzimm}に展開されます。
C.ADDI16SPは、{\em nzimm}$\neq$0のときのみ有効です。
{\em nzimm}=0の時のコードポイントは予約されています。

\begin{commentary}
\begin{comment}
In the standard RISC-V calling convention, the stack pointer {\tt sp}
is always 16-byte aligned.
\end{comment}
標準RISC-V呼び出し規約では、スタックポインタ{\tt sp}は常に16バイトにアラインされています。
\end{commentary}

\begin{center}
\begin{tabular}{@{}S@{}K@{}S@{}Y}
\\
\instbitrange{15}{13} &
\instbitrange{12}{5} &
\instbitrange{4}{2} &
\instbitrange{1}{0} \\
\hline
\multicolumn{1}{|c|}{funct3} &
\multicolumn{1}{c|}{imm} &
\multicolumn{1}{c|}{\rdprime} &
\multicolumn{1}{c|}{op} \\
\hline
3 & 8 & 3 & 2 \\
C.ADDI4SPN & nzuimm[5:4$\vert$9:6$\vert$2$\vert$3] & dest & C0 \\
\end{tabular}
\end{center}

\begin{comment}
C.ADDI4SPN is a CIW-format instruction that adds a {\em zero}-extended
non-zero immediate, scaled by 4, to the stack pointer, {\tt x2}, and
writes the result to {\tt \rdprime}.  This instruction is used
to generate pointers to stack-allocated variables, and expands to
{\tt addi \rdprime, x2, nzuimm}.
C.ADDI4SPN is only valid when {\em nzuimm}$\neq$0;
the code points with {\em nzuimm}=0 are reserved.
\end{comment}
C.ADDI4SPNはCIWフォーマットの命令で、スタックポインタに4倍に拡張した0でない即値を加え、その結果をC.ADDI4SPNに書き込みます。
この命令は、スタックに配置された変数へのポインタを生成するために使用され、{\tt addi \rdprime, x2, nzuimm}に展開されます。
C.ADDI4SPNは、{\em nzuimm}$\neq$0のときのみ有効で、{\em nzuimm}=0のときは予約されています。


\vspace{-0.4in}
\begin{center}
\begin{tabular}{S@{}W@{}T@{}T@{}Y}
\\
\instbitrange{15}{13} &
\multicolumn{1}{c}{\instbit{12}} &
\instbitrange{11}{7} &
\instbitrange{6}{2} &
\instbitrange{1}{0} \\
\hline
\multicolumn{1}{|c|}{funct3} &
\multicolumn{1}{c|}{shamt[5]} &
\multicolumn{1}{c|}{rd/rs1} &
\multicolumn{1}{c|}{shamt[4:0]} &
\multicolumn{1}{c|}{op} \\
\hline
3 & 1 & 5 & 5 & 2 \\
C.SLLI  & shamt[5] & dest$\neq$0 & shamt[4:0] & C2 \\
\end{tabular}
\end{center}

\begin{comment}
C.SLLI is a CI-format instruction that performs a logical left shift
of the value in register {\em rd} then writes the result to {\em rd}.
The shift amount is encoded in the {\em shamt} field.
For RV128C, a shift amount of zero is used to encode a shift of 64.
C.SLLI expands into {\tt slli rd, rd, shamt}, except for
RV128C with {\tt shamt=0}, which expands to {\tt slli rd, rd, 64}.
\end{comment}
C.SLLIは、レジスタに格納されている値を左論理シフトし、その結果を{\em rd}に書き込むCIフォーマットの命令です。
シフト量はフィールドに格納されます。
RV128Cの場合、シフト量0で64のシフトがエンコードされます。
C.SLLIは、{\tt slli rd, rd, shamt} に展開されますが、例外的にRV128Cの{\tt shamt=0}では{\tt slli rd, rd, 64}に展開されます。

\begin{comment}
For RV32C, {\em shamt[5]} must be zero; the code points with {\em shamt[5]}=1
are designated for custom extensions.  For RV32C and RV64C, the shift
amount must be non-zero; the code points with {\em shamt}=0 are HINTs.  For
all base ISAs, the code points with {\em rd}={\tt x0} are HINTs, except those
with {\em shamt[5]}=1 in RV32C.
\end{comment}
RV32Cでは、{\em shamt[5]}は0でなければならず、{\em shamt[5]}=1のコードポイントは、カスタム拡張に指定されています。
RV32CとRV64Cでは、シフト量は0以外でなければなりません。
全てのベースISAにおいて、RV32Cでは、{\em shamt[5]}=1のコードポイントを除き、{\em rd}={\tt x0}のコードポイントはHINTとなります。

\vspace{-0.4in}
\begin{center}
\begin{tabular}{S@{}W@{}Y@{}S@{}T@{}Y}
\\
\instbitrange{15}{13} &
\multicolumn{1}{c}{\instbit{12}} &
\instbitrange{11}{10} &
\instbitrange{9}{7} &
\instbitrange{6}{2} &
\instbitrange{1}{0} \\
\hline
\multicolumn{1}{|c|}{funct3} &
\multicolumn{1}{c|}{shamt[5]} &
\multicolumn{1}{|c|}{funct2} &
\multicolumn{1}{c|}{\rdprime/\rsoneprime} &
\multicolumn{1}{c|}{shamt[4:0]} &
\multicolumn{1}{c|}{op} \\
\hline
3 & 1 & 2 & 3 & 5 & 2 \\
C.SRLI  & shamt[5] & C.SRLI & dest & shamt[4:0] & C1 \\
C.SRAI  & shamt[5] & C.SRAI & dest & shamt[4:0] & C1 \\
\end{tabular}
\end{center}

\begin{comment}
C.SRLI is a CB-format instruction that performs a logical right shift
of the value in register {\em \rdprime} then writes the result to {\em \rdprime}.
The shift amount is encoded in the {\em shamt} field.
For RV128C, a shift amount of zero is used to encode a shift of 64.
Furthermore, the shift amount is sign-extended
for RV128C, and so the legal shift amounts are 1--31, 64, and 96--127.
C.SRLI expands into {\tt srli \rdprime, \rdprime, shamt},
except for RV128C with {\tt shamt=0}, which expands to
{\tt srli \rdprime, \rdprime, 64}.
\end{comment}
C.SRLIはCBフォーマットの命令で、レジスタの値を右論理シフトし、その結果をレジスタに書き込みます。
シフト量はフィールドに格納されています。
RV128Cでは、シフト量が0の場合、シフト量は64としてエンコードされます。
さらに、RV128Cではシフト量は符号拡張されているので、合法的なシフト量は1--31、64、96--127となります。
C.SRLIは、RV128Cの{\tt shamt=0}を除き、{\tt srli \rdprime, \rdprime, shamt}に展開されます。

\begin{comment}
For RV32C, {\em shamt[5]} must be zero; the code points with {\em shamt[5]}=1
are designated for custom extensions.  For RV32C and RV64C, the shift
amount must be non-zero; the code points with {\em shamt}=0 are HINTs.
\end{comment}
RV32Cでは、{\em shamt[5]}はゼロでなければなりません。
{\em shamt[5]}=1のコードポイントは、カスタム拡張用のコードポイントです。
RV32C、RV64Cでは、シフト量は0以外でなければならず、{\em shamt}=0のコードポイントはHINTとなります。


\begin{comment}
C.SRAI is defined analogously to C.SRLI, but instead performs an arithmetic
right shift.
C.SRAI expands to {\tt srai \rdprime, \rdprime, shamt}.
\end{comment}
C.SRAIは、C.SRLIと同様に定義されますが、算術右シフトを行います。
C.SRAIは {\tt srai \rdprime, \rdprime, shamt} に展開されます。

\begin{commentary}
\begin{comment}
Left shifts are usually more frequent than right shifts, as left
shifts are frequently used to scale address values.  Right shifts have
therefore been granted less encoding space and are placed in an
encoding quadrant where all other immediates are sign-extended.  For
RV128, the decision was made to have the 6-bit shift-amount immediate
also be sign-extended.  Apart from reducing the decode complexity, we
believe right-shift amounts of 96--127 will be more useful than 64--95,
to allow extraction of tags located in the high portions of 128-bit
address pointers.  We note that RV128C will not be frozen at the same
point as RV32C and RV64C, to allow evaluation of typical usage of
128-bit address-space codes.
\end{comment}
左シフトはアドレス値のスケーリングに頻繁に使用されるため、通常、左シフトは右シフトよりも頻繁に使用されます。
そのため、右シフトの符号化スペースは少なく、他の即値が符号拡張されたエンコーディングクアドラントに配置されています。
RV128では、6ビットのシフト量即時値も符号拡張されることになりました。
デコードの複雑さを軽減するだけでなく、128ビットのアドレスポインタの上位部分にあるタグを抽出するためには、64～95よりも96～127の右シフト量の方が有用であると考えています。
なお、RV128Cは、RV32CやRV64Cと同じ時点では凍結されず、128ビットアドレス空間コードの典型的な使い方を評価できるようになっています。
\end{commentary}

\begin{center}
\begin{tabular}{S@{}W@{}Y@{}S@{}T@{}Y}
\\
\instbitrange{15}{13} &
\multicolumn{1}{c}{\instbit{12}} &
\instbitrange{11}{10} &
\instbitrange{9}{7} &
\instbitrange{6}{2} &
\instbitrange{1}{0} \\
\hline
\multicolumn{1}{|c|}{funct3} &
\multicolumn{1}{c|}{imm[5]} &
\multicolumn{1}{|c|}{funct2} &
\multicolumn{1}{c|}{\rdprime/\rsoneprime} &
\multicolumn{1}{c|}{imm[4:0]} &
\multicolumn{1}{c|}{op} \\
\hline
3 & 1 & 2 & 3 & 5 & 2 \\
C.ANDI  & imm[5] & C.ANDI & dest & imm[4:0] & C1 \\
\end{tabular}
\end{center}

\begin{comment}
C.ANDI is a CB-format instruction that computes the bitwise AND of
the value in register {\em \rdprime} and the sign-extended 6-bit immediate,
then writes the result to {\em \rdprime}.
C.ANDI expands to {\tt andi \rdprime, \rdprime, imm}.
\end{comment}
C.ANDIは、レジスタ{\em \rdprime}の値と符号拡張された6ビットの即値とのビット毎のANDを計算し、
その結果をレジスタ{\em \rdprime}に書き込むCB形式の命令です。
C.ANDIは{\tt andi \rdprime, \rdprime, imm}に展開されます。

\subsection*{Integer Register-Register Operations}
\vspace{-0.4in}
\begin{center}
\begin{tabular}{E@{}T@{}T@{}Y}
\\
\instbitrange{15}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{2} &
\instbitrange{1}{0} \\
\hline
\multicolumn{1}{|c|}{funct4} &
\multicolumn{1}{c|}{rd/rs1} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{op} \\
\hline
4 & 5 & 5 & 2 \\
C.MV & dest$\neq$0 & src$\neq$0 & C2 \\
C.ADD & dest$\neq$0 & src$\neq$0 & C2 \\
\end{tabular}
\end{center}
\begin{comment}
These instructions use the CR format.
\end{comment}
これらの命令はCRフォーマットを使用します。

\begin{comment}
C.MV copies the value in register {\em rs2} into register {\em rd}.  C.MV
expands into {\tt add rd, x0, rs2}.
C.MV is only valid when $\textit{rs2}{\neq}\texttt{x0}$; the code points
with $\textit{rs2}{=}\texttt{x0}$ correspond to the C.JR instruction.
The code points with $\textit{rs2}{\neq}\texttt{x0}$ and
$\textit{rd}{=}\texttt{x0}$ are HINTs.
\end{comment}
C.MV は、レジスタ{\em rs2}の値をレジスタ{\em rd}にコピーします。
C.MVは、{\tt add rd, x0, rs2}に展開されます。
C.MVは、$\textit{rs2}{\neq}\texttt{x0}$のときのみ有効で、$\textit{rs2}{=}\texttt{x0}$のコードポイントがC.JR命令に対応します。
また、$\textit{rs2}{\neq}\texttt{x0}$、$\textit{rd}{=}\texttt{x0}$のコードポイントはHINTです。

\begin{commentary}
\begin{comment}
C.MV expands to a different instruction than the canonical MV
pseudoinstruction, which instead uses ADDI. Implementations that handle MV
specially, e.g. using register-renaming hardware, may find it more convenient
to expand C.MV to MV instead of ADD, at slight additional hardware cost.
\end{comment}
C.MVは、正規のMV疑似命令とは異なる命令に展開され、代わりにADDIが使用されます。
MVを特別に扱う実装(レジスタリネームハードウェアなど)では、C.MVをADDではなくMVに展開した方が便利な場合がありますが、ハードウェアのコストが若干かかります。
\end{commentary}

\begin{comment}
C.ADD adds the values in registers {\em rd} and {\em rs2} and writes the
result to register {\em rd}.  C.ADD expands into {\tt add rd, rd, rs2}.
C.ADD is only valid when $\textit{rs2}{\neq}\texttt{x0}$; the code points
with $\textit{rs2}{=}\texttt{x0}$ correspond to the C.JALR and C.EBREAK instructions.
The code points with $\textit{rs2}{\neq}\texttt{x0}$ and
$\textit{rd}{=}\texttt{x0}$ are HINTs.
\end{comment}
C.ADDは、レジスタの値を加算し、その結果をレジスタに書き込みます。
C.ADDは、{\tt add rd, rd, rs2}に展開されます。
C.ADDは，$\textit{rs2}{=}\texttt{x0}$のときのみ有効であり、$\textit{rs2}{=}\texttt{x0}$のコードポイントは、
C.JALR命令，C.EBREAK命令に対応します。
$\textit{rs2}{\neq}\texttt{x0}$ かつ $\textit{rd}{=}\texttt{x0}$ の時のコードポイントはHINTです。

\vspace{-0.4in}
\begin{center}
\begin{tabular}{M@{}S@{}Y@{}S@{}Y}
\\
\instbitrange{15}{10} &
\instbitrange{9}{7} &
\instbitrange{6}{5} &
\instbitrange{4}{2} &
\instbitrange{1}{0} \\
\hline
\multicolumn{1}{|c|}{funct6} &
\multicolumn{1}{c|}{\rdprime/\rsoneprime} &
\multicolumn{1}{c|}{funct2} &
\multicolumn{1}{c|}{\rstwoprime} &
\multicolumn{1}{c|}{op} \\
\hline
6 & 3 & 2 & 3 & 2 \\
C.AND  & dest & C.AND  & src & C1 \\
C.OR   & dest & C.OR   & src & C1 \\
C.XOR  & dest & C.XOR  & src & C1 \\
C.SUB & dest & C.SUB & src & C1 \\
C.ADDW & dest & C.ADDW & src & C1 \\
C.SUBW & dest & C.SUBW & src & C1 \\
\end{tabular}
\end{center}

These instructions use the CA format.

C.AND computes the bitwise AND of the values in registers {\em \rdprime}
and {\em \rstwoprime}, then writes the result to register {\em \rdprime}.
C.AND expands into {\tt and \rdprime, \rdprime, \rstwoprime}.

C.OR computes the bitwise OR of the values in registers {\em \rdprime}
and {\em \rstwoprime}, then writes the result to register {\em \rdprime}.
C.OR expands into {\tt or \rdprime, \rdprime, \rstwoprime}.

C.XOR computes the bitwise XOR of the values in registers {\em \rdprime}
and {\em \rstwoprime}, then writes the result to register {\em \rdprime}.
C.XOR expands into {\tt xor \rdprime, \rdprime, \rstwoprime}.

C.SUB subtracts the value in register {\em \rstwoprime} from the value in
register {\em \rdprime}, then writes the result to register {\em \rdprime}.
C.SUB expands into {\tt sub \rdprime, \rdprime, \rstwoprime}.

C.ADDW is an RV64C/RV128C-only instruction that adds the values in
registers {\em \rdprime} and {\em \rstwoprime}, then sign-extends the lower
32 bits of the sum before writing the result to register {\em \rdprime}.
C.ADDW expands into {\tt addw \rdprime, \rdprime, \rstwoprime}.

C.SUBW is an RV64C/RV128C-only instruction that subtracts the value in
register {\em \rstwoprime} from the value in register {\em \rdprime}, then
sign-extends the lower 32 bits of the difference before writing the result
to register {\em \rdprime}. C.SUBW expands into {\tt subw \rdprime, \rdprime, \rstwoprime}.

\begin{commentary}
This group of six instructions do not provide large savings
individually, but do not occupy much encoding space and are
straightforward to implement, and as a group provide a worthwhile
improvement in static and dynamic compression.
\end{commentary}

\subsection*{Defined Illegal Instruction}
\vspace{-0.4in}
\begin{center}
\begin{tabular}{SW@{}T@{}T@{}Y}
\\
\instbitrange{15}{13} &
\multicolumn{1}{c}{\instbit{12}} &
\instbitrange{11}{7} &
\instbitrange{6}{2} &
\instbitrange{1}{0} \\
\hline
\multicolumn{1}{|c|}{0} &
\multicolumn{1}{c|}{0} &
\multicolumn{1}{c|}{0} &
\multicolumn{1}{c|}{0} &
\multicolumn{1}{c|}{0} \\
\hline
3 & 1 & 5 & 5 & 2 \\
0 & 0 & 0 & 0 & 0 \\
\end{tabular}
\end{center}

A 16-bit instruction with all bits zero is permanently reserved as an
illegal instruction.
\begin{commentary}
We reserve all-zero instructions to be illegal instructions to help
trap attempts to execute zero-ed or non-existent portions of the
memory space.  The all-zero value should not be redefined in any
non-standard extension.  Similarly, we reserve instructions with all
bits set to 1 (corresponding to very long instructions in the RISC-V
variable-length encoding scheme) as illegal to capture another common
value seen in non-existent memory regions.
\end{commentary}

\subsection*{NOP Instruction}
\vspace{-0.4in}
\begin{center}
\begin{tabular}{SW@{}T@{}T@{}Y}
\\
\instbitrange{15}{13} &
\multicolumn{1}{c}{\instbit{12}} &
\instbitrange{11}{7} &
\instbitrange{6}{2} &
\instbitrange{1}{0} \\
\hline
\multicolumn{1}{|c|}{funct3} &
\multicolumn{1}{c|}{imm[5]} &
\multicolumn{1}{c|}{rd/rs1} &
\multicolumn{1}{c|}{imm[4:0]} &
\multicolumn{1}{c|}{op} \\
\hline
3 & 1 & 5 & 5 & 2 \\
C.NOP & 0 & 0 & 0 & C1 \\
\end{tabular}
\end{center}

C.NOP is a CI-format instruction that does not change any user-visible state,
except for advancing the {\tt pc} and incrementing any applicable performance
counters.  C.NOP expands to {\tt nop}.  C.NOP is only valid when {\em imm}=0;
the code points with {\em imm}$\neq$0 encode HINTs.

\subsection*{Breakpoint Instruction}
\vspace{-0.4in}
\begin{center}
\begin{tabular}{E@{}U@{}Y}
\\
\instbitrange{15}{12} &
\instbitrange{11}{2} &
\instbitrange{1}{0} \\
\hline
\multicolumn{1}{|c|}{funct4} &
\multicolumn{1}{c|}{0} &
\multicolumn{1}{c|}{op} \\
\hline
4 & 10 & 2 \\
C.EBREAK & 0 & C2 \\
\end{tabular}
\end{center}

Debuggers can use the C.EBREAK instruction, which expands to {\tt ebreak},
to cause control to be transferred back to the debugging environment.
C.EBREAK shares the opcode with the C.ADD instruction, but with {\em
  rd} and {\em rs2} both zero, thus can also use the CR format.

\section{Usage of C Instructions in LR/SC Sequences}

On implementations that support the C extension, compressed forms of the
I instructions permitted inside constrained LR/SC sequences, as described in
Section~\ref{sec:lrscseq}, are also permitted inside constrained LR/SC
sequences.

\begin{commentary}
The implication is that any implementation that claims to support both
the A and C extensions must ensure that LR/SC sequences containing
valid C instructions will eventually complete.
\end{commentary}

\section{HINT Instructions}
\label{sec:rvc-hints}

A portion of the RVC encoding space is reserved for microarchitectural HINTs.
Like the HINTs in the RV32I base ISA (see Section~\ref{sec:rv32i-hints}),
these instructions do not modify any architectural state, except for advancing
the {\tt pc} and any applicable performance counters.  HINTs are
executed as no-ops on implementations that ignore them.

RVC HINTs are encoded as computational instructions that do not modify the
architectural state, either because {\em rd}={\tt x0}
(e.g. \mbox{C.ADD {\em x0}, {\em t0}}), or because {\em rd} is overwritten
with a copy of itself (e.g. \mbox{C.ADDI {\em t0}, 0}).

\begin{commentary}
This HINT encoding has been chosen so that simple implementations can ignore
HINTs altogether, and instead execute a HINT as a regular computational
instruction that happens not to mutate the architectural state.
\end{commentary}

RVC HINTs do not necessarily expand to their RVI HINT counterparts.  For
example, \mbox{C.ADD {\em x0}, {\em t0}} might not encode the same HINT
as \mbox{ADD {\em x0}, {\em x0}, {\em t0}}.

\begin{commentary}
The primary reason to not require an RVC HINT to expand to an RVI HINT
is that HINTs are unlikely to be compressible in the same manner as
the underlying computational instruction.  Also, decoupling the RVC
and RVI HINT mappings allows the scarce RVC HINT space to be allocated
to the most popular HINTs, and in particular, to HINTs that are
amenable to macro-op fusion.
\end{commentary}

Table~\ref{tab:rvc-hints} lists all RVC HINT code points.  For RV32C, 78\% of
the HINT space is reserved for standard HINTs, but none are presently defined.
The remainder of the HINT space is designated for custom HINTs; no standard
HINTs will ever be defined in this subspace.

\begin{table}[hbt]
\centering
\begin{tabular}{|l|l|r|l|}
  \hline
  Instruction             & Constraints                                 & Code Points & Purpose \\ \hline \hline
  C.NOP                   & {\em nzimm}$\neq$0                          & 63          & \multirow{6}{*}{\em Reserved for future standard use} \\ \cline{1-3}
  C.ADDI                  & {\em rd}$\neq${\tt x0}, {\em nzimm}=0       & 31          & \\ \cline{1-3}
  C.LI                    & {\em rd}={\tt x0}                           & 64          & \\ \cline{1-3}
  C.LUI                   & {\em rd}={\tt x0}, {\em nzimm}$\neq$0       & 63          & \\ \cline{1-3}
  C.MV                    & {\em rd}={\tt x0}, {\em rs2}$\neq${\tt x0}  & 31          & \\ \cline{1-3}
  C.ADD                   & {\em rd}={\tt x0}, {\em rs2}$\neq${\tt x0}  & 31          & \\ \hline \hline
  \multirow{2}{*}{C.SLLI} & \multirow{2}{*}{{\em rd}={\tt x0}, {\em nzimm}$\neq$0} & 31 (RV32)   & \multirow{6}{*}{\em Designated for custom use} \\
                          &                                             & 63 (RV64/128) & \\ \cline{1-3}
  C.SLLI64                & {\em rd}={\tt x0}                           & 1           & \\ \cline{1-3}
  C.SLLI64                & {\em rd}$\neq${\tt x0}, RV32 and RV64 only  & 31          & \\ \cline{1-3}
  C.SRLI64                & RV32 and RV64 only                          & 8           & \\ \cline{1-3}
  C.SRAI64                & RV32 and RV64 only                          & 8           & \\ \hline
\end{tabular}
\caption{RVC HINT instructions.}
\label{tab:rvc-hints}
\end{table}

\clearpage

\section{RVC Instruction Set Listings}

Table~\ref{rvcopcodemap} shows a map of the major opcodes for RVC.
Each row of the table corresponds to one quadrant of the encoding
space.  The last quadrant, which has the two
least-significant bits set, corresponds to instructions wider
than 16 bits, including those in the base ISAs.  Several instructions
are only valid for certain operands; when invalid, they are marked
either {\em RES} to indicate that the opcode is reserved for future
standard extensions; {\em Custom} to indicate that the opcode is designated
for custom extensions; or {\em HINT} to indicate that the opcode
is reserved for microarchitectural hints (see Section~\ref{sec:rvc-hints}).

\input{rvc-opcode-map}

Tables~\ref{rvc-instr-table0}--\ref{rvc-instr-table2} list the RVC instructions.
\input{rvc-instr-table}
