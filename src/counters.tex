\begin{comment}
\chapter{Counters}
\end{comment}
\chapter{カウンタ}
\label{counters}

\begin{comment}
RISC-V ISAs provide a set of up to 32$\times$64-bit performance counters and
timers that are accessible via unprivileged XLEN read-only CSR
registers {\tt 0xC00}--{\tt 0xC1F} (with the upper 32 bits accessed
via CSR registers {\tt 0xC80}--{\tt 0xC9F} on RV32).  The first three
of these (CYCLE, TIME, and INSTRET) have dedicated functions (cycle
count, real-time clock, and instructions-retired respectively), while
the remaining counters, if implemented, provide programmable event
counting.
\end{comment}

RISC-V ISAでは、最大32$\times$64ビットのパフォーマンスカウンターとタイマが用意されており、
特権のないXLEN読み取り専用CSRレジスタ{\tt 0xC00}--{\tt 0xC1F}を介してアクセスできます
(RV32では上位32ビットがCSRレジスタ{\tt 0xC80}--{tt 0xC9F}を介してアクセスされます)。 
これらのうち、最初の3つ(CYCLE、TIME、INSTRET)は、それぞれ専用の機能(サイクルカウント、リアルタイムクロック、命令完了)を持ち、
残りのカウンタは、実装されていれば、プログラマブルなイベントカウントを提供します。

\begin{comment}
\section{Base Counters and Timers}
\end{comment}
\section{基本となるカウンタとタイマ}

\vspace{-0.2in}
\begin{center}
\begin{tabular}{M@{}R@{}F@{}R@{}S}
\\
\instbitrange{31}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{csr} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
12 & 5 & 3 & 5 & 7 \\
RDCYCLE[H]   & 0 & CSRRS  & dest & SYSTEM \\
RDTIME[H]    & 0 & CSRRS  & dest & SYSTEM \\
RDINSTRET[H] & 0 & CSRRS  & dest & SYSTEM \\
\end{tabular}
\end{center}

\begin{comment}
RV32I provides a number of 64-bit read-only user-level counters, which
are mapped into the 12-bit CSR address space and accessed in 32-bit
pieces using CSRRS instructions.  In RV64I, the CSR instructions can
manipulate 64-bit CSRs.  In particular, the RDCYCLE, RDTIME, and
RDINSTRET pseudoinstructions read the full 64 bits of the {\tt cycle},
{\tt time}, and {\tt instret} counters.  Hence, the RDCYCLEH, RDTIMEH,
and RDINSTRETH instructions are RV32I-only.
\end{comment}

RV32Iには、64ビットの読み取り専用のユーザーレベルカウンタが多数用意されており、
これらは12ビットのCSRアドレス空間にマッピングされ、CSRRS命令を用いて32ビット単位でアクセスされます。
RV64Iでは、CSR命令で64ビットのCSRを操作することができます。 
特に、RDCYCLE、RDTIME、RDINSTRETの各疑似命令は、
64ビットの{\tt cycle}, {\tt time}, {\tt instret}カウンタを完全に読み取ります。
したがって，RDCYCLEH，RDTIMEH，RDINSTRETHの各命令はRV32I専用となります。

\begin{commentary}
\begin{comment}
Some execution environments might prohibit access to counters to
impede timing side-channel attacks.
\end{comment}
実行環境によっては、タイミングサイドチャネル攻撃を防ぐためにカウンタへのアクセスを禁止する場合があります。
\end{commentary}

\begin{comment}
The RDCYCLE pseudoinstruction reads the low XLEN bits of the {\tt
  cycle} CSR which holds a count of the number of clock cycles
executed by the processor core on which the hart is running from an
arbitrary start time in the past.  RDCYCLEH is an RV32I-only
instruction that reads bits 63--32 of the same cycle counter.  The
underlying 64-bit counter should never overflow in practice.  The rate
at which the cycle counter advances will depend on the implementation
and operating environment.  The execution environment should provide a
means to determine the current rate (cycles/second) at which the cycle
counter is incrementing.
\end{comment}

RDCYCLE疑似命令は、過去の任意の開始時刻から実行されたプロセッサコアのクロックサイクル数を保持するCSRである{\tt cycle}のXLEN下位ビットを読み出します。
CSRは、過去の任意の開始時刻からhartが動作しているプロセッサコアが実行したクロックサイクル数のカウントを保持しています。
RDCYCLEHは，RV32I専用の命令で，同じサイクルカウンタの63～32ビットを読み出します。
64ビットのカウンタは、実際にはオーバーフローしないようになっています。
サイクルカウンタが進む速度は、実装や動作環境によって異なります。
実行環境では、サイクルカウンタがインクリメントしている現在のレート(サイクル／秒)を決定する手段を提供する必要があります。

\begin{commentary}
\begin{comment}
RDCYCLE is intended to return the number of cycles executed by the
processor core, not the hart.  Precisely defining what is a ``core'' is
difficult given some implementation choices (e.g., AMD Bulldozer).
Precisely defining what is a ``clock cycle'' is also difficult given the
range of implementations (including software emulations), but the
intent is that RDCYCLE is used for performance monitoring along with the
other performance counters.  In particular, where there is one
hart/core, one would expect cycle-count/instructions-retired to
measure CPI for a hart.
\end{comment}

RDCYCLEは、hartではなく、プロセッサコアで実行されたサイクル数を返すことを目的としています。
``コア''とは何かを正確に定義することは、いくつかの実装方法（例：AMD Bulldozer）を考えると困難です。
また、``クロックサイクル''を正確に定義することは、さまざまな実装(ソフトウェアのエミュレーションを含む)があるため困難ですが、
RDCYCLEを他のパフォーマンスカウンタと一緒にパフォーマンスの監視に使用することを意図しています。
特に、1つのhart/コアがある場合、サイクルカウント/実行命令数は、hartのCPIを測定すると考えられます。

\begin{comment}
Cores don't have to be exposed to software at all, and an implementor
might choose to pretend multiple harts on one physical core are
running on separate cores with one hart/core, and provide separate
cycle counters for each hart.  This might make sense in a simple
barrel processor (e.g., CDC 6600 peripheral processors) where
inter-hart timing interactions are non-existent or minimal.
\end{comment}

コアはソフトウェアに公開する必要は全くありません。
実装者は、1つの物理コア上の複数のhartが1つのharts/coreで別々のコア上で動作しているように見せかけ、
各hartsに別々のサイクルカウンタを提供することを選択するかもしれません。
これは、hart間のタイミングの相互作用が存在しないか、
最小限であるような単純なバレルプロセッサ(CDC 6600ペリフェラルプロセッサなど)では意味があるかもしれません。

\begin{comment}
Where there is more than one hart/core and dynamic multithreading, it
is not generally possible to separate out cycles per hart (especially
with SMT).  It might be possible to define a separate performance
counter that tried to capture the number of cycles a particular hart
was running, but this definition would have to be very fuzzy to cover
all the possible threading implementations.  For example, should we
only count cycles for which any instruction was issued to execution
for this hart, and/or cycles any instruction retired, or include
cycles this hart was occupying machine resources but couldn't execute
due to stalls while other harts went into execution? Likely, ``all of
the above'' would be needed to have understandable performance stats.
This complexity of defining a per-hart cycle count, and also the need
in any case for a total per-core cycle count when tuning multithreaded
code led to just standardizing the per-core cycle counter, which also
happens to work well for the common single hart/core case.
\end{comment}

複数のhart/コアが存在し、動的なマルチスレッディングが行われている場合、
hartごとのサイクルを分離することは一般的に不可能です(特にSMTの場合)。
特定のhartが実行しているサイクル数を把握するために、別のパフォーマンスカウンタを定義することは可能かもしれませんが、
この定義は、ありとあらゆるスレッディング実装をカバーするために非常に曖昧なものでなければなりません。 
例えば、このhartの実行に対して何らかの命令が発行されたサイクルや、
何らかの命令がリタイアしたサイクルのみをカウントすべきなのか、
あるいは、このhartがマシンリソースを占有していたが、他のhartが実行に移る間にストールが発生して実行できなかったサイクルも含めるべきなのか。
おそらく、パフォーマンス統計を理解するためには、``上記のすべて''が必要になるでしょう。
このように、hartごとのサイクルカウントを定義するのは複雑であり、
また、マルチスレッドのコードをチューニングする際には、
コアごとのサイクルカウントを合計する必要があるため、コアごとのサイクルカウンタを標準化することにしました。

\begin{comment}
Standardizing what happens during ``sleep'' is not practical given
that what ``sleep'' means is not standardized across execution
environments, but if the entire core is paused (entirely clock-gated
or powered-down in deep sleep), then it is not executing clock cycles,
and the cycle count shouldn't be increasing per the spec.  There are
many details, e.g., whether clock cycles required to reset a processor
after waking up from a power-down event should be counted, and these
are considered execution-environment-specific details.
\end{comment}

``スリープ''が何を意味するかが実行環境ごとに標準化されていないことを考えると、
``スリープ''中に何が起こるかを標準化することは現実的ではありませんが、
コア全体が一時停止している(完全にクロックゲーティングされているか、ディープスリープでパワーダウンしている)場合は、
クロックサイクルを実行していないことになるので、仕様上、サイクルカウントを増やすべきではありません。
例えば、パワーダウンイベントからの起動後にプロセッサをリセットするのに必要なクロックサイクルをカウントすべきかどうかなど、
多くの詳細があり、これらは実行環境固有の詳細と考えられます。

\begin{comment}
Even though there is no precise definition that works for all
platforms, this is still a useful facility for most platforms, and an
imprecise, common, ``usually correct'' standard here is better than no
standard.  The intent of RDCYCLE was primarily performance
monitoring/tuning, and the specification was written with that goal in
mind.
\end{comment}

すべてのプラットフォームに対応する正確な定義はありませんが、これはほとんどのプラットフォームにとって有用な機能であり、
ここでの不正確な、一般的な、``通常は正しい''基準は、基準がないよりはましです。
RDCYCLEの目的は、主にパフォーマンスのモニタリングやチューニングであり、仕様はその目的を念頭に置いて書かれています。

\end{commentary}

\begin{comment}
The RDTIME pseudoinstruction reads the low XLEN bits of the {\tt
  time} CSR, which counts wall-clock real time that has passed from an
arbitrary start time in the past.  RDTIMEH is an RV32I-only instruction
that reads bits 63--32 of the same real-time counter.  The underlying 64-bit
counter should never overflow in practice.  The execution environment
should provide a means of determining the period of the real-time
counter (seconds/tick).  The period must be constant.  The
real-time clocks of all harts in a single user application
should be synchronized to within one tick of the real-time clock.  The
environment should provide a means to determine the accuracy of the
clock.
\end{comment}

RDTIME疑似命令は、過去の任意の開始時刻から経過した壁時計の実時間をカウントする{\tt time}CSRの下位XLENビットを読み取ります。
CSRは、過去の任意の開始時刻から経過した壁時計の実時間をカウントします。
RDTIMEHはRV32I専用の命令で、同じリアルタイムカウンタの63～32ビットを読み出します。
実際には64ビットのカウンタがオーバーフローすることはありません。
実行環境は、リアルタイムカウンタの周期(秒/tick)を決定する手段を提供しなければならず、周期は一定でなければなりません。
1つのユーザー・アプリケーション内のすべてのhartのリアルタイム・クロックは、
リアルタイム・クロックの1ティック以内に同期していなければなりません。
環境は、クロックの精度を決定する手段を提供しなければなりません。

\begin{commentary}
\begin{comment}
On some simple platforms, cycle count might represent a valid
implementation of RDTIME, but in this case, platforms should implement
the RDTIME instruction as an alias for RDCYCLE to make code more
portable, rather than using RDCYCLE to measure wall-clock time.
\end{comment}

一部のシンプルなプラットフォームでは、サイクルカウントはRDTIMEの有効な実装を表すかもしれませんが、
この場合、プラットフォームはRDCYCLEを壁時計の時間を測定するために使用するのではなく、
コードをよりポータブルにするためにRDCYCLEの別名としてRDTIME命令を実装する必要があります。

\end{commentary}

\begin{comment}
The RDINSTRET pseudoinstruction reads the low XLEN bits of the {\tt
  instret} CSR, which counts the number of instructions retired by
this hart from some arbitrary start point in the past.  RDINSTRETH is
an RV32I-only instruction that reads bits 63--32 of the same
instruction counter. The underlying 64-bit counter should never
overflow in practice.
\end{comment}

RDINSTRET疑似命令は、{\tt instret} CSRの下位XLENビットを読み取ります。
CSRは、過去の任意の開始点からこのhartによってリタイヤされた命令の数をカウントします。
RDINSTRETHはRV32I専用の命令で、同じ命令カウンタの63～32ビットを読み取ります。
実際には、64ビットのカウンタがオーバーフローすることはありません。

\begin{comment}
The following code sequence will read a valid 64-bit cycle counter value into
{\tt x3}:{\tt x2}, even if the counter overflows its lower half between reading its upper
and lower halves.
\end{comment}

以下のコードでは、64ビットのサイクルカウンタの値が、上半分と下半分を読み取る間に下半分がオーバーフローしても、
有効な64ビットのサイクルカウンタの値を{\tt x3}:{\tt x2}に読み取ることができます。

\begin{figure}[h!]
\begin{center}
\begin{verbatim}
    again:
        rdcycleh     x3
        rdcycle      x2
        rdcycleh     x4
        bne          x3, x4, again
\end{verbatim}
\end{center}
\begin{comment}
\caption{Sample code for reading the 64-bit cycle counter in RV32.}
\end{comment}
\caption{RV32において64ビットサイクルカウンタを読み出すサンプルコード}
\label{rdcycle}
\end{figure}

\begin{commentary}
\begin{comment}
We recommend provision of these basic counters in implementations
as they are essential for basic performance analysis, adaptive and
dynamic optimization, and to allow an application to work with
real-time streams.  Additional counters should be provided to help
diagnose performance problems and these should be made accessible from
user-level application code with low overhead.
\end{comment}

これらの基本的なカウンターは、基本的な性能分析、適応的かつ動的な最適化、
およびアプリケーションがリアルタイムストリームを扱うために不可欠なものであるため、
実装において提供することを推奨します。
パフォーマンスの問題を診断するためには、追加のカウンタを提供する必要があり、
これらはユーザーレベルのアプリケーションコードから低いオーバーヘッドでアクセスできるようにする必要があります。

\begin{comment}
We required the counters be 64 bits wide, even on RV32, as otherwise
it is very difficult for software to determine if values have
overflowed.  For a low-end implementation, the upper 32 bits of each
counter can be implemented using software counters incremented by a
trap handler triggered by overflow of the lower 32 bits.  The sample
code described above shows how the full 64-bit width value can be
safely read using the individual 32-bit instructions.
\end{comment}

RV32でもカウンターは64ビット幅でなければなりません。
そうしないと、値がオーバーフローしたかどうかをソフトウェアで判断することが非常に困難になるからです。
ローエンドの実装では，各カウンタの上位32ビットを，下位32ビットのオーバーフローをトリガーとする
トラップハンドラでインクリメントするソフトウェアカウンタで実装することができます。
前述のサンプルコードでは、32ビットの各命令を使って64ビット幅の値を安全に読み取ることができました。

\begin{comment}
In some applications, it is important to be able to read multiple
counters at the same instant in time.  When run under a multitasking
environment, a user thread can suffer a context switch while
attempting to read the counters.  One solution is for the user thread
to read the real-time counter before and after reading the other
counters to determine if a context switch occurred in the middle of the
sequence, in which case the reads can be retried.  We considered
adding output latches to allow a user thread to snapshot the counter
values atomically, but this would increase the size of the user
context, especially for implementations with a richer set of counters.
\end{comment}

アプリケーションによっては、複数のカウンターを同時に読み取ることが重要な場合があります。
マルチタスク環境で実行されている場合、ユーザースレッドはカウンタを読み取ろうとする際にコンテキストスイッチを受ける可能性があります。 
解決策の1つとして，ユーザースレッドが他のカウンタを読み取る前と後にリアルタイムカウンタを読み取って、
シーケンスの途中でコンテキストスイッチが発生したかどうかを判断し、その場合には読み取りをやり直すことができます。 
ユーザースレッドがカウンタの値をアトミックにスナップショットできるように、
出力ラッチを追加することを検討しましたが、これはユーザコンテキストのサイズを増大させることになり、
特にカウンタのセットが豊富な実装の場合には問題となります。
\end{commentary}

\begin{comment}
\section{Hardware Performance Counters}
\end{comment}
\section{ハードウェアパフォーマンスカウンタ}

\begin{comment}
There is CSR space allocated for 29 additional unprivileged 64-bit
hardware performance counters, {\tt hpmcounter3}--{\tt hpmcounter31}.
For RV32, the upper 32 bits of these performance counters is
accessible via additional CSRs {\tt hpmcounter3h}--{\tt
  hpmcounter31h}.  These counters count platform-specific events and
are configured via additional privileged registers.  The number and
width of these additional counters, and the set of events they count
is platform-specific.
\end{comment}

29個の非特権の64ビットハードウェアパフォーマンスカウンター({\tt hpmcounter3}--{\tt hpmcounter31})用にCSRスペースが割り当てられています。
RV32では、これらのパフォーマンスカウンターの上位32ビットは、追加のCSRである{\tt hpmcounter3h}--{\tt hpmcounter31h}を介してアクセス可能です。
これらのカウンターは、プラットフォーム固有のイベントをカウントするもので、追加の特権的レジスタを介して設定されます。
これらのカウンターの数や幅、カウントされるイベントの種類は、プラットフォームごとに異なります。

\begin{commentary}
\begin{comment}
  The privileged architecture manual describes the privileged CSRs
  controlling access to these counters and to set the events to be
  counted.
\end{comment}
特権アーキテクチャマニュアルでは、これらのカウンターへのアクセスを制御し、カウントされるイベントを設定する特権CSRについて説明しています。

\begin{comment}
  It would be useful to eventually standardize event settings to count
  ISA-level metrics, such as the number of floating-point instructions
  executed for example, and possibly a few common microarchitectural
  metrics, such as ``L1 instruction cache misses''.
\end{comment}

最終的にはイベント設定を標準化して、例えば浮動小数点命令の実行数などのISAレベルの指標や、
``L1命令キャッシュミス''などのいくつかの共通のマイクロアーキテクチャ指標をカウントすることができれば便利です。

\end{commentary}
