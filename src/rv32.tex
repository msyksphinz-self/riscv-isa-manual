\begin{comment}
\chapter{RV32I Base Integer Instruction Set, Version 2.1}
\label{rv32}

This chapter describes the RV32I base integer instruction set.
\end{comment}

\chapter{RV32I ベース整数命令セット, Version 2.1}
\label{rv32}

本章ではRV32Iベース整数命令セットについて説明する。

\begin{comment}
\begin{commentary}
RV32I was designed to be sufficient to form a compiler target and to
support modern operating system environments.  The ISA was also
designed to reduce the hardware required in a minimal implementation.
RV32I contains 40 unique instructions, though a simple implementation
might cover the ECALL/EBREAK instructions with a single SYSTEM
hardware instruction that always traps and might be able to implement
the FENCE instruction as a NOP, reducing base instruction count to 38
total.  RV32I can emulate almost any other ISA extension (except the A
extension, which requires additional hardware support for atomicity).

In practice, a hardware implementation including the machine-mode
privileged architecture will also require the 6 CSR instructions.

Subsets of the base integer ISA might be useful for pedagogical
purposes, but the base has been defined such that there should be
little incentive to subset a real hardware implementation beyond
omitting support for misaligned memory accesses and treating all
SYSTEM instructions as a single trap.
\end{commentary}
\end{comment}

\begin{commentary}
RV32Iは、コンパイラのターゲットを形成するのに十分な性能と、最新のOS環境をサポートするように設計されています。
また、ISAは、最小限の実装で必要なハードウェアを減らすように設計されています。
RV32Iには40のユニークな命令が含まれていますが、シンプルな実装であれば、ECALL/EBREAK命令を常にトラップする1つのSYSTEMハードウェア命令でカバーしたり、
FENCE命令をNOPとして実装することで、
基本命令数を合計38に減らすことができるかもしれません。
RV32Iは、他のほとんどのISA拡張をエミュレートすることができます(アトミック性のために追加のハードウェアサポートを必要とするA拡張を除く)。

実際には、マシンモード特権アーキテクチャを含むハードウェア実装では、
6つのCSR命令も必要となります。

基本となる整数ISAのサブセットは、教育的には有用かもしれませんが、
実際のハードウェア実装では、ミスアラインド・メモリ・アクセスのサポートを省略したり、
SYSTEM命令をすべて1つのトラップとして扱ったりする以外には、
サブセット化する動機がほとんどないように定義されています。
\end{commentary}

\begin{comment}
\begin{commentary}
The standard RISC-V assembly language syntax is documented in the
Assembly Programmer's Manual~\cite{riscv-asm-manual}.
\end{commentary}
\end{comment}

\begin{commentary}
RISC-Vの標準的なアセンブリ言語の文法は、
Assembly Programmer's Manual~\cite{riscv-asm-manual}に記載されています。	
\end{commentary}

\begin{comment}
\begin{commentary}
Most of the commentary for RV32I also applies to the RV64I base.
\end{commentary}
\end{comment}

\begin{commentary}
殆どのRV32Iにおけるコメント文は、RV64Iベースにも適用できます。
\end{commentary}

\begin{comment}
\section{Programmers' Model for Base Integer ISA}

Figure~\ref{gprs} shows the unprivileged state for the base integer
ISA.  For RV32I, the 32 {\tt x} registers are each 32 bits wide, i.e.,
XLEN=32.  Register {\tt x0} is hardwired with all bits equal to 0.
General purpose registers {\tt x1}--{\tt x31} hold values that various
instructions interpret as a collection of Boolean values, or as two's
complement signed binary integers or unsigned binary integers.

There is one additional unprivileged register: the program counter {\tt pc}
holds the address of the current instruction.

\begin{figure}[H]
{\footnotesize
\begin{center}
\begin{tabular}{p{2in}}
\instbitrange{XLEN-1}{0}                                  \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ \ \ x0 / zero}}      \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ x1\ \ \ \ \ }}            \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ x2\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ x3\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ x4\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ x5\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ x6\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ x7\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ x8\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ x9\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x10\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x11\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x12\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x13\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x14\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x15\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x16\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x17\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x18\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x19\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x20\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x21\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x22\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x23\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x24\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x25\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x26\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x27\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x28\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x29\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x30\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x31\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{c}{XLEN}                                  \\

\instbitrange{XLEN-1}{0}                                  \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{pc}}                         \\ \cline{1-1}
\multicolumn{1}{c}{XLEN}                                  \\
\end{tabular}
\end{center}
}
\caption{RISC-V base unprivileged integer register state.}
\label{gprs}
\end{figure}
\end{comment}

\section{ベース整数命令のプログラマモデル}

図~\ref{gprs}は、ベース整数ISAの非特権状態を示しています。
RV32Iでは、32本のレジスタはそれぞれ32ビット幅(XLEN=32)で構成されています。
レジスタ{\tt x0}は全てのビットがゼロに固定されています。
汎用レジスタ{\tt x1} -- {\tt x31}は、ブール値の集合体、2の補数の符号付き2進整数、
符号なし2進整数として、各種命令が解釈する値を保持します。

もう一つ非特権レジスタが定義されています: プログラムカウンタ{\tt pc} は、
現在実行中の命令のアドレスを保持しています。

\begin{figure}[H]
{\footnotesize
\begin{center}
\begin{tabular}{p{2in}}
\instbitrange{XLEN-1}{0}                                  \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ \ \ x0 / zero}}      \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ x1\ \ \ \ \ }}            \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ x2\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ x3\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ x4\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ x5\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ x6\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ x7\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ x8\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ x9\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x10\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x11\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x12\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x13\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x14\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x15\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x16\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x17\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x18\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x19\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x20\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x21\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x22\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x23\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x24\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x25\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x26\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x27\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x28\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x29\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x30\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x31\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{c}{XLEN}                                  \\

\instbitrange{XLEN-1}{0}                                  \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{pc}}                         \\ \cline{1-1}
\multicolumn{1}{c}{XLEN}                                  \\
\end{tabular}
\end{center}
}
\caption{RISC-Vベース非特権整数レジスタの状態}
\label{gprs}
\end{figure}

\begin{comment}
\begin{commentary}
There is no dedicated stack pointer or subroutine return address link
register in the Base Integer ISA; the instruction encoding allows any
{\tt x} register to be used for these purposes. However, the standard
software calling convention uses register {\tt x1} to hold the return
address for a call, with register {\tt x5} available as an alternate
link register.
The standard calling convention uses register {\tt x2} as the stack
pointer.

Hardware might choose to accelerate function calls and returns that
use {\tt x1} or {\tt x5}. See the descriptions of the JAL and JALR
instructions.

The optional compressed 16-bit instruction format is designed around
the assumption that {\tt x1} is the return address register and {\tt
 x2} is the stack pointer. Software using other conventions will
operate correctly but may have greater code size.
\end{commentary}
\end{comment}

\begin{commentary}
ベース整数ISAには、専用のスタックポインタやサブルーチンのリターンアドレスのリンクレジスタはなく、
命令エンコーディングでは、どの{tt x}レジスタもこれらの目的に使用することができます。
しかし、標準的なソフトウェアの呼び出し規則では、
呼び出しのためのリターンアドレスを保持するためにレジスタ{\tt x1}を使用し、
代わりのリンクレジスタとしてレジスタ{\tt x5}を使用します。
また、標準的な呼び出し規則では、スタック・ポインタとしてレジスタ {\tt x2}を使用します。

ハードウェアでは、関数の呼び出しと戻りを高速化するために、
{\tt x1}や{\tt x5}を使用する場合があります。
JAL命令とJALR命令の説明を参照してください。

オプションの圧縮16ビット命令は、リターン・アドレス・レジスタを{\tt x1}、
スタック・ポインタを{\tt x2}と仮定して設計されています。
他の規則を利用するソフトウェアは正しく動作しますが、
コードサイズが大きくなる可能性があります。
\end{commentary}

\begin{comment}
\begin{commentary}
The number of available architectural registers can have large impacts
on code size, performance, and energy consumption.  Although 16
registers would arguably be sufficient for an integer ISA running
compiled code, it is impossible to encode a complete ISA with 16
registers in 16-bit instructions using a 3-address format.  Although a
2-address format would be possible, it would increase instruction
count and lower efficiency.  We wanted to avoid intermediate
instruction sizes (such as Xtensa's 24-bit instructions) to simplify
base hardware implementations, and once a 32-bit instruction size was
adopted, it was straightforward to support 32 integer registers.  A
larger number of integer registers also helps performance on
high-performance code, where there can be extensive use of loop
unrolling, software pipelining, and cache tiling.

For these reasons, we chose a conventional size of 32 integer
registers for the base ISA.  Dynamic register usage tends to be
dominated by a few frequently accessed registers, and regfile
implementations can be optimized to reduce access energy for the
frequently accessed registers~\cite{jtseng:sbbci}.  The optional
compressed 16-bit instruction format mostly only accesses 8 registers
and hence can provide a dense instruction encoding, while additional
instruction-set extensions could support a much larger register space
(either flat or hierarchical) if desired.

For resource-constrained embedded applications, we have defined the
RV32E subset, which only has 16 registers (Chapter~\ref{rv32e}).
\end{commentary}
\end{comment}

\begin{commentary}
利用可能なアーキテクチャレジスタの数は、コードサイズ、性能、エネルギー消費に大きな影響を与えます。 
コンパイルされたコードを実行する整数型ISAでは16本のレジスタで十分であることは間違いありませんが、
16本のレジスタを持つ完全なISAを3アドレス形式の16ビット命令でエンコードすることは不可能です。
2アドレスのフォーマットも可能ですが、命令数が増え、効率が悪くなります。
私たちは、ベースハードウェアの実装を簡素化するために、
中間的な命令サイズ(Xtensaの24ビット命令など)を避けたかったのですが、
32ビットの命令サイズが採用されたことで、32本の整数レジスタをサポートすることが容易になりました。
また、整数レジスタの数が多いほど、ループアンローリング、ソフトウェアパイプライン、
キャッシュタイリングなどが多用される高性能コードでのパフォーマンスが向上します。

これらの理由から、ベースISAでは従来のサイズである32本の整数レジスタを選択しました。
動的なレジスタの使用率は、頻繁にアクセスされるいくつかのレジスタに支配される傾向があり、
レジスタファイルの実装を最適化することで、
頻繁にアクセスされるレジスタのアクセスエネルギーを削減することができます。 
オプションの圧縮16ビット命令フォーマットは、ほとんどの場合、8本のレジスタにしかアクセスしないため、
高密度の命令エンコーディングを提供することができますが、
必要に応じて、追加の命令セット拡張により、
より大きなレジスタ空間(フラットまたは階層)をサポートすることができます。

また、リソースに制約のある組込みアプリケーション向けに、
16本のレジスタしか持たないRV32Eサブセットを定義しています(第~ref{rv32e}章)。
\end{commentary}

\begin{comment}
\section{Base Instruction Formats}

In the base RV32I ISA, there are four core instruction formats
(R/I/S/U), as shown in Figure~\ref{fig:baseinstformats}.  All are a
fixed 32 bits in length and must be aligned on a four-byte boundary in
memory.  An instruction-address-misaligned exception is generated on a
taken branch or unconditional jump if the target address is not
four-byte aligned.  This exception is reported on the branch or jump
instruction, not on the target instruction.  No
instruction-address-misaligned exception is generated for a
conditional branch that is not taken.
\end{comment}

\section{ベース命令フォーマット}

ベースとなるRV32I ISAでは、図~ref{fig:baseinstformats}に示すように、4つのコア命令フォーマット(R/I/S/U)があります。
いずれも長さは32ビット固定で、メモリ上の4バイト境界上にアラインメントする必要があります。 
命令-アドレス-ミスアラインド例外は、ターゲットアドレスが4バイトアラインドでない場合、
ブランチ成立時または無条件ジャンプで生成されます。
この例外は、ターゲット命令ではなく、分岐命令やジャンプ命令で報告されます。
不成立の条件付き分岐では、命令-アドレス-misaligned例外は発生しません。

\begin{comment}
\begin{commentary}
The alignment constraint for base ISA instructions is relaxed to a
two-byte boundary when instruction extensions with 16-bit lengths or
other odd multiples of 16-bit lengths are added (i.e., IALIGN=16).

Instruction-address-misaligned exceptions are reported on the branch
or jump that would cause instruction misalignment to help debugging,
and to simplify hardware design for systems with IALIGN=32, where these
are the only places where misalignment can occur.
\end{commentary}
\end{comment}

\begin{commentary}
ベースISA命令のアライメント制約は、16ビット長または16ビット長の奇数倍の
命令拡張が追加されると、2バイト境界に緩和されます(IALIGN=16)。

命令-アドレス-ミスアラインドの例外は、命令のミスアラインメントの原因となる
分岐やジャンプの際に報告され、デバッグを助け、また、IALIGN=32のシステムでは、
これらの場所でしかミスアラインメントが発生しないため、ハードウェアの設計を簡素化されます。
\end{commentary}

\begin{comment}
The behavior upon decoding a reserved instruction is \unspecified.
\begin{commentary}
Some platforms may require that opcodes reserved for standard use raise
an illegal-instruction exception.
Other platforms may permit reserved opcode space be used for non-conforming
extensions.
\end{commentary}
\end{comment}

予約された命令をデコードしたときの動作は``不定''です。

\begin{commentary}
プラットフォームによっては、標準的な使用のために予約されたオペコードが、
不正命令例外を発生させることを要求する場合があります。
他のプラットフォームでは、予約されたオペコード領域を規格化されていない拡張に
使用することを許可する場合があります。
\end{commentary}

\begin{comment}
\begin{figure}[h]
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{p{1.2in}@{}p{0.8in}@{}p{0.8in}@{}p{0.6in}@{}p{0.8in}@{}p{1in}l}
\\
\instbitrange{31}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\cline{1-6}
\multicolumn{1}{|c|}{funct7} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} &
R-type \\
\cline{1-6}
\\
\cline{1-6}
\multicolumn{2}{|c|}{imm[11:0]} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} &
I-type \\
\cline{1-6}
\\
\cline{1-6}
\multicolumn{1}{|c|}{imm[11:5]} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{imm[4:0]} &
\multicolumn{1}{c|}{opcode} &
S-type \\
\cline{1-6}
\\
\cline{1-6}
\multicolumn{4}{|c|}{imm[31:12]} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} &
U-type \\
\cline{1-6}
\end{tabular}
\end{center}
\caption{RISC-V base instruction formats.  Each immediate subfield is
  labeled with the bit position (imm[{\em x}\,]) in the immediate
  value being produced, rather than the bit position within the
  instruction's immediate field as is usually done.  }
\label{fig:baseinstformats}
\end{figure}
\end{comment}

\begin{figure}[h]
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{p{1.2in}@{}p{0.8in}@{}p{0.8in}@{}p{0.6in}@{}p{0.8in}@{}p{1in}l}
\\
\instbitrange{31}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\cline{1-6}
\multicolumn{1}{|c|}{funct7} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} &
R-type \\
\cline{1-6}
\\
\cline{1-6}
\multicolumn{2}{|c|}{imm[11:0]} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} &
I-type \\
\cline{1-6}
\\
\cline{1-6}
\multicolumn{1}{|c|}{imm[11:5]} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{imm[4:0]} &
\multicolumn{1}{c|}{opcode} &
S-type \\
\cline{1-6}
\\
\cline{1-6}
\multicolumn{4}{|c|}{imm[31:12]} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} &
U-type \\
\cline{1-6}
\end{tabular}
\end{center}
\caption{RISC-Vの基本命令フォーマット。 各即値サブフィールドには、
通常、命令の即値フィールド内のビット位置ではなく、
生成される即値のビット位置(imm[{\em x}\,])が表示されます}
\label{fig:baseinstformats}
\end{figure}

\begin{comment}
The RISC-V ISA keeps the source ({\em rs1} and {\em rs2}) and
destination ({\em rd}) registers at the same position in all formats
to simplify decoding.  Except for the 5-bit immediates used in CSR
instructions (Chapter~\ref{csrinsts}), immediates are always
sign-extended, and are generally packed towards the leftmost available
bits in the instruction and have been allocated to reduce hardware
complexity.  In particular, the sign bit for all immediates is always
in bit 31 of the instruction to speed sign-extension circuitry.
\end{comment}

RISC-V ISAは、デコードを簡素化するために、ソース({\em rs1}および{\em rs2})と
書き込み先({\em rd})レジスタをすべての形式で同じ位置に保持します。
CSR命令で使用される5ビットの即値(Chapter~\ref{csrinsts})を除いて、
即値は常に符号拡張され、通常、命令の左端の使用可能なビットに向かってパックされ、
ハードウェアの複雑さを軽減するために割り当てられています。 
特に、すべての即値の符号ビットは、符号拡張回路を高速化するために
常に命令の31ビット目に配置されています。

\begin{comment}
\begin{commentary}
Decoding register specifiers is usually on the critical paths in
implementations, and so the instruction format was chosen to keep all
register specifiers at the same position in all formats at the expense
of having to move immediate bits across formats (a property shared
with RISC-IV aka. SPUR~\cite{spur-jsscc1989}).

In practice, most immediates are either small or require all XLEN
bits.  We chose an asymmetric immediate split (12 bits in regular
instructions plus a special load-upper-immediate instruction with 20
bits) to increase the opcode space available for regular instructions.

Immediates are sign-extended because we did not observe a benefit to
using zero-extension for some immediates as in the MIPS ISA and wanted
to keep the ISA as simple as possible.
\end{commentary}
\end{comment}

\begin{commentary}
レジスタ指定子のデコードは、通常、実装上のクリティカルパスに含まれるため、
フォーマット間で即値ビットを移動させることを犠牲にして、すべてのフォーマットで
すべてのレジスタ指定子を同じ位置に保つような命令フォーマットが選択されました
(RISC-IV aka.SPUR~\cite{spur-jsscc1989}と共通の特性です)。

実際には、ほとんどの即値は小さいか、またはすべてのXLENビットを必要とします。
そこで、非対称の即値分割(12ビットの通常命令と、20ビットの特別なロードアップ即値命令)
を採用し、通常命令で使用できるオペコード空間を増やしました。

即値命令は符号拡張されていますが、これは一部の即値命令にゼロ拡張を使用することの
利点が認められなかったためです。
符号拡張されているのは、MIPS ISAのように一部の即席命令をゼロ拡張にするメリットがなく、
可能な限りISAをできるだけシンプルにしたかったからです。
\end{commentary}

\begin{comment}
\section{Immediate Encoding Variants}

There are a further two variants of the instruction formats (B/J)
based on the handling of immediates, as shown in
Figure~\ref{fig:baseinstformatsimm}.
\end{comment}

\section{即値命令エンコーディング}

命令フォーマット(B/J)には、即値の扱いに応じて図~\ref{fig:baseinstformatsimm}に示すように、さらに2つのバリエーションがあります。

\begin{figure}[h]
\begin{small}
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{p{0.3in}@{}p{0.8in}@{}p{0.6in}@{}p{0.18in}@{}p{0.7in}@{}p{0.6in}@{}p{0.6in}@{}p{0.3in}@{}p{0.5in}l}
\\
\multicolumn{1}{c}{\instbit{31}} &
\instbitrange{30}{25} &
\instbitrange{24}{21} &
\multicolumn{1}{c}{\instbit{20}} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{8} &
\multicolumn{1}{c}{\instbit{7}} &
\instbitrange{6}{0} \\
\cline{1-9}
\multicolumn{2}{|c|}{funct7} &
\multicolumn{2}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{2}{c|}{rd} &
\multicolumn{1}{c|}{opcode} &
R-type \\
\cline{1-9}
\\
\cline{1-9}
\multicolumn{4}{|c|}{imm[11:0]} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{2}{c|}{rd} &
\multicolumn{1}{c|}{opcode} &
I-type \\
\cline{1-9}
\\
\cline{1-9}
\multicolumn{2}{|c|}{imm[11:5]} &
\multicolumn{2}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{2}{c|}{imm[4:0]} &
\multicolumn{1}{c|}{opcode} &
S-type \\
\cline{1-9}
\\
\cline{1-9}
\multicolumn{1}{|c|}{imm[12]} &
\multicolumn{1}{c|}{imm[10:5]} &
\multicolumn{2}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{imm[4:1]} &
\multicolumn{1}{c|}{imm[11]} &
\multicolumn{1}{c|}{opcode} &
B-type \\
\cline{1-9}
\\
\cline{1-9}
\multicolumn{6}{|c|}{imm[31:12]} &
\multicolumn{2}{c|}{rd} &
\multicolumn{1}{c|}{opcode} &
U-type \\
\cline{1-9}
\\
\cline{1-9}
\multicolumn{1}{|c|}{imm[20]} &
\multicolumn{2}{c|}{imm[10:1]} &
\multicolumn{1}{c|}{imm[11]} &
\multicolumn{2}{c|}{imm[19:12]} &
\multicolumn{2}{c|}{rd} &
\multicolumn{1}{c|}{opcode} &
J-type \\
\cline{1-9}
\end{tabular}
\end{center}
\end{small}
\begin{comment}
\caption{RISC-V base instruction formats showing immediate variants.}
\end{comment}
\caption{即値を持つRISC-Vベース命令フォーマット}
\label{fig:baseinstformatsimm}
\end{figure}

\begin{comment}
The only difference between the S and B formats is that the 12-bit
immediate field is used to encode branch offsets in multiples of 2 in
the B format.  Instead of shifting all bits in the
instruction-encoded immediate left by one in hardware as is
conventionally done, the middle bits (imm[10:1]) and sign bit stay in
fixed positions, while the lowest bit in S format (inst[7]) encodes a
high-order bit in B format.
\end{comment}

SフォーマットとBフォーマットの唯一の違いは、Bフォーマットでは12ビットの即値フィールドを
2倍することで分岐オフセットのエンコードに使用されることです。 
従来のように、命令でエンコードされた即値のすべてのビットを
ハードウェアで左に1ビットシフトするのではなく、
中間ビット(imm[10:1])と符号ビットは固定されたままで、
Sフォーマットの即値の最下位ビット(inst[7])はBフォーマットのより高い位置のビットをエンコードしています。

\begin{comment}
Similarly, the only difference between the U and J formats is
that the 20-bit immediate is shifted left by 12 bits to form U
immediates and by 1 bit to form J immediates.  The location of
instruction bits in the U and J format immediates is chosen to
maximize overlap with the other formats and with each other.
\end{comment}

同様に、UとJのフォーマットの違いは、20ビットの即値がU即値の場合は12ビット、
J即値の場合は1ビットだけ左にシフトすることです。
UおよびJフォーマットの即値の命令ビットの位置は、
他のフォーマットや相互に最大限にオーバーラップするように選択されています。

\begin{comment}
Figure~\ref{fig:immtypes} shows the immediates produced by each of the
base instruction formats, and is labeled to show which instruction
bit (inst[{\em y}\,]) produces each bit of the immediate value.
\end{comment}

図~\ref{fig:immtypes}は、それぞれの基本命令フォーマットで生成される即時値を示しており、
どの命令ビット(inst[{\em y}\,])が即値の各ビットを生成するかをラベルで示しています。

\begin{figure}[h]
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{p{0.2in}@{}p{1.2in}@{}p{1.0in}@{}p{0.2in}@{}p{0.7in}@{}p{0.7in}@{}p{0.2in}l}
\\
\multicolumn{1}{c}{\instbit{31}} &
\instbitrange{30}{20} &
\instbitrange{19}{12} &
\multicolumn{1}{c}{\instbit{11}} &
\instbitrange{10}{5} &
\instbitrange{4}{1} &
\multicolumn{1}{c}{\instbit{0}} &
\\
\cline{1-7}
\multicolumn{4}{|c|}{--- inst[31] ---} &
\multicolumn{1}{c|}{inst[30:25]} &
\multicolumn{1}{c|}{inst[24:21]} &
\multicolumn{1}{c|}{inst[20]} &
I-immediate \\
\cline{1-7}
\\
\cline{1-7}
\multicolumn{4}{|c|}{--- inst[31] ---} &
\multicolumn{1}{c|}{inst[30:25]} &
\multicolumn{1}{c|}{inst[11:8]} &
\multicolumn{1}{c|}{inst[7]} &
S-immediate \\
\cline{1-7}
\\
\cline{1-7}
\multicolumn{3}{|c|}{--- inst[31] ---} &
\multicolumn{1}{c|}{inst[7]} &
\multicolumn{1}{c|}{inst[30:25]} &
\multicolumn{1}{c|}{inst[11:8]} &
\multicolumn{1}{c|}{0} &
B-immediate \\
\cline{1-7}
\\
\cline{1-7}
\multicolumn{1}{|c|}{inst[31]} &
\multicolumn{1}{c|}{inst[30:20]} &
\multicolumn{1}{c|}{inst[19:12]} &
\multicolumn{4}{c|}{--- 0 ---} &
U-immediate \\
\cline{1-7}
\\
\cline{1-7}
\multicolumn{2}{|c|}{--- inst[31] ---} &
\multicolumn{1}{c|}{inst[19:12]} &
\multicolumn{1}{c|}{inst[20]} &
\multicolumn{1}{c|}{inst[30:25]} &
\multicolumn{1}{c|}{inst[24:21]} &
\multicolumn{1}{c|}{0} &
J-immediate \\
\cline{1-7}
\end{tabular}
\end{center}
\begin{comment}
\caption{Types of immediate produced by RISC-V instructions.  The fields are labeled with the
  instruction bits used to construct their value.  Sign extension
  always uses inst[31].}
\end{comment}
\caption{RISC-V命令で生成される即値の種類。
フィールドには、その値を構成するために使用される命令ビットが表示されています。
符号拡張は常に inst[31] を使用します。}
\label{fig:immtypes}
\end{figure}

\begin{commentary}
\begin{comment}
Sign-extension is one of the most critical operations on immediates
(particularly for XLEN$>$32), and in RISC-V the sign bit for all immediates
is always held in bit 31 of the instruction to allow sign-extension to
proceed in parallel with instruction decoding.
\end{comment}

符号拡張は即値の最も重要な演算の1つであり(特にXLEN$>$32の場合)、
RISC-Vではすべての即値の符号ビットは常に命令のビット31目に保持され、
符号拡張が命令のデコードと並行して行われるようになっています。

\begin{comment}
Although more complex implementations might have separate adders for
branch and jump calculations and so would not benefit from keeping the
location of immediate bits constant across types of instruction, we
wanted to reduce the hardware cost of the simplest implementations.
By rotating bits in the instruction encoding of B and J immediates
instead of using dynamic hardware muxes to multiply the immediate by
2, we reduce instruction signal fanout and immediate mux costs by
around a factor of 2.  The scrambled immediate encoding will add
negligible time to static or ahead-of-time compilation.  For dynamic
generation of instructions, there is some small additional
overhead, but the most common short forward branches have
straightforward immediate encodings.
\end{comment}

より複雑な実装では、分岐計算とジャンプ計算を別々の加算器で行うため、
命令の種類に関わらず即時ビットの位置を一定にするメリットはありませんが、
私たちは最もシンプルな実装でハードウェアコストを削減したいと考えました。
即値を2倍にするためにダイナミックハードウェアMUXを使用する代わりに、
B即値とJ即値の命令エンコーディングでビットを回転させることで、
命令信号のファンアウトと即値MUXのコストを約2分の1に削減しました。 
命令を動的に生成する場合には、若干の追加オーバーヘッドがありますが、
最も一般的な短い順方向の分岐では、直接的な即値エンコーディングが行われます。
\end{commentary}

\begin{comment}
\section{Integer Computational Instructions}

Most integer computational instructions operate on XLEN bits of values
held in the integer register file.  Integer computational instructions
are either encoded as register-immediate operations using the I-type
format or as register-register operations using the R-type format.
The destination is register {\em rd} for both register-immediate and
register-register instructions.  No integer computational instructions
cause arithmetic exceptions.
\end{comment}

\section{整数算術演算命令}

ほとんどの整数演算命令は、整数レジスタファイルに保持されている値の
XLENビットに対して演算を行います
整数演算命令は、Iタイプのフォーマットを使用したレジスタ即値演算、
またはRタイプのフォーマットを使用したレジスタ・レジスタ演算としてエンコードされます。
レジスタ即値演算とレジスタ・レジスタ演算のどちらの命令でも、出力先はレジスタ{\em rd}です。
算術例外を発生させる整数演算命令はありません。

\begin{commentary}
\begin{comment}
We did not include special instruction-set support for overflow checks
on integer arithmetic operations in the base instruction set, as many
overflow checks can be cheaply implemented using RISC-V branches.
Overflow checking for unsigned addition requires only a single
additional branch instruction after the addition:
\verb! add t0, t1, t2; bltu t0, t1, overflow!.
\end{comment}

整数演算のオーバーフローチェックは、RISC-Vの分岐を使って安価に実装できるものが多いため、
基本命令セットには特別な命令セットのサポートは含まれていません。
符号なし加算のオーバーフローチェックは、加算後に1回の分岐命令を追加するだけで済みます。\verb! add t0, t1, t2; bltu t0, t1, overflow!

\begin{comment}
For signed addition, if one operand's sign is known, overflow checking
requires only a single branch after the addition:
\verb! addi t0, t1, +imm; blt t0, t1, overflow!.  This covers the
common case of addition with an immediate operand.
\end{comment}

符号付き加算の場合、片方のオペランドの符号がわかっていれば、
オーバーフローのチェックは加算後に1回の分岐で済みます。
\verb! addi t0, t1, +imm; blt t0, t1, overflow!
これは、即値オペランドでの加算という一般的なケースをカバーしています。

\begin{comment}
For general signed addition, three additional instructions after the
addition are required, leveraging the observation that the sum should
be less than one of the operands if and only if the other operand is
negative.
\end{comment}

一般的な符号付き加算では、加算後に3つの追加命令が必要となりますが、
これは「もう一方のオペランドが負の場合に限り、和が一方のオペランドよりも小さくなるはず」というものを利用しています。

\begin{verbatim}
         add t0, t1, t2
         slti t3, t2, 0
         slt t4, t0, t1
         bne t3, t4, overflow
\end{verbatim}
\begin{comment}
In RV64I, checks of 32-bit signed additions can be optimized further by
comparing the results of ADD and ADDW on the operands.
\end{comment}

RV64Iでは，オペランドのADDとADDWの結果を比較することで，32ビット符号付き加算のチェックをさらに最適化することができます。
※ 訳者注：on the operands, どういう意味？
\end{commentary}

\begin{comment}
\subsubsection*{Integer Register-Immediate Instructions}
\end{comment}
\subsubsection*{整数レジスタ即値命令}

\vspace{-0.4in}
\begin{center}
\begin{tabular}{M@{}R@{}S@{}R@{}O}
\\
\instbitrange{31}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{imm[11:0]} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
12 & 5 & 3 & 5 & 7 \\
I-immediate[11:0] & src & ADDI/SLTI[U]  & dest & OP-IMM \\
I-immediate[11:0] & src & ANDI/ORI/XORI & dest & OP-IMM \\
\end{tabular}
\end{center}

\begin{comment}
ADDI adds the sign-extended 12-bit immediate to register {\em rs1}.
Arithmetic overflow is ignored and the result is simply the low
XLEN bits of the result.  ADDI {\em rd, rs1, 0} is used to implement the
MV {\em rd, rs1} assembler pseudoinstruction.
\end{comment}

ADDIは、符号拡張された12ビットの即値をレジスタ{\em rs1}と加算します。
算術オーバーフローは無視され、結果は単に結果の下位XLENビットとなります。
ADDI {\em rd, rs1, 0} は、MV {\em rd, rs1} アセンブラ疑似命令の実装に使用されます。

\begin{comment}
SLTI (set less than immediate) places the value 1 in register {\em rd}
if register {\em rs1} is less than the sign-extended immediate when
both are treated as signed numbers, else 0 is written to {\em rd}.
SLTIU is similar but compares the values as unsigned numbers (i.e.,
the immediate is first sign-extended to XLEN bits then treated as an
unsigned number).  Note, SLTIU {\em rd, rs1, 1} sets {\em rd}
to 1 if {\em rs1} equals zero, otherwise sets {\em rd} to 0 (assembler
pseudoinstruction SEQZ {\em rd, rs}).
\end{comment}

SLTI(set less than immediate)は、
レジスタが符号付き整数として扱われているときに、レジスタ{\em rs1}が符号拡張した即値より小さい場合は、
レジスタ{\em rd}に値1を、そうでない場合は0を書き込みます。
SLTIUも同様ですが、値を符号なしの数値として比較します(つまり、即値をまずXLENビットに符号拡張してから、符号なしの数値として扱います)。
なお、SLTIU {\em rd, rs1, 1} は、{\em rs1} が0であれば{\em rd}に1、{\em rs1}が0でなければ0に設定されます
(アセンブラの擬似命令SEQZ {\em rd, rs})。

\begin{comment}
ANDI, ORI, XORI are logical operations that perform bitwise AND, OR,
and XOR on register {\em rs1} and the sign-extended 12-bit immediate
and place the result in {\em rd}.  Note, XORI {\em rd, rs1, -1}
performs a bitwise logical inversion of register {\em rs1} (assembler
pseudoinstruction NOT {\em rd, rs}).
\end{comment}

ANDI、ORI、XORIは、レジスタ{\em rs1}と符号拡張された12ビットの即値に対して、
ビット単位のAND、OR、XORを行い、その結果を{\em rd}に格納する論理演算です。
なお、XORI {\em rd, rs1, -1} はレジスタ {\em rs1} をビット単位で論理反転させるものです。
(アセンブラの疑似命令 NOT {\em rd, rs})

\vspace{-0.2in}
\begin{center}
\begin{tabular}{S@{}R@{}R@{}S@{}R@{}O}
\\
\instbitrange{31}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{imm[11:5]} &
\multicolumn{1}{c|}{imm[4:0]} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
7 & 5 & 5 & 3 & 5 & 7 \\
0000000 & shamt[4:0]  & src & SLLI & dest & OP-IMM \\
0000000 & shamt[4:0]  & src & SRLI & dest & OP-IMM \\
0100000 & shamt[4:0]  & src & SRAI & dest & OP-IMM \\
\end{tabular}
\end{center}

\begin{comment}
Shifts by a constant are encoded as a specialization of the
I-type format.  The operand to be shifted is in {\em rs1}, and the
shift amount is encoded in the lower 5 bits of the I-immediate field.
The right shift type is encoded in bit 30.
SLLI is a logical left shift (zeros are shifted into the lower bits);
SRLI is a logical right shift (zeros are shifted into the upper bits);
and SRAI is an arithmetic right shift (the original sign bit is copied
into the vacated upper bits).
\end{comment}

定数によるシフトは、I-typeフォーマットの特殊な場合としてエンコードされます。
シフトされるオペランドは、I-immediateフィールドの下位5ビットにエンコードされます。
右シフトの種類は、ビット30でエンコードされます。
SLLIは論理的左シフト(下位ビットにゼロがシフトされる)、SRLIは論理的右シフト(上位ビットにゼロがシフトされる)、
SRAIは算術的右シフト(空いた上位ビットに元の符号ビットがコピーされる)です。

\vspace{-0.2in}
\begin{center}
\begin{tabular}{U@{}R@{}O}
\\
\instbitrange{31}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{imm[31:12]} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
20 & 5 & 7 \\
U-immediate[31:12] & dest & LUI \\
U-immediate[31:12] & dest & AUIPC
\end{tabular}
\end{center}

\begin{comment}
LUI (load upper immediate) is used to build 32-bit constants and uses
the U-type format.  LUI places the 32-bit U-immediate value into
the destination register {\em rd}, filling in the lowest 12
bits with zeros.
\end{comment}

LUI(load upper immediate)は32ビットの定数を構築するためのもので、
U-Typeのフォーマットを使用します。
LUIは、32ビットのU-Immediateを、下位12ビットをゼロで埋めて、書き込みレジスタ{\em rd}に格納します。

\begin{comment}
AUIPC (add upper immediate to {\tt pc}) is used to build {\tt pc}-relative
addresses and uses the U-type format.  AUIPC forms a 32-bit offset from the
U-immediate, filling in the lowest 12 bits with zeros, adds this offset
to the address of the AUIPC instruction, then places the result in register {\em rd}.
\end{comment}

AUIPC(add upper immediate to {\tt pc})は、相対アドレスを構築するための命令で、
U-Immediateのフォーマットを使用します。
AUIPCは、U-immediateから32ビットのオフセットを形成し、そのオフセットをAUIPC命令のアドレスに加算し、
その結果をレジスタ{\em rd}に格納します。

\begin{commentary}
\begin{comment}
The assembly syntax for {\tt lui} and {\tt auipc} does not represent the lower
12 bits of the U-immediate, which are always zero.
\end{comment}

{\tt lui}と{\tt auipc}のアセンブリの構文では、
U-immediateの下位12ビットが表現されておらず、常に0となっています。

\begin{comment}
The AUIPC instruction supports two-instruction sequences to access
arbitrary offsets from the PC for both control-flow transfers and data
accesses.  The combination of an AUIPC and the 12-bit immediate in a
JALR can transfer control to any 32-bit PC-relative address, while an
AUIPC plus the 12-bit immediate offset in regular load or store
instructions can access any 32-bit PC-relative data address.
\end{comment}

AUIPC命令は、制御フロー転送とデータアクセスの両方において、
PCからの任意のオフセットにアクセスするための2つの命令シーケンスをサポートしています。 
AUIPCとJALRの12ビット即値の組み合わせでは、任意の32ビットPC相対アドレスに制御を移すことができ、
通常のロード命令やストア命令では、AUIPCと12ビット即値のオフセットで任意の
32ビットPC相対データアドレスにアクセスすることができます。

\begin{comment}
The current PC can be obtained by setting the U-immediate to 0.
Although a JAL +4 instruction could also be used to obtain the local
PC (of the instruction following the JAL), it might cause pipeline
breaks in simpler microarchitectures or pollute BTB structures in more
complex microarchitectures.
\end{comment}

現在のPCは、U-Immediateを0にすることで取得できます。 
JAL+4命令で(JALに続く命令の)ローカルPCを取得することも可能ですが、
単純なマイクロアーキテクチャではパイプラインの切断を引き起こし、
複雑なマイクロアーキテクチャではBTB構造を汚染する可能性があります。

\end{commentary}

\begin{comment}
\subsubsection*{Integer Register-Register Operations}
\end{comment}

\subsubsection*{整数レジスタ・レジスタ演算命令}

\begin{comment}
RV32I defines several arithmetic R-type operations.  All operations
read the {\em rs1} and {\em rs2} registers as source operands and
write the result into register {\em rd}.  The {\em funct7} and {\em
  funct3} fields select the type of operation.
\end{comment}

RV32Iでは、いくつかのR型の算術演算が定義されています。
すべての演算はレジスタ{\em rs1}と{\em rs2} をソースオペランドとして読み込み、
結果をレジスタ{\em rd}に書き込みます。
演算の種類は、{\em funct7}と{\em funct3}で選択します。

\vspace{-0.2in}
\begin{center}
\begin{tabular}{S@{}R@{}R@{}S@{}R@{}O}
\\
\instbitrange{31}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{funct7} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
7 & 5 & 5 & 3 & 5 & 7 \\
0000000 & src2 & src1 & ADD/SLT/SLTU & dest & OP    \\
0000000 & src2 & src1 & AND/OR/XOR  & dest & OP    \\
0000000 & src2 & src1 & SLL/SRL     & dest & OP    \\
0100000 & src2 & src1 & SUB/SRA     & dest & OP    \\
\end{tabular}
\end{center}

\begin{comment}
ADD performs the addition of {\em rs1} and {\em rs2}. SUB performs the
subtraction of {\em rs2} from {\em rs1}.  Overflows are ignored and the low XLEN
bits of results are written to the destination {\em rd}.
SLT and SLTU perform signed and unsigned compares
respectively, writing 1 to {\em rd} if $\mbox{\em rs1} < \mbox{\em
  rs2}$, 0 otherwise.  Note, SLTU {\em rd}, {\em x0}, {\em rs2} sets
{\em rd} to 1 if {\em rs2} is not equal to zero, otherwise sets {\em
  rd} to zero (assembler pseudoinstruction SNEZ {\em rd, rs}).  AND, OR, and
XOR perform bitwise logical operations.
\end{comment}

ADDは、{\em rs1}と{
\em rs2}の加算を行います。
SUBは、{\em rs1}から{\em rs2}の減算を行います。
オーバーフローは無視され、結果の下位XLENビットが出力先の{\em rd}に書き込まれます。
SLTとSLTUは、それぞれ符号付きと符号なしの比較を行い、$\mbox{\em rs1} < \mbox{\em rs1}$より大きい場合に1を書き込み、それ以外は0を書き込みます。
なお、SLTU {\em rd}, {\em x0}, {\em rs2}は、 {\em rs2}が0でなければ1、そうでなければ0を{\em rd}に設定します
(アセンブラの擬似命令SNEZ {\em rd, rs}のことです)。
AND、OR、XORはビット単位の論理演算を行います。

\begin{comment}
SLL, SRL, and SRA perform logical left, logical right, and arithmetic
right shifts on the value in register {\em rs1} by the shift amount
held in the lower 5 bits of register {\em rs2}.
\end{comment}
SLL, SRL, SRAは、レジスタの下位5ビットに保持されているシフト量で、
レジスタの値を左へ論理シフト、右へ論理シフト、右へ算術シフトします。

\begin{comment}
\subsubsection*{NOP Instruction}
\end{comment}
\subsubsection*{NOP命令}

\vspace{-0.4in}
\begin{center}
\begin{tabular}{M@{}R@{}S@{}R@{}O}
\\
\instbitrange{31}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{imm[11:0]} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
12 & 5 & 3 & 5 & 7 \\
0 & 0 & ADDI & 0 & OP-IMM \\
\end{tabular}
\end{center}

\begin{comment}
The NOP instruction does not change any architecturally visible state, except for
advancing the {\tt pc} and incrementing any applicable performance
counters.  NOP is encoded as ADDI {\em x0, x0, 0}.
\end{comment}

NOP命令は、アーキテクチャ的に見える状態を一切変更しません。
ただし、パフォーマンスカウンタを進めたり、使用可能なパフォーマンスカウンタをインクリメントしたりします。
NOPはADDI {\em x0, x0, 0}としてエンコードされます。

\begin{commentary}
\begin{comment}
NOPs can be used to align code segments to microarchitecturally
significant address boundaries, or to leave space for inline code
modifications.  Although there are many possible ways to encode a NOP,
we define a canonical NOP encoding to allow microarchitectural
optimizations as well as for more readable disassembly output.  The
other NOP encodings are made available for HINT instructions
(Section~\ref{sec:rv32i-hints}).
\end{comment}

NOPは、コードセグメントをマイクロアーキテクチャ的に重要なアドレス境界に合わせたり、
インラインコードの修正のためにスペースを残したりするために使用することができます。 
NOPをエンコードする方法はたくさんありますが、
マイクロアーキテクチャの最適化を可能にし、より読みやすい逆アセンブル出力を実現するために、
標準的なNOPエンコードを定義します。
他のNOPエンコーディングはHINT命令(~\ref{sec:rv32i-hints}節)で利用できます。

\begin{comment}
ADDI was chosen for the NOP encoding as this is most likely to take
fewest resources to execute across a range of systems (if not
optimized away in decode).  In particular, the instruction only reads
one register.  Also, an ADDI functional unit is more likely to be
available in a superscalar design as adds are the most common
operation.  In particular, address-generation functional units can
execute ADDI using the same hardware needed for base+offset address
calculations, while register-register ADD or logical/shift operations
require additional hardware.
\end{comment}

ADDIは、(デコードで最適化されていない場合)様々なシステムで実行するのに
最も少ないリソースを必要とする可能性が高いため、NOPエンコーディングに選ばれました。
特に、この命令は1つのレジスタしか読み取りません。
また、加算は最も一般的な演算であるため、スーパースカラ設計ではADDI機能ユニットが
利用できる可能性が高くなります。
特に、アドレス生成機能ユニットは、ベース+オフセットのアドレス計算に必要なのと
同じハードウェアを使用してADDIを実行できますが、
レジスタ・レジスタ間のADDや論理/シフト演算には追加のハードウェアが必要です。
\end{commentary}

\begin{comment}
\section{Control Transfer Instructions}
\end{comment}
\section{制御転送命令}

\begin{comment}
RV32I provides two types of control transfer instructions:
unconditional jumps and conditional branches.  Control transfer
instructions in RV32I do {\em not} have architecturally visible delay
slots.
\end{comment}

RV32Iには、無条件ジャンプと条件付き分岐の2種類の制御転送命令があります。
RV32Iの制御転送命令には、アーキテクチャ的に見える遅延スロットがありません。

\begin{comment}
If an instruction access-fault or instruction page-fault exception occurs
on the target of a jump or taken branch, the exception is reported on the
target instruction, not on the jump or branch instruction.
\end{comment}

ジャンプ命令や分岐命令のターゲットで命令アクセス・フォールトや
命令ページ・フォールトの例外が発生した場合、
その例外はジャンプ命令や分岐命令ではなく、ターゲット命令で報告されます。

\begin{comment}
\subsubsection*{Unconditional Jumps}
\end{comment}
\subsubsection*{無条件ジャンプ命令}

\begin{comment}
\vspace{-0.1in} The jump and link (JAL) instruction uses the J-type
format, where the J-immediate encodes a signed offset in multiples of
2 bytes.  The offset is sign-extended and added to the address of
the jump instruction
to form the jump target address.  Jumps can therefore target a
$\pm$\wunits{1}{MiB} range. JAL stores the address of the instruction
following the jump ({\tt pc}+4) into register {\em rd}.  The standard
software calling convention uses {\tt x1} as the return address
register and {\tt x5} as an alternate link register.
\end{comment}

\vspace{-0.1in} ジャンプ\&リンク(JAL)命令はJ-typeフォーマットの命令で、
J-immediateには2バイトの倍数の符号付きオフセットがエンコードされています。
このオフセットは符号拡張され、ジャンプ命令のアドレスに加算されてジャンプ先のアドレスとなります。
このため、ジャンプは$\pm$\wunits{1}{MiB}の範囲を対象とすることができます。
JALは、ジャンプ命令の次の命令のアドレス({\tt PC}+4)をレジスタ{\em rd}に格納します。
標準的なソフトウェアの呼び出し規則では、リターンアドレスレジスタとして{\tt x1}を、代替リンクレジスタとして{\tt x5}を使用します。

\begin{commentary}
\begin{comment}
The alternate link register supports calling millicode routines (e.g.,
those to save and restore registers in compressed code) while
preserving the regular return address register.  The register {\tt x5}
was chosen as the alternate link register as it maps to a temporary in
the standard calling convention, and has an encoding that is only one
bit different than the regular link register.
\end{comment}
代替リンク・レジスタは、通常のリターン・アドレス・レジスタを保持しながら、
ミリコード・ルーチン(圧縮コードでレジスタを保存・復元するものなど)の呼び出しをサポートします。
レジスタ{\tt x5}は、標準的な呼び出し方法でテンポラリにマッピングされ、
通常のリンクレジスタとは1ビットだけ異なるエンコーディングを持つため、代替リンクレジスタとして選択されました。
\end{commentary}

\begin{comment}
Plain unconditional jumps (assembler pseudoinstruction J) are encoded as a JAL
with {\em rd}={\tt x0}.
\end{comment}

リンクしない無条件ジャンプ(アセンブラ擬似命令J)は、
JALでは、{\em rd}={\tt x0}でエンコードされます。

\vspace{-0.2in}
\begin{center}
\begin{tabular}{W@{}E@{}W@{}R@{}R@{}O}
\\
\multicolumn{1}{c}{\instbit{31}} &
\instbitrange{30}{21} &
\multicolumn{1}{c}{\instbit{20}} &
\instbitrange{19}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{imm[20]} &
\multicolumn{1}{c|}{imm[10:1]} &
\multicolumn{1}{c|}{imm[11]} &
\multicolumn{1}{c|}{imm[19:12]} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
1 & 10 & \multicolumn{1}{c}{1} & 8 & 5 & 7 \\
\multicolumn{4}{c}{offset[20:1]} & dest & JAL \\
\end{tabular}
\end{center}

\begin{comment}
The indirect jump instruction JALR (jump and link register) uses the
I-type encoding.  The target address is obtained by adding the sign-extended
12-bit I-immediate to the register {\em rs1}, then setting the
least-significant bit of the result to zero.  The address of
the instruction following the jump ({\tt pc}+4) is written to register
{\em rd}.  Register {\tt x0} can be used as the destination if the
result is not required.
\end{comment}

間接ジャンプ命令JALR(jump and link register)は，I型エンコーディングを使用しています。 
符号拡張された12ビットのI-immediateをレジスタ{\em rs1}に加算し、
その結果の最下位ビットを0にすることでターゲットアドレスが得られます。
ジャンプの次の命令のアドレス({\tt pc}+4)は、レジスタ{\em rd}に書き込まれます。
結果が不要な場合は、レジスタ{\tt x0}を出力先として使用できます。

\vspace{-0.4in}
\begin{center}
\begin{tabular}{M@{}R@{}F@{}R@{}O}
\\
\instbitrange{31}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{imm[11:0]} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
12 & 5 & 3 & 5 & 7 \\
offset[11:0] & base & 0 & dest & JALR \\
\end{tabular}
\end{center}

\begin{commentary}
\begin{comment}
The unconditional jump instructions all use PC-relative addressing to
help support position-independent code.  The JALR instruction was
defined to enable a two-instruction sequence to jump anywhere in a
32-bit absolute address range.  A LUI instruction can first load {\em
  rs1} with the upper 20 bits of a target address, then JALR can add
in the lower bits. Similarly, AUIPC then JALR can jump
anywhere in a 32-bit {\tt pc}-relative address range.
\end{comment}

無条件ジャンプ命令は、位置に依存しないコードをサポートするために、すべてPC相対アドレッシングを使用しています。 JALR命令は、2つの命令で32ビットの絶対アドレス範囲のどこにでもジャンプできるように定義されています。 LUI命令では、まず上位20ビットのアドレスをロードし、JALRで下位ビットを追加します。同様に、AUIPC→JALRの順で、32ビットの{\ pc}相対アドレス範囲内のどこにでもジャンプできます。

\begin{comment}
Note that the JALR instruction does not treat the 12-bit immediate as
multiples of 2 bytes, unlike the conditional branch instructions.
This avoids one more immediate format in hardware.  In
practice, most uses of JALR will have either a zero immediate or be
paired with a LUI or AUIPC, so the slight reduction in range is not
significant.
\end{comment}

JALR命令では、条件分岐命令とは異なり、12ビットの即値を2バイトの倍数として扱いません。
これにより、ハードウェア上で即値のフォーマットが1つ増えることを避けられます。 
実際には、JALRのほとんどの用途では、即値が0になるか、
LUIやAUIPCとペアになるかのいずれかであるため、
範囲がわずかに狭くなることは重要ではありません。

\begin{comment}
Clearing the least-significant bit when calculating the JALR target
address both simplifies the hardware slightly and allows the
low bit of function pointers to be used to store auxiliary
information.  Although there is potentially a slight loss of error
checking in this case, in practice jumps to an incorrect instruction
address will usually quickly raise an exception.
\end{comment}

JALRのターゲットアドレスを計算する際に最下位ビットをクリアすることで、
ハードウェアが若干簡素化されるとともに、
関数ポインタの下位ビットを補助的な情報の格納に使用することができます。
この場合、エラーチェック機能が若干失われる可能性がありますが、
実際には誤った命令アドレスにジャンプするとすぐに例外が発生します。

\begin{comment}
When used with a base {\em rs1}$=${\tt x0}, JALR can be used to implement
a single instruction subroutine call to the lowest \wunits{2}{KiB} or highest
\wunits{2}{KiB} address region from anywhere in the address space, which could
be used to implement fast calls to a small runtime library.  Alternatively,
an ABI could dedicate a general-purpose register to point to a library
elsewhere in the address space.
\end{comment}

JALRは、ベースとなる{\em rs1}$=${\em x0}とすることで、
アドレス空間内の任意の場所から\wunits{2}{KiB}離れた下位のアドレスか、\wunits{2}{KiB}離れた上位のアドレス領域への
単一命令によるサブルーチンコールを実装することができ、
小さなランタイムライブラリへの高速な呼び出しを実現することができます。
また、ABIはアドレス空間の別の場所にあるライブラリを指すように汎用レジスタを割り当てることもできます。
\end{commentary}

\begin{comment}
The JAL and JALR instructions will generate an
instruction-address-misaligned exception if the target address is not
aligned to a four-byte boundary.
\end{comment}
JALおよびJALR命令は、ターゲットアドレスが4バイト境界にアラインされていない場合、
命令アドレスミスアライン例外を発生させます。

\begin{commentary}
\begin{comment}
Instruction-address-misaligned exceptions are not possible on machines
that support extensions with 16-bit aligned instructions, such as the
compressed instruction-set extension, C.
\end{comment}

命令アドレスミスアライン例外は、圧縮命令セット拡張であるC拡張など、
16ビットアラインド命令を持つ拡張をサポートするマシンでは発生しません。

\end{commentary}

\begin{comment}
Return-address prediction stacks are a common feature of
high-performance instruction-fetch units, but require accurate
detection of instructions used for procedure calls and returns to be
effective.  For RISC-V, hints as to the instructions' usage are encoded
implicitly via the register numbers used.  A JAL instruction should
push the return address onto a return-address stack (RAS) only when
{\em rd} is {\tt x1} or {\tt x5}.  JALR instructions should push/pop a
RAS as shown in the Table~\ref{rashints}.
\end{comment}

リターンアドレス予測スタック(Return Address Prediction stack)は、
高性能な命令フェッチユニットの一般的な機能ですが、その効果を発揮するためには、
プロシージャコールやリターンに使用される命令を正確に検出する必要があります。
RISC-Vでは、使用されるレジスタ番号によって、命令の使用方法に関するヒントが暗黙のうちにエンコードされます。
JAL命令では、RAS(Return-Address Stack)にリターンアドレスをプッシュしますが、
その際には、{\em rd}が{\tt x1}または{\tt x5}である必要があります。
JALR命令は、表のようにRASに挿入・取り出しを行います。

\begin{table}[hbt]
\centering
\begin{tabular}{|c|c|c|l|}
  \hline
  \textit{rd} is \texttt{x1}/\texttt{x5}
      & \textit{rs1} is \texttt{x1}/\texttt{x5}
            & \textit{rd}$=$\textit{rs1} & RAS action \\
  \hline
  No  & No  & --  & None \\
  No  & Yes & --  & Pop \\
  Yes & No  & --  & Push \\
  Yes & Yes & No  & Pop, then push \\
  Yes & Yes & Yes & Push \\
   \hline
\end{tabular}
\begin{comment}
\caption{Return-address stack prediction hints encoded in the register
  operands of a JALR instruction.}
\end{comment}
\caption{リターンアドレス予測スタックはJALR命令のレジスタオペランドによってエンコードされたヒントを提供する}
\label{rashints}
\end{table}

\begin{commentary}
\begin{comment}
Some other ISAs added explicit hint bits to their indirect-jump instructions
to guide return-address stack manipulation.  We use implicit hinting tied to
register numbers and the calling convention to reduce the encoding space used
for these hints.
\end{comment}
他のISAでは、リターンアドレスのスタック操作を誘導するために、
間接ジャンプ命令に明示的なヒントビットを追加していました。 
私たちは、レジスタ番号と呼び出し規則に関連した暗黙のヒントを使用して、
これらのヒントに使用されるエンコーディングスペースを減らしています。

\begin{comment}
When two different link registers ({\tt x1} and {\tt x5}) are given as
{\em rs1} and {\em rd}, then the RAS is both popped and pushed to
support coroutines.  If {\em rs1} and {\em rd} are the same link
register (either {\tt x1} or {\tt x5}), the RAS is only pushed to
enable macro-op fusion of the sequences:\linebreak
{\tt lui ra, imm20; jalr ra, imm12(ra)} \ and \ 
{\tt auipc ra, imm20; jalr ra, imm12(ra)}
\end{comment}

2つの異なるリンクレジスタ({\tt x1}と{\tt x5})がそれぞれ{\em rs1}と{\em rd}に与えられた場合、
コルーチンをサポートするために、RASは取り出しと挿入の両方が行われます。
{\em rs1}と{\em rd}が同じリンクレジスタ({\tt x1}もしくは{\tt x5})の場合は、
RASは以下のプログラム列のマクロな演算結合のためにRASに挿入のみを行います:
\linebreak
{\tt lui ra, imm20; jalr ra, imm12(ra)} \ と \ 
{\tt auipc ra, imm20; jalr ra, imm12(ra)}
\end{commentary}

\begin{comment}
\subsubsection*{Conditional Branches}
\end{comment}
\subsubsection*{条件分岐命令}

\begin{comment}
All branch instructions use the B-type instruction format.  The
12-bit B-immediate encodes signed offsets in multiples of 2 bytes.
The offset is sign-extended and added
to the address of the branch instruction to give the target address.  The
conditional branch range is $\pm$\wunits{4}{KiB}.
\end{comment}

すべての分岐命令は、B型命令フォーマットを使用します。 
12ビットのB型中間子は、2バイトの倍数の符号付きオフセットをエンコードします。
オフセットは符号拡張され、分岐命令のアドレスに加算されてターゲットアドレスとなります。
すべての分岐命令はBタイプの命令フォーマットを使用しますが、
条件分岐の範囲は$\pm$\wunits{4}{KiB}です。 

\vspace{-0.2in}
\begin{center}
\begin{tabular}{W@{}R@{}F@{}F@{}R@{}R@{}F@{}S}
\\
\multicolumn{1}{c}{\instbit{31}} &
\instbitrange{30}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{8} &
\multicolumn{1}{c}{\instbit{7}} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{imm[12]} &
\multicolumn{1}{c|}{imm[10:5]} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{imm[4:1]} &
\multicolumn{1}{c|}{imm[11]} &
\multicolumn{1}{c|}{opcode} \\
\hline
1 & 6 & 5 & 5 & 3 & 4 & 1 & 7 \\
\multicolumn{2}{c}{offset[12$\vert$10:5]} & src2 & src1 & BEQ/BNE & \multicolumn{2}{c}{offset[11$\vert$4:1]} & BRANCH \\
\multicolumn{2}{c}{offset[12$\vert$10:5]} & src2 & src1 & BLT[U] & \multicolumn{2}{c}{offset[11$\vert$4:1]} & BRANCH \\
\multicolumn{2}{c}{offset[12$\vert$10:5]} & src2 & src1 & BGE[U]  & \multicolumn{2}{c}{offset[11$\vert$4:1]} & BRANCH \\
\end{tabular}
\end{center}

\begin{comment}
Branch instructions compare two registers.  BEQ and BNE take the
branch if registers {\em rs1} and {\em rs2} are equal or unequal
respectively.  BLT and BLTU take the branch if {\em rs1} is less than
{\em rs2}, using signed and unsigned comparison respectively.  BGE and
BGEU take the branch if {\em rs1} is greater than or equal to {\em rs2},
using signed and unsigned comparison respectively. Note, BGT, BGTU,
BLE, and BLEU can be synthesized by reversing the operands to BLT,
BLTU, BGE, and BGEU, respectively.
\end{comment}

分岐命令は2つのレジスタを比較します。
BEQとBNEは、レジスタが等しければ分岐し、等しくなければ分岐しません。
BLT および BLTU は、それぞれ符号付きおよび符号なしの比較を使用して、
{\em rs1} が {\em rs2} よりも小さい場合に分岐します。
BGEとBGEUは、それぞれ符号付きと符号なしの比較を用いて、{\em rs1}が{\em rs2}よりも大きいか等しい場合に分岐します。
なお、BGT、BGTU、BLE、BLEUは、それぞれBLT、BLTU、BGE、BGEUのオペランドを逆にして合成することができます。

\begin{commentary}
\begin{comment}
Signed array bounds may be checked with a single BLTU instruction, since
any negative index will compare greater than any nonnegative bound.
\end{comment}
符号付き配列の境界は、1つのBLTU命令で調べることができます。
負のインデックスは、非負の境界よりも大きく比較されるからです。
\end{commentary}

\begin{comment}
Software should be optimized such that the sequential code path is the
most common path, with less-frequently taken code paths placed out of
line.  Software should also assume that backward branches will be
predicted taken and forward branches as not taken, at least the
first time they are encountered.  Dynamic predictors should quickly
learn any predictable branch behavior.
\end{comment}

ソフトウェアは、シーケンシャル・コード・パスが最も一般的なパスであり、
あまり頻繁に使用されないコード・パスはライン外に配置されるように最適化されるべきです。 
また、ソフトウェアは、少なくとも最初に遭遇したときには、
後方への分岐は取られると予測され、前方への分岐は取られないと予測されるべきです。
動的予測器は、予測可能な分岐の動作をすぐに学ぶべきです。

\begin{comment}
Unlike some other architectures, the RISC-V jump (JAL with {\em
  rd}={\tt x0}) instruction should always be used for unconditional
branches instead of a conditional branch instruction with an
always-true condition.  RISC-V jumps are also PC-relative and support
a much wider offset range than branches, and will not pollute
conditional-branch prediction tables.
\end{comment}

他のいくつかのアーキテクチャとは異なり、
RISC-Vのジャンプ({\em rd}={\tt x0}のJAL命令)は、
常に真の条件を持つ条件付き分岐命令の代わりに、
常に無条件の分岐に使用されるべきです。
RISC-Vのジャンプは、PC相対で、
分岐(訳者注:これは条件分岐命令のことを示しているものと思われる)よりもはるかに広いオフセット範囲をサポートしており、
条件分岐の予測テーブルを汚染することはありません。

\begin{commentary}
\begin{comment}
The conditional branches were designed to include arithmetic
comparison operations between two registers (as also done in PA-RISC,
Xtensa, and MIPS R6), rather than use condition codes (x86, ARM, SPARC,
PowerPC), or to only compare one register against zero (Alpha, MIPS),
or two registers only for equality (MIPS).  This design was motivated
by the observation that a combined compare-and-branch instruction fits
into a regular pipeline, avoids additional condition code state or use
of a temporary register, and reduces static code size and dynamic
instruction fetch traffic.  Another point is that comparisons against
zero require non-trivial circuit delay (especially after the move to
static logic in advanced processes) and so are almost as expensive as
arithmetic magnitude compares.  Another advantage of a fused
compare-and-branch instruction is that branches are observed earlier
in the front-end instruction stream, and so can be predicted earlier.
There is perhaps an advantage to a design with condition codes in the
case where multiple branches can be taken based on the same condition
codes, but we believe this case to be relatively rare.
\end{comment}

条件分岐は、条件コードを使用したり(x86, ARM, SPARC, PowerPC)、
1つのレジスタをゼロと比較するだけにしたり(Alpha, MIPS)、
2つのレジスタを等しく比較するだけにしたり(MIPS)するのではなく、
2つのレジスタ間の算術比較演算を含むように設計されています(PA-RISC, Xtensa, MIPS R6でも同様)。
この設計は、比較と分岐を組み合わせた命令が通常のパイプラインに収まり、
追加の条件コードの状態や一時的なレジスタの使用を回避し、
静的なコードサイズと動的な命令フェッチのトラフィックを削減できるという観察に基づいています。 
もう1つのポイントは、ゼロとの比較には自明ではない回路遅延が必要であり(特に高度なプロセスでスタティック・ロジックに移行した後)、
そのために算術的な大きさの比較とほぼ同じコストがかかることです。 
比較と分岐を融合させた命令のもう一つの利点は、
分岐がフロントエンドの命令ストリームの早い段階で観測されるため、
早い段階で予測することができることです。
同一の条件コードに基づいて複数の分岐を行う場合には、
条件コードを用いた設計の利点があるかもしれませんが、このようなケースは比較的少ないと考えています。

\begin{comment}
We considered but did not include static branch hints in the
instruction encoding.  These can reduce the pressure on dynamic
predictors, but require more instruction encoding space and
software profiling for best results, and can result in poor
performance if production runs do not match profiling runs.
\end{comment}

静的な分岐ヒントを命令エンコーディングに含めることも検討しましたが，今回は見送りました． 
しかし，最良の結果を得るためには，より多くの命令エンコーディングスペースとソフトウェアプロファイリングが必要となります．

\begin{comment}
We considered but did not include conditional moves or predicated
instructions, which can effectively replace unpredictable short
forward branches.  Conditional moves are the simpler of the two, but
are difficult to use with conditional code that might cause exceptions
(memory accesses and floating-point operations).  Predication adds
additional flag state to a system, additional instructions to set and
clear flags, and additional encoding overhead on every instruction.
Both conditional move and predicated instructions add complexity to
out-of-order microarchitectures, adding an implicit third source
operand due to the need to copy the original value of the destination
architectural register into the renamed destination physical register
if the predicate is false.  Also, static compile-time decisions to use
predication instead of branches can result in lower performance on
inputs not included in the compiler training set, especially given
that unpredictable branches are rare, and becoming rarer as branch
prediction techniques improve.
\end{comment}

予測不可能な短い順方向の分岐を効果的に置き換えることができる、
条件付き移動やプリディケーテッド命令を検討しましたが、採用しませんでした。 
条件付き移動は、この2つのうちではシンプルな方ですが、
例外が発生する可能性のある条件付きコード(メモリ・アクセスや浮動小数点演算)では使用することが困難です。 
プレディケート命令はシステムに追加のフラグ状態を追加し、フラグを設定およびクリアするための追加の命令、
およびすべての命令に追加のエンコーディング・オーバーヘッドを追加します。
条件付き移動命令とプレディケート付き命令の両方とも、
アウトオブオーダー・マイクロアーキテクチャに複雑さをもたらします。
プレディケートが成立しない場合には、書き込みアーキテクチャレジスタの元の値をリネームされた
書き込み物理レジスタにコピーする必要があるため、暗黙の第3ソース・オペランドが追加されます。 
また、分岐の代わりにプレディケートを使用するという静的なコンパイル時の決定は、
コンパイラのトレーニングセットに含まれていない入力に対する性能を低下させる可能性があります。
特に、予測できない分岐はまれであり、分岐予測技術の向上に伴い、
分岐予測できない場合はますます減っています。

\begin{comment}
We note that various microarchitectural techniques exist to
dynamically convert unpredictable short forward branches into
internally predicated code to avoid the cost of flushing pipelines on
a branch mispredict~\cite{heil-tr1996,Klauser-1998,Kim-micro2005} and
have been implemented in commercial processors~\cite{ibmpower7}.
The simplest techniques just reduce the penalty of recovering from a
mispredicted short forward branch by only flushing instructions in the
branch shadow instead of the entire fetch pipeline, or by fetching
instructions from both sides using wide instruction fetch or idle
instruction fetch slots.  More complex techniques for out-of-order
cores add internal predicates on instructions in the branch shadow,
with the internal predicate value written by the branch instruction,
allowing the branch and following instructions to be executed
speculatively and out-of-order with respect to other code~\cite{ibmpower7}.
\end{comment}

予測不可能な短い順方向の分岐を内部で予測されたコードに動的に変換し、
分岐の予測失敗に伴うパイプラインのフラッシュコストを回避する様々なマイクロアーキテクチャー技術が存在し、
商用プロセッサに実装されていることに注目しました。
最も単純な手法は、フェッチパイプライン全体ではなく、分岐シャドウ内の命令のみをフラッシュすることで、
誤予測された短い順方向の分岐から回復する際のペナルティを軽減したり、
より幅の広い命令フェッチやアイドル命令フェッチスロットを使用して両サイドから命令をフェッチすることです。 
アウトオブオーダーコアのためのより複雑な技術は、分岐シャドウ内の命令に内部プレディケートを追加し、
内部プレディケートの値は分岐命令によって書き込まれ、分岐とそれに続く命令が投機的に実行され、
他のコードに対してアウトオブオーダーで実行されることを可能にします~\cite{ibmpower7}。
\end{commentary}

\begin{comment}
The conditional branch instructions will generate an
instruction-address-misaligned exception if the target address is not
aligned to a four-byte boundary and the branch condition evaluates
to true.  If the branch condition evaluates to false, the
instruction-address-misaligned exception will not be raised.
\end{comment}

条件分岐命令は、ターゲットアドレスが4バイト境界にアラインされておらず、
分岐条件が真と評価された場合に命令アドレスミスアライン例外を発生させます。
分岐条件が不成立と評価された場合は、命令アドレスミスアライン例外は発生しません。

\begin{commentary}
\begin{comment}
Instruction-address-misaligned exceptions are not possible on machines
that support extensions with 16-bit aligned instructions, such as the
compressed instruction-set extension, C.
\end{comment}

圧縮命令セット拡張であるCなど、16ビットアラインドの命令を持つ拡張をサポートするマシンでは、
命令アドレスミスアライン例外は発生しません。
\end{commentary}

\begin{comment}
\section{Load and Store Instructions}
\end{comment}
\section{ロードストア命令}
\label{sec:rv32:ldst}

\begin{comment}
RV32I is a load-store architecture, where only load and store
instructions access memory and arithmetic instructions only operate on
CPU registers.  RV32I provides a 32-bit address space that is
byte-addressed.
The EEI will define what portions of the address space are legal to access with
which instructions (e.g., some addresses might be read only, or
support word access only).  Loads with a destination of {\tt x0} must
still raise any exceptions and cause any other side effects even
though the load value is discarded.
\end{comment}

RV32Iはロード・ストア・アーキテクチャで、ロード命令とストア命令のみがメモリにアクセスし、
演算命令はCPUレジスタのみを操作します。 
RV32Iは、バイトアドレス方式の32ビットのアドレス空間を提供します。
EEIは、アドレス空間のどの部分がどのような命令でアクセスするのが有効であるかを定義します
(例えば、いくつかのアドレスは読み取り専用であったり、ワードアクセスのみをサポートしたりします)。
宛先が{\tt x0}のロードは、ロード値が破棄されても、
例外が発生したり、その他の副作用が発生したりしなければなりません。

\begin{comment}
The EEI will define whether the memory system is little-endian or big-endian.
In RISC-V, endianness is byte-address invariant.
\end{comment}

EEIは、メモリシステムがリトルエンディアンかビッグエンディアンのどちらかとして定義されます。
RISC-Vでは、エンディアンはバイトアドレスで不変です。

\begin{commentary}
\begin{comment}
In a system for which endianness is byte-address invariant, the following
property holds: if a byte is stored to memory at some address in some
endianness, then a byte-sized load from that address in any endianness returns
the stored value.
\end{comment}

エンディアンがバイトアドレス不変のシステムでは以下の性質があります:
あるエンディアンでアドレスにバイトデータがメモリに格納されている場合、
どのようなエンディアンでもそのアドレスからバイトサイズのロードを行うと、ストアした値が返されます。

\begin{comment}
In a little-endian configuration, multibyte stores write the least-significant
register byte at the lowest memory byte address, followed by the other
register bytes in ascending order of their significance.
Loads similarly transfer the contents of the lesser memory byte addresses to
the less-significant register bytes.
\end{comment}

リトルエンディアンの構成では、マルチバイトストアは、最下位のメモリバイトアドレスに最下位のレジスタバイトを書き込み、
その後、他のレジスタバイトをアドレスの昇順で書き込みます。
ロードの場合も同様に、下位のメモリバイトアドレスの内容を下位のレジスタバイトに転送します。

\begin{comment}
In a big-endian configuration, multibyte stores write the most-significant
register byte at the lowest memory byte address, followed by the other
register bytes in descending order of their significance.
Loads similarly transfer the contents of the greater memory byte addresses to
the less-significant register bytes.
\end{comment}

ビッグエンディアン構成の場合、マルチバイトストアは最下位のメモリバイトアドレスに最上位のレジスタバイトを書き込み、
その後、バイトアドレスの降順で他のレジスタバイトを書き込みます。
ロードも同様に、上位のメモリバイトアドレスの内容を下位のレジスタバイトに転送します。

\end{commentary}

\vspace{-0.4in}
\begin{center}
\begin{tabular}{M@{}R@{}F@{}R@{}O}
\\
\instbitrange{31}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{imm[11:0]} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
12 & 5 & 3 & 5 & 7 \\
offset[11:0] & base & width & dest & LOAD \\
\end{tabular}
\end{center}

\vspace{-0.2in}
\begin{center}
\begin{tabular}{O@{}R@{}R@{}F@{}R@{}O}
\\
\instbitrange{31}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{imm[11:5]} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{imm[4:0]} &
\multicolumn{1}{c|}{opcode} \\
\hline
7 & 5 & 5 & 3 & 5 & 7 \\
offset[11:5] & src & base & width & offset[4:0] & STORE \\
\end{tabular}
\end{center}

\begin{comment}
Load and store instructions transfer a value between the registers and
memory.  Loads are encoded in the I-type format and stores are
S-type.  The effective address is obtained by adding register
{\em rs1} to the sign-extended 12-bit offset.  Loads copy a value
from memory to register {\em rd}.  Stores copy the value in register
{\em rs2} to memory.
\end{comment}

ロード命令とストア命令は、レジスタとメモリの間で値を転送します。
ロードはI-Type、ストアはS-Typeでエンコードされます。
実効アドレスは、符号拡張された12ビットのオフセットに、レジスタ{\em rs1}を加算したものになります。
ロードは、メモリからレジスタに値をコピーします。
ストアは、レジスタ{\em rs2}の値をメモリにコピーします。

\begin{comment}
The LW instruction loads a 32-bit value from memory into {\em rd}.  LH
loads a 16-bit value from memory, then sign-extends to 32-bits before
storing in {\em rd}. LHU loads a 16-bit value from memory but then
zero extends to 32-bits before storing in {\em rd}.  LB and LBU are
defined analogously for 8-bit values.  The SW, SH, and SB instructions
store 32-bit, 16-bit, and 8-bit values from the low bits of register
{\em rs2} to memory.
\end{comment}

LWは、メモリから32ビットの値をロードする命令です。 
LHは16ビットの値をメモリからロードし、32ビットに符号拡張してから格納します。
LHUは16ビットの値をメモリからロードしますが、32ビットにゼロ拡張してから格納します。
LBとLBUは、8ビット値の場合と同様に定義されます。
SW、SH、SB命令は、32ビット、16ビット、8ビットの値をレジスタの下位ビットからメモリに格納します。

\begin{comment}
Regardless of EEI, loads and stores whose effective addresses are
naturally aligned shall not raise an address-misaligned exception.
Loads and stores whose effective address is not naturally aligned
to the referenced datatype (i.e., the effective address is
not divisible by the size of the access in bytes) have behavior
dependent on the EEI.
\end{comment}

EEIにかかわらず、実効アドレスが自然にアラインされているロードおよびストアは、
アドレスミスアライン例外を発生してはなりません。
有効なアドレスが参照されるデータ型に対して自然にアラインされていない
(すなわち、有効なアドレスがアクセスのバイトサイズで割り切れない)ロードおよびストアは、
EEIに依存した動作をします。

\begin{comment}
An EEI may guarantee that misaligned loads and stores are fully
supported, and so the software running inside the execution
environment will never experience a contained or fatal
address-misaligned trap.  In this case, the misaligned loads and
stores can be handled in hardware, or via an invisible trap into the
execution environment implementation, or possibly a combination of
hardware and invisible trap depending on address.
\end{comment}

EEIは、ミスアラインド・ロードとストアが完全にサポートされていることを保証し、
実行環境内で実行されているソフトウェアが、致命的なアドレス・ミスアライン例外が発生することがないようにすることができます。 
この場合、ミスアラインド・ロードとストアは、ハードウェアで処理するか、
実行環境の実装に不可視のトラップを介して処理するか、
あるいはアドレスに応じてハードウェアと不可視のトラップを組み合わせて処理することができます。

\begin{comment}
An EEI may not guarantee misaligned loads and stores are handled
invisibly.  In this case, loads and stores that are not naturally
aligned may either complete execution successfully or raise an
exception.  The exception raised can be either an address-misaligned
exception or an access-fault exception.  For a memory access that would
otherwise be able to complete except for the misalignment, an
access-fault exception can be raised instead of an address-misaligned
exception if the misaligned access should not be emulated, e.g., if
accesses to the memory region have side effects.  When an EEI does not
guarantee misaligned loads and stores are handled invisibly, the EEI
must define if exceptions caused by address misalignment result in a
contained trap (allowing software running inside the execution
environment to handle the trap) or a fatal trap (terminating
execution).
\end{comment}

EEIは、ミスアラインロードとストアが目に見えない形で処理されることを保証しない場合があります。 
この場合、自然にアラインされていないロードとストアは、
正常に実行を完了するか、または例外を発生させることがあります。
発生する例外には、アドレスミスアラインド例外とアクセスフォルト例外があります。 
アライメントがずれていなければ完了するはずのメモリ・アクセスでも、メモリ領域へのアクセスに副作用があるなど、
ミスアラインド・アクセスをエミュレートすべきでない場合は、
アドレス・ミスアライン例外ではなく、アクセス・フォールト例外を発生させることができます。 
EEIがミスアラインド・ロードとストアが目に見えない形で処理されることを保証しない場合、
EEIはアドレス・ミスアラインよる例外が、contained trap(実行環境内で動作するソフトウェアがトラップを処理できるようにする)
とフェイタル・トラップ(実行を終了する)のどちらになるかを定義しなければなりません。

\begin{commentary}
\begin{comment}
Misaligned accesses are occasionally required when porting legacy
code, and help performance on applications when using any form of
packed-SIMD extension or handling externally packed data structures.
Our rationale for allowing EEIs to choose to support misaligned
accesses via the regular load and store instructions is to simplify
the addition of misaligned hardware support.  One option would have
been to disallow misaligned accesses in the base ISA and then provide
some separate ISA support for misaligned accesses, either special
instructions to help software handle misaligned accesses or a new
hardware addressing mode for misaligned accesses.  Special
instructions are difficult to use, complicate the ISA, and often add
new processor state (e.g., SPARC VIS align address offset register) or
complicate access to existing processor state (e.g., MIPS LWL/LWR
partial register writes).  In addition, for loop-oriented packed-SIMD
code, the extra overhead when operands are misaligned motivates
software to provide multiple forms of loop depending on operand
alignment, which complicates code generation and adds to loop startup
overhead.  New misaligned hardware addressing modes take considerable
space in the instruction encoding or require very simplified
addressing modes (e.g., register indirect only).
\end{comment}

従来のコードを移植する際にミスアライン・アクセスが必要になることがあります。
また、何らかの形でPacked-SIMD拡張を使用したり、
外部からパックされたデータ構造を扱うアプリケーションでは、パフォーマンスの向上に役立ちます。
EEIが通常のロード/ストア命令によるミスアラインアクセスのサポートを選択できるようにした理由は、
ミスアライン・ハードウェア・サポートの追加を容易にするためです。 
そのためには、ソフトウェアがミスアラインアクセスを処理するための特別な命令を用意するか、
ミスアラインアクセスのための新しいハードウェア・アドレッシング・モードを用意するかのいずれかを選択する必要があります。 
特別な命令は使いにくく、ISAを複雑にし、しばしば新しいプロセッサの状態を追加したり(例：SPARC VISアラインアドレスオフセットレジスタ)、
既存のプロセッサの状態へのアクセスを複雑にします(例：MIPS LWL/LWRパーシャルレジスタライト)。
さらに、ループ指向のpacked-SIMDコードでは、
オペランドがミスアラインされた場合にオーバーヘッドが増えるため、
ソフトウェアはオペランドのアラインメントに応じて複数のループ形態を提供する必要があり、
コード生成が複雑になり、ループ起動時のオーバーヘッドも増えることになります。
新しいミスアライン・ハードウェア・アドレッシング・モードは、命令エンコーディングに大きなスペースを必要としたり、
非常にシンプルなアドレッシング・モード(例：レジスタ間接のみ)に限定されます。
\end{commentary}

\begin{comment}
Even when misaligned loads and stores complete successfully, these
accesses might run extremely slowly depending on the implementation
(e.g., when implemented via an invisible trap).  Furthermore, whereas
naturally aligned loads and stores are guaranteed to execute
atomically, misaligned loads and stores might not, and hence
require additional synchronization to ensure atomicity.
\end{comment}

ミスアラインド・ロード/ストアが正常に完了した場合でも、
実装によっては(invisible trapを使って実装されている場合など)、
これらのアクセスが非常に遅くなることがあります。 
さらに、自然にアラインされたロードとストアはアトミックに実行されることが保証されていますが、
ミスアラインされたロードとストアはアトミックに実行されない可能性があるため、
アトミック性を確保するために追加の同期が必要になります。

\begin{commentary}
\begin{comment}
We do not mandate atomicity for misaligned accesses so execution
environment implementations can use an invisible machine trap and
a software handler to handle some or all misaligned accesses.  If
hardware misaligned support is provided, software can exploit this by
simply using regular load and store instructions.  Hardware can then
automatically optimize accesses depending on whether runtime addresses
are aligned.
\end{comment}

実行環境の実装では、不可視のマシントラップとソフトウェアハンドラーを使用して、
一部またはすべてのミスアラインドアクセスを処理することができるように、
ミスアラインドアクセスのアトミック性を義務付けていません。 
ハードウェアのミスアラインサポートが提供されている場合、
ソフトウェアは通常のロードおよびストア命令を使用するだけでこれを利用することができます。 
ハードウェアは、ランタイムアドレスがアラインされているかどうかに応じて、
アクセスを自動的に最適化することができます。
\end{commentary}

\pagebreak

\section{Memory Ordering Instructions}
\label{sec:fence}

\vspace{-0.2in}
\begin{center}
\begin{tabular}{F@{}IIIIIIIIF@{}F@{}F@{}S}
\\
\instbitrange{31}{28} &
\multicolumn{1}{c}{\instbit{27}} &
\multicolumn{1}{c}{\instbit{26}} &
\multicolumn{1}{c}{\instbit{25}} &
\multicolumn{1}{c}{\instbit{24}} &
\multicolumn{1}{c}{\instbit{23}} &
\multicolumn{1}{c}{\instbit{22}} &
\multicolumn{1}{c}{\instbit{21}} &
\multicolumn{1}{c}{\instbit{20}} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{fm} &
\multicolumn{1}{c|}{PI} &
\multicolumn{1}{c|}{PO} &
\multicolumn{1}{c|}{PR} &
\multicolumn{1}{c|}{PW} &
\multicolumn{1}{|c|}{SI} &
\multicolumn{1}{c|}{SO} &
\multicolumn{1}{c|}{SR} &
\multicolumn{1}{c|}{SW} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
4 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 5 & 3 & 5 & 7 \\
FM & \multicolumn{4}{c}{predecessor} & \multicolumn{4}{c}{successor} & 0 & FENCE & 0 & MISC-MEM \\
\end{tabular}
\end{center}

The FENCE instruction is used to order device I/O and
memory accesses as viewed by other RISC-V harts and external devices
or coprocessors.  Any combination of device input (I), device output
(O), memory reads (R), and memory writes (W) may be ordered with
respect to any combination of the same.  Informally, no other RISC-V
hart or external device can observe any operation in the {\em
  successor} set following a FENCE before any operation in the {\em
  predecessor} set preceding the FENCE.
Chapter~\ref{ch:memorymodel} provides a precise description of the
RISC-V memory consistency model.
  
The EEI will define what I/O operations are possible, and in
particular, which memory addresses when accessed by load and store instructions will be treated and
ordered as device input and device output operations respectively
rather than memory reads and writes.  For example, memory-mapped I/O
devices will typically be accessed with uncached loads and stores that
are ordered using the I and O bits rather than the R and W bits.
Instruction-set extensions might also describe new I/O
instructions that will also be ordered using the I and O bits in a
FENCE.

\begin{table}[htp]
\begin{small}
\begin{center}
\begin{tabular}{|c|c|l|}
\hline
{\em fm} field & Mnemonic & Meaning \\
\hline
0000 & \em none & Normal Fence \\
\hline
\multirow{2}{*}{1000} & \multirow{2}{*}{TSO} & With FENCE RW,RW: exclude write-to-read ordering \\
                      &                      & Otherwise: \em Reserved for future use. \\
\hline
\multicolumn{2}{|c|}{\em other} & \em Reserved for future use. \\
\hline
\end{tabular}
\end{center}
\end{small}
\caption{Fence mode encoding.}
\label{fm}
\end{table}

The fence mode field {\em fm} defines the semantics of the FENCE.  A
FENCE with {\em fm}=0000 orders all memory operations in its
predecessor set before all memory operations in its successor set. 

The optional FENCE.TSO instruction is encoded as a FENCE instruction
with {\em fm}=1000, {\em predecessor}=RW, and {\em successor}=RW.
FENCE.TSO orders all load
operations in its predecessor set before all memory operations in its
successor set, and all store operations in its predecessor set before
all store operations in its successor set.  This leaves non-AMO store
operations in the FENCE.TSO's predecessor set unordered with non-AMO
loads in its successor set.

\begin{commentary}
  The FENCE.TSO encoding was added as an optional extension to the
  original base FENCE instruction encoding.  The base definition
  requires that implementations ignore any set bits and treat the
  FENCE as global, and so this is a backwards-compatible extension.
\end{commentary}

The unused fields in the FENCE instructions---{\em rs1} and {\em rd}---are
reserved for finer-grain fences in future extensions.  For forward
compatibility, base implementations shall ignore these fields, and standard
software shall zero these fields.  Likewise, many {\em fm} and
predecessor/successor set settings in Table~\ref{fm} are also reserved
for future use.  Base implementations shall treat all such reserved
configurations as normal fences with {\em fm}=0000, and standard
software shall use only non-reserved configurations.

\begin{commentary}
We chose a relaxed memory model to allow high performance from simple
machine implementations and from likely future
coprocessor or accelerator extensions.  We separate out I/O ordering
from memory R/W ordering to avoid unnecessary serialization within a
device-driver hart and also to support alternative non-memory paths
to control added coprocessors or I/O devices.  Simple implementations
may additionally ignore the {\em predecessor} and {\em successor}
fields and always execute a conservative fence on all operations.
\end{commentary}

\section{Environment Call and Breakpoints}

SYSTEM instructions are used to access system functionality that might
require privileged access and are encoded using the I-type instruction
format.  These can be divided into two main classes: those that
atomically read-modify-write control and status registers (CSRs), and
all other potentially privileged instructions. CSR instructions are
described in Chapter~\ref{csrinsts}, and the base unprivileged instructions
are described in the following section.

\begin{commentary}
The SYSTEM instructions are defined to allow simpler implementations
to always trap to a single software trap handler.  More sophisticated
implementations might execute more of each system instruction in
hardware.
\end{commentary}

\vspace{-0.2in}
\begin{center}
\begin{tabular}{M@{}R@{}F@{}R@{}S}
\\
\instbitrange{31}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{funct12} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
12 & 5 & 3 & 5 & 7 \\
ECALL   & 0 & PRIV & 0 & SYSTEM \\
EBREAK  & 0 & PRIV & 0 & SYSTEM \\
\end{tabular}
\end{center}

These two instructions cause a precise requested trap to the
supporting execution environment.

The ECALL instruction is used to make a service request to the
execution environment.  The EEI will define how parameters for the
service request are passed, but usually these will be in defined
locations in the integer register file.

The EBREAK instruction is used to return control to a debugging
environment.

\begin{commentary}
ECALL and EBREAK were previously named SCALL and SBREAK.  The
instructions have the same functionality and encoding, but were
renamed to reflect that they can be used more generally than to call a
supervisor-level operating system or debugger.
\end{commentary}

\begin{commentary}
  EBREAK was primarily designed to be used by a debugger to cause
  execution to stop and fall back into the debugger. EBREAK is also
  used by the standard gcc compiler to mark code paths that should not
  be executed.

  Another use of EBREAK is to support ``semihosting'', where the
  execution environment includes a debugger that can provide services
  over an alternate system call interface built around the EBREAK
  instruction.  Because the RISC-V base ISA does not provide more than
  one EBREAK instruction, RISC-V semihosting uses a special sequence of
  instructions to distinguish a semihosting EBREAK from a debugger
  inserted EBREAK.
\begin{verbatim}
    slli x0, x0, 0x1f   # Entry NOP
    ebreak              # Break to debugger
    srai x0, x0, 7      # NOP encoding the semihosting call number 7
\end{verbatim}
   Note that these three instructions must be 32-bit-wide instructions,
   i.e., they mustn't be among the compressed 16-bit instructions
   described in Chapter~\ref{compressed}.

   The shift NOP instructions are still considered available for use as
   HINTS.

   Semihosting is a form of service call and would be more naturally
   encoded as an ECALL using an existing ABI, but this would require
   the debugger to be able to intercept ECALLs, which is a newer
   addition to the debug standard.  We intend to move over to using
   ECALLs with a standard ABI, in which case, semihosting can share a
   service ABI with an existing standard.

   We note that ARM processors have also moved to using SVC instead of
   BKPT for semihosting calls in newer designs.
\end{commentary}

\section{HINT Instructions}
\label{sec:rv32i-hints}

RV32I reserves a large encoding space for HINT instructions, which are
usually used to communicate performance hints to the
microarchitecture.
Like the NOP instruction, HINTs do not change any architecturally visible
state, except for advancing the {\tt pc} and any applicable performance
counters.
Implementations are always allowed to ignore the encoded hints.

Most RV32I HINTs are encoded as integer computational instructions with
{\em rd}={\tt x0}.
The other RV32I HINTs are encoded as FENCE instructions with a null
predecessor or successor set and with {\em fm}=0.

\begin{commentary}
These HINT encodings have been chosen so that simple implementations can ignore
HINTs altogether, and instead execute a HINT as a regular
instruction that happens not to mutate the architectural state.  For example, ADD is
a HINT if the destination register is {\tt x0}; the five-bit {\em rs1} and {\em
rs2} fields encode arguments to the HINT.  However, a simple implementation can
simply execute the HINT as an ADD of {\em rs1} and {\em rs2} that writes {\tt
x0}, which has no architecturally visible effect.

As another example, a FENCE instruction with a zero {\em pred} field and
a zero {\em fm} field is a HINT; the {\em succ}, {\em rs1}, and {\em rd}
fields encode the arguments to the HINT.
A simple implementation can simply execute the HINT as a FENCE that orders the
null set of prior memory accesses before whichever subsequent memory accesses
are encoded in the {\em succ} field.
Since the intersection of the predecessor and successor sets is null, the
instruction imposes no memory orderings, and so it has no architecturally
visible effect.
\end{commentary}

Table~\ref{tab:rv32i-hints} lists all RV32I HINT code points.  91\% of the HINT
space is reserved for standard HINTs.  The
remainder of the HINT space is designated for custom HINTs: no standard HINTs
will ever be defined in this subspace.

\begin{commentary}
We anticipate
standard hints to eventually include memory-system spatial and
temporal locality hints, branch prediction hints, thread-scheduling
hints, security tags, and instrumentation flags for
simulation/emulation.
\end{commentary}

\begin{table}[hbt]
\centering
\begin{tabular}{|l|l|c|l|}
  \hline
  Instruction           & Constraints                                 & Code Points & Purpose \\ \hline \hline
  LUI                   & {\em rd}={\tt x0}                           & $2^{20}$                    & \multirow{25}{*}{\em Reserved for future standard use} \\ \cline{1-3}
  AUIPC                 & {\em rd}={\tt x0}                           & $2^{20}$                    & \\ \cline{1-3}
  \multirow{2}{*}{ADDI} & {\em rd}={\tt x0}, and either               & \multirow{2}{*}{$2^{17}-1$} & \\
                        & {\em rs1}$\neq${\tt x0} or {\em imm}$\neq$0 &                             & \\ \cline{1-3}
  ANDI                  & {\em rd}={\tt x0}                           & $2^{17}$                    & \\ \cline{1-3}
  ORI                   & {\em rd}={\tt x0}                           & $2^{17}$                    & \\ \cline{1-3}
  XORI                  & {\em rd}={\tt x0}                           & $2^{17}$                    & \\ \cline{1-3}
  ADD                   & {\em rd}={\tt x0}                           & $2^{10}$                    & \\ \cline{1-3}
  SUB                   & {\em rd}={\tt x0}                           & $2^{10}$                    & \\ \cline{1-3}
  AND                   & {\em rd}={\tt x0}                           & $2^{10}$                    & \\ \cline{1-3}
  OR                    & {\em rd}={\tt x0}                           & $2^{10}$                    & \\ \cline{1-3}
  XOR                   & {\em rd}={\tt x0}                           & $2^{10}$                    & \\ \cline{1-3}
  SLL                   & {\em rd}={\tt x0}                           & $2^{10}$                    & \\ \cline{1-3}
  SRL                   & {\em rd}={\tt x0}                           & $2^{10}$                    & \\ \cline{1-3}
  SRA                   & {\em rd}={\tt x0}                           & $2^{10}$                    & \\ \cline{1-3}
  \multirow{3}{*}{FENCE}& {\em rd}={\tt x0}, {\em rs1}$\neq${\tt x0}, & \multirow{3}{*}{$2^{10}-63$}& \\
                        & {\em fm}=0, and either                      &                             & \\
                        & {\em pred}=0 or {\em succ}=0                &                             & \\ \cline{1-3}
  \multirow{3}{*}{FENCE}& {\em rd}$\neq${\tt x0}, {\em rs1}={\tt x0}, & \multirow{3}{*}{$2^{10}-63$}& \\
                        & {\em fm}=0, and either                      &                             & \\
                        & {\em pred}=0 or {\em succ}=0                &                             & \\ \cline{1-3}
  \multirow{2}{*}{FENCE}& {\em rd}={\em rs1}={\tt x0}, {\em fm}=0,    & \multirow{2}{*}{15}         & \\
                        & {\em pred}=0, {\em succ}$\neq$0             &                             & \\ \cline{1-3}
  \multirow{2}{*}{FENCE}& {\em rd}={\em rs1}={\tt x0}, {\em fm}=0,    & \multirow{2}{*}{15}         & \\
                        & {\em pred}$\neq$W, {\em succ}=0             &                             & \\ \hline
  \multirow{2}{*}{FENCE}& {\em rd}={\em rs1}={\tt x0}, {\em fm}=0,    & \multirow{2}{*}{1}          & \multirow{2}{*}{PAUSE} \\
                        & {\em pred}=W, {\em succ}=0                  &                             & \\ \hline \hline
  SLTI                  & {\em rd}={\tt x0}                           & $2^{17}$                    & \multirow{7}{*}{\em Designated for custom use} \\ \cline{1-3}
  SLTIU                 & {\em rd}={\tt x0}                           & $2^{17}$                    & \\ \cline{1-3}
  SLLI                  & {\em rd}={\tt x0}                           & $2^{10}$                    & \\ \cline{1-3}
  SRLI                  & {\em rd}={\tt x0}                           & $2^{10}$                    & \\ \cline{1-3}
  SRAI                  & {\em rd}={\tt x0}                           & $2^{10}$                    & \\ \cline{1-3}
  SLT                   & {\em rd}={\tt x0}                           & $2^{10}$                    & \\ \cline{1-3}
  SLTU                  & {\em rd}={\tt x0}                           & $2^{10}$                    & \\ \hline
\end{tabular}
\caption{RV32I HINT instructions.}
\label{tab:rv32i-hints}
\end{table}

