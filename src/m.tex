\begin{comment}
\chapter{``M'' Standard Extension for Integer Multiplication and
  Division, Version 2.0}
\end{comment}
\chapter{整数乗除算 ``M'' 標準拡張, Version 2.0}

\begin{comment}
This chapter describes the standard integer multiplication and
division instruction extension, which is named ``M'' and contains
instructions that multiply or divide values held in two integer
registers.
\end{comment}

この章では、標準的な整数の乗除算命令の拡張について説明します。
拡張命令は``M''と名付けられ、2つの整数レジスタに保持されている値を乗除算する命令が含まれています。

\begin{commentary}
\begin{comment}
We separate integer multiply and divide out from the base to simplify
low-end implementations, or for applications where integer multiply
and divide operations are either infrequent or better handled in
attached accelerators.
\end{comment}
整数の乗算と除算をベース命令セットから切り離したのは、ローエンドの実装を簡単にするため、
あるいは整数の乗算と除算の演算が頻繁に行われない、あるいは付属のアクセラレータで処理したほうがよいアプリケーションのためです。
\end{commentary}

\begin{comment}
\section{Multiplication Operations}
\end{comment}
\section{乗算命令}

\vspace{-0.2in}
\begin{center}
\begin{tabular}{S@{}R@{}R@{}S@{}R@{}O}
\\
\instbitrange{31}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{funct7} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
7 & 5 & 5 & 3 & 5 & 7 \\
MULDIV & multiplier & multiplicand & MUL/MULH[[S]U] & dest & OP    \\
MULDIV & multiplier & multiplicand & MULW           & dest & OP-32 \\
\end{tabular}
\end{center}

\begin{comment}
MUL performs an XLEN-bit$\times$XLEN-bit multiplication
of {\em rs1} by {\em rs2} and places the
lower XLEN bits in the destination register.  MULH, MULHU, and MULHSU
perform the same multiplication but return the upper XLEN bits of the
full 2$\times$XLEN-bit product, for signed$\times$signed,
unsigned$\times$unsigned, and \wunits{signed}{\em rs1}$\times$\wunits{unsigned}{\em rs2} multiplication,
respectively.  If both the high and low bits of the same product are
required, then the recommended code sequence is: MULH[[S]U] {\em rdh,
  rs1, rs2}; MUL {\em rdl, rs1, rs2} (source register specifiers must
be in same order and {\em rdh} cannot be the same as {\em rs1} or {\em
  rs2}).  Microarchitectures can then fuse these into a single
multiply operation instead of performing two separate multiplies.
\end{comment}

MULは、{\em rs1}×{\em rs2}のXLEN-bit$\times$XLEN-bit乗算を行い、
下位XLENビットをデスティネーションレジスタに格納します。
MULH、MULHU、MULHSUは、同様の乗算を行いますが、2$\times$XLEN-bitの乗算の上位ビットを返します。
同一乗算の上位ビットと下位ビットの両方が必要な場合は、
推奨されるコードシーケンスは: MULH[[S]U]] {\em rdh,rs1,rs2}; MUL {\em rd1, rs1, rs2}
(ソースレジスタは同じ順番でなければならず、{\em rs1}、{\em rs2}と同じにすることはできません)。
マイクロアーキテクチャでは、これらを2つに分けて乗算を行うのではなく、1つの乗算演算に融合させることができます。

\begin{commentary}
\begin{comment}
MULHSU is used in multi-word signed multiplication to multiply the
most-significant word of the multiplicand (which contains the sign bit)
with the less-significant words of the multiplier (which are unsigned).
\end{comment}
MULHSUは、複数ワードの符号付き乗算において、
乗数の最上位ワード(符号ビットを含む)と乗数の最下位ワード(符号なし)を乗算する際に使用します。
\end{commentary}

\begin{comment}
MULW is an RV64 instruction that multiplies the lower 32 bits of the source
registers, placing the sign-extension of the lower 32 bits of the result
into the destination register.
\end{comment}

MULWは，ソースレジスタの下位32ビットを乗算し，その結果の下位32ビットを符号拡張して書き込みレジスタに格納するRV64命令です。

\begin{commentary}
\begin{comment}
In RV64, MUL can be used to obtain the upper 32 bits of the 64-bit product,
but signed arguments must be proper 32-bit signed values, whereas unsigned
arguments must have their upper 32 bits clear.  If the
arguments are not known to be sign- or zero-extended, an alternative is to
shift both arguments left by 32 bits, then use MULH[[S]U].
\end{comment}
RV64では、64ビットの積の上位32ビットを得るためにMULを使用することができますが、
符号付きの引数は適切な32ビットの符号付き値でなければならず、一方、符号なしの引数はその上位32ビットをクリアしなければなりません。
引数が符号またはゼロ拡張であることが分からない場合は、両方の引数を32ビット左にシフトしてから、MULH[[S]U]を使用する方法があります。
\end{commentary}

\begin{comment}
\section{Division Operations}
\end{comment}
\section{除算命令}

\vspace{-0.2in}
\begin{center}
\begin{tabular}{S@{}R@{}R@{}O@{}R@{}O}
\\
\instbitrange{31}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{funct7} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
7 & 5 & 5 & 3 & 5 & 7 \\
MULDIV & divisor & dividend & DIV[U]/REM[U]   & dest & OP    \\
MULDIV & divisor & dividend & DIV[U]W/REM[U]W & dest & OP-32 \\
\end{tabular}
\end{center}

\begin{comment}
DIV and DIVU perform an XLEN bits by XLEN bits signed and unsigned integer
division of {\em rs1} by {\em rs2}, rounding towards zero.
REM and REMU provide the remainder of the corresponding division operation.
For REM, the sign of the result equals the sign of the dividend.
\end{comment}

DIVとDIVUは、XLENビット×XLENビットの符号付きおよび符号なし整数の除算を行い、0に向かって丸めます。
REMおよびREMUは、対応する除算演算の剰余を計算します。
REM の場合、結果の符号は被除数の符号と等しくなります。

\begin{commentary}
\begin{comment}
For both signed and unsigned division, it holds that
\mbox{$\textrm{dividend} = \textrm{divisor} \times \textrm{quotient} + \textrm{remainder}$}.
\end{comment}
符号付除算、符号なし除算ともに、\mbox{$\textrm{被除数} = \textrm{除数} \times \textrm{商} + \textrm{余り}$} が成り立ちます。
\end{commentary}

\begin{comment}
If both the quotient and remainder
are required from the same division, the recommended code sequence is:
DIV[U] {\em rdq, rs1, rs2}; REM[U] {\em rdr, rs1, rs2} ({\em rdq}
cannot be the same as {\em rs1} or {\em rs2}).  Microarchitectures can
then fuse these into a single divide operation instead of performing
two separate divides.
\end{comment}

同一の除算で商と余りの両方が必要な場合、推奨されるコードシーケンスは次のとおりです: 
DIV[U] {\em rdq, rs1, rs2}; REM[U] {\em rdr, rs1, rs2}
({\em rdq}は{\em rs1}と{\em rs2}と同じレジスタを使用することはできません)
マイクロアーキテクチャーでは、これらを2回に分けて分割するのではなく、1回の分割演算に融合させることができます。

\begin{comment}
DIVW and DIVUW are RV64 instructions that divide the
lower 32 bits of {\em rs1} by the lower 32 bits of {\em rs2}, treating
them as signed and unsigned integers respectively, placing the 32-bit
quotient in {\em rd}, sign-extended to 64 bits.  REMW and REMUW
are RV64 instructions that provide the corresponding
signed and unsigned remainder operations respectively. Both REMW and
REMUW always sign-extend the 32-bit result to 64 bits, including on a
divide by zero.
\end{comment}

DIVWとDIVUWは、それぞれ符号付き整数と符号なし整数として、
{\em rs1}の下位32ビットを{\em rs2}の下位32ビットで除算し、
32ビットの商を符号付きで64ビットに拡張して{\em rd}に書き込むRV64命令です。
REMWとREMUWは、それぞれ対応する符号付きと符号なしの剰余演算を行うRV64命令です。
REMWとREMUWは、ゼロ除算の場合も含めて、32ビットの結果を常に64ビットに符号拡張します。

\begin{comment}
The semantics for division by zero and division overflow are summarized in
Table~\ref{tab:divby0}.  The quotient of division by zero has all bits set, and
the remainder of division by zero equals the dividend.  Signed division overflow
occurs only when the most-negative integer is divided by $-1$.  The quotient of
a signed division with overflow is equal to the dividend, and the remainder is
zero. Unsigned division overflow cannot occur.
\end{comment}

ゼロによる除算と除算のオーバーフローの動作は、表~\ref{tab:divby0}にまとめられています。
ゼロによる除算の商にはすべてのビットが設定され、ゼロによる除算の余りは被除数と等しくなります。
符号付き除算のオーバーフローは、整数の負の最大値を$-1$で除算する場合にのみ発生します。
オーバーフローを伴う符号付き除算の商は被除数と等しく、余りはゼロです。
符号なし除算のオーバーフローは発生しません。

\begin{table}[h]
\center
\begin{tabular}{|l|c|c||c|c|c|c|}
\hline
Condition              & Dividend   & Divisor & DIVU[W]   & REMU[W] & DIV[W]     & REM[W] \\ \hline
Division by zero       & $x$        & 0       & $2^{L}-1$ & $x$     & $-1$       & $x$    \\
Overflow (signed only) & $-2^{L-1}$ & $-1$    & --        & --      & $-2^{L-1}$ & 0      \\
\hline
\end{tabular}
\begin{comment}
\caption{Semantics for division by zero and division overflow.
L is the width of the operation in bits: XLEN for DIV[U] and REM[U], or
32 for DIV[U]W and REM[U]W.}
\end{comment}
\caption{ゼロによる除算のオーバーフローによる動作。
Lは演算のビット単位: DIV[U]とREM[U]ではXLEN、DIV[U]WとREM[U]Wでは32ビットである。}
\label{tab:divby0}
\end{table}

\begin{commentary}
\begin{comment}
We considered raising exceptions on integer divide by zero, with these
exceptions causing a trap in most execution environments.  However,
this would be the only arithmetic trap in the standard ISA
(floating-point exceptions set flags and write default values, but do
not cause traps) and would require language implementors to interact
with the execution environment's trap handlers for this case.
Further, where language standards mandate that a divide-by-zero
exception must cause an immediate control flow change, only a single
branch instruction needs to be added to each divide operation, and
this branch instruction can be inserted after the divide and should
normally be very predictably not taken, adding little runtime
overhead.
\end{comment}

私たちは、整数のゼロ除算時に例外を発生させ、
その例外がほとんどの実行環境でトラップを引き起こすことを検討しました。 
しかし、これは標準ISAにおける唯一の算術トラップであり(浮動小数点の例外はフラグの設定とデフォルト値の書き込みを行いますが、トラップは発生しません)、
この場合、言語実装者は実行環境のトラップ・ハンドラと対話する必要があります。
さらに、言語標準では、ゼロ除算例外は直ちに制御フローを変更しなければならないことになっていますが、
各除算操作には1つの分岐命令を追加するだけでよく、この分岐命令は除算の後に挿入することができ、
通常は非常に予測しやすく取られないはずなので、実行時のオーバーヘッドはほとんどありません。

\begin{comment}
The value of all bits set is returned for both unsigned and signed
divide by zero to simplify the divider circuitry.  The value of all 1s
is both the natural value to return for unsigned divide, representing
the largest unsigned number, and also the natural result for simple
unsigned divider implementations.  Signed division is often
implemented using an unsigned division circuit and specifying the same
overflow result simplifies the hardware.
\end{comment}

すべてのビットが1の値は、符号なしの除算と符号ありの除算の両方で返され、
除算回路を簡素化します。
全てのビットが1の値は、符号なし除算では最大の符号なし数を表す自然な値であると同時に、
単純な符号なし除算器の実装では自然な結果となります。
符号付きの除算は、符号なしの除算回路を使って実装されることが多く、
オーバーフローの結果を同じにすることで、ハードウェアを簡素化することができます。
\end{commentary}
