\begin{comment}
\chapter{``F'' Standard Extension for Single-Precision Floating-Point,
Version 2.2}
\end{comment}
\chapter{単精度浮動小数点のための``F'' 標準拡張}
\label{sec:single-float}

\begin{comment}
This chapter describes the standard instruction-set extension for
single-precision floating-point, which is named ``F'' and adds
single-precision floating-point computational instructions compliant
with the IEEE 754-2008 arithmetic standard~\cite{ieee754-2008}.
The F extension depends on the ``Zicsr'' extension for control
and status register access.
\end{comment}

本章では，単精度浮動小数点用の標準的な命令セット拡張について説明します。
この拡張は，IEEE 754-2008 算術規格に準拠した単精度浮動小数点演算命令を追加するもので、``F''と名付けられています。
F拡張は、制御およびステータス・レジスタ・アクセスのために``Zicsr''拡張に依存しています。

\begin{comment}
\section{F Register State}
\end{comment}
\section{Fレジスタステート}

\begin{comment}
The F extension adds 32 floating-point registers, {\tt f0}--{\tt f31},
each 32 bits wide, and a floating-point control and status register
{\tt fcsr}, which contains the operating mode and exception status of the
floating-point unit.  This additional state is shown in
Figure~\ref{fprs}.  We use the term FLEN to describe the width of the
floating-point registers in the RISC-V ISA, and FLEN=32 for the F
single-precision floating-point extension.  Most floating-point
instructions operate on values in the floating-point register file.
Floating-point load and store instructions transfer floating-point
values between registers and memory.  Instructions to transfer values
to and from the integer register file are also provided.
\end{comment}

F拡張では、32ビット幅の浮動小数点レジスタ{\tt f0}--{\tt f31}と、
浮動小数点ユニットの動作モードや例外処理の状態を示す浮動小数点コントロール・ステータス・レジスタ{\tt fcsr}が追加されます。
この追加ステートは図~\ref{fprs}に示されています。 
ここでは、RISC-V ISAの浮動小数点レジスタの幅を表すためにFLENという用語を使用し、
F単精度浮動小数点拡張の場合はFLEN=32としています。 
ほとんどの浮動小数点命令は、浮動小数点レジスタ・ファイルの値を操作します。
浮動小数点のロードおよびストア命令は、レジスタとメモリの間で浮動小数点値を転送します。
また、整数レジスタ・ファイルとの間で値を転送する命令も用意されています。

\begin{figure}[htbp]
{\footnotesize
\begin{center}
\begin{tabular}{p{2in}}
\instbitrange{FLEN-1}{0}                                    \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ f0\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ f1\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ f2\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ f3\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ f4\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ f5\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ f6\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ f7\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ f8\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ f9\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ f10\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ f11\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ f12\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ f13\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ f14\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ f15\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ f16\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ f17\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ f18\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ f19\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ f20\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ f21\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ f22\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ f23\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ f24\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ f25\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ f26\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ f27\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ f28\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ f29\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ f30\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ f31\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{c}{FLEN}                                    \\

\instbitrange{31}{0}                                        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{fcsr}}                       \\ \cline{1-1}
\multicolumn{1}{c}{32}                                      \\
\end{tabular}
\end{center}
}
\begin{comment}
\caption{RISC-V standard F extension single-precision floating-point state.}
\end{comment}
\caption{RISC-V 標準F拡張単精度浮動小数点ステート}
\label{fprs}
\end{figure}

\begin{commentary}
\begin{comment}
We considered a unified register file for both integer and
floating-point values as this simplifies software register allocation
and calling conventions, and reduces total user state.  However, a
split organization increases the total number of registers accessible
with a given instruction width, simplifies provision of enough regfile
ports for wide superscalar issue, supports decoupled
floating-point-unit architectures, and simplifies use of internal
floating-point encoding techniques.  Compiler support and calling
conventions for split register file architectures are well understood,
and using dirty bits on floating-point register file state can reduce
context-switch overhead.
\end{comment}
我々は、整数値と浮動小数点値の両方に対応する統一されたレジスタファイルを検討しました。
これは、ソフトウェア・レジスタの割り当てと呼び出し規則を簡素化し、ユーザー・ステートの総数を減らすことができるからです。 
しかし、分割された構成の場合には、所定の命令幅でアクセス可能なレジスタの総数が増え、
スーパースカラの広い問題に対して十分なレジスタファイルポートを提供することが容易になり、
非結合浮動小数点ユニット・アーキテクチャをサポートし、内部浮動小数点エンコーディング技術の使用が容易になります。 
分割レジスタファイル・アーキテクチャに対するコンパイラのサポートと呼び出し規約はよく理解されており、
浮動小数点レジスタファイルの状態にダーティビットを使用することで、
コンテキストスイッチのオーバーヘッドを削減することができます。
\end{commentary}

\clearpage

\begin{comment}
\section{Floating-Point Control and Status Register}
\end{comment}
\section{浮動小数点 制御・ステータスレジスタ}

\begin{comment}
The floating-point control and status register, {\tt fcsr}, is a RISC-V
control and status register (CSR).  It is a 32-bit read/write register that
selects the dynamic rounding mode for floating-point arithmetic operations and
holds the accrued exception flags, as shown in Figure~\ref{fcsr}.
\end{comment}

浮動小数点制御・ステータスレジスタ{\tt fcsr}は、RISC-Vの制御・ステータスレジスタ(CSR)です。 
32ビットのリード/ライトレジスタで、図~\ref{fcsr}のように、浮動小数点演算の動的丸め込みモードの選択や、
発生した例外フラグを保持します。

\begin{figure*}[h]
{\footnotesize
\begin{center}
\begin{tabular}{K@{}E@{}ccccc}
\instbitrange{31}{8} &
\instbitrange{7}{5} &
\instbit{4} &
\instbit{3} &
\instbit{2} &
\instbit{1} &
\instbit{0} \\
\hline
\multicolumn{1}{|c|}{{\em Reserved}} &
\multicolumn{1}{c|}{Rounding Mode ({\tt frm})} &
\multicolumn{5}{c|}{Accrued Exceptions ({\tt fflags})} \\
\hline
\multicolumn{1}{c}{} &
\multicolumn{1}{c|}{} &
\multicolumn{1}{c|}{NV} &
\multicolumn{1}{c|}{DZ} &
\multicolumn{1}{c|}{OF} &
\multicolumn{1}{c|}{UF} &
\multicolumn{1}{c|}{NX} \\
\cline{3-7}
24 & 3 & 1 & 1 & 1 & 1 & 1 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\begin{comment}
\caption{Floating-point control and status register.}
\end{comment}
\caption{浮動小数点制御・ステータスレジスタ}
\label{fcsr}
\end{figure*}

\begin{comment}
The {\tt fcsr} register can be read and written with the FRCSR and
FSCSR instructions, which are assembler pseudoinstructions built on the
underlying CSR access instructions.  FRCSR reads {\tt fcsr} by copying
it into integer register {\em rd}.  FSCSR swaps the value in {\tt
  fcsr} by copying the original value into integer register {\em rd},
and then writing a new value obtained from integer register {\em rs1}
into {\tt fcsr}.
\end{comment}

FRCSR、FSCSRは、CSRアクセス命令をベースにしたアセンブラの擬似命令で、
レジスタの読み書きが可能です。 
FRCSRは{\tt fcsr}を読みだして、整数レジスタ{\em rd}にコピーします。
FSCSRは、{\tt fcsr}の値を、元の値を整数レジスタ{\em rd}にコピーし、
整数レジスタ{\tt rs1}から得た新しい値を{\tt fcsr}に書き込むことでスワップします。

\begin{comment}
The fields within the {\tt fcsr} can also be accessed individually
through different CSR addresses, and separate assembler pseudoinstructions are
defined for these accesses.  The FRRM instruction reads the Rounding
Mode field {\tt frm} and copies it into the least-significant three
bits of integer register {\em rd}, with zero in all other bits.  FSRM
swaps the value in {\tt frm} by copying the original value into
integer register {\em rd}, and then writing a new value obtained from
the three least-significant bits of integer register {\em rs1} into
{\tt frm}.  FRFLAGS and FSFLAGS are defined analogously for the
Accrued Exception Flags field {\tt fflags}.
\end{comment}

{\tt fcsr}内のフィールドは、それぞれ別のCSRアドレスでアクセスすることも可能で、
そのためのアセンブラ疑似命令も別途定義されています。
FRRM命令は、丸めモードフィールドの値を整数レジスタ{\tt frm}の最下位3ビットにコピーし、それ以外のビットは0にします。 
FSRMは、{\tt frm}の値を整数レジスタ{\em rd}にコピーした後、
整数レジスタ{\em rs1}の下位3ビットから得られる新しい値を{\tt frm}に書き込むことで、
frmの値を交換します。 
FRFLAGSとFSFLAGSは、同様に未処理の例外フラグフィールド{\tt fflags}に定義されています。

\begin{comment}
Bits 31--8 of the {\tt fcsr} are reserved for other standard extensions,
including the ``L'' standard extension for decimal floating-point.  If
these extensions are not present, implementations shall ignore writes to
these bits and supply a zero value when read.  Standard software should
preserve the contents of these bits.
\end{comment}

{\tt fcsr}の31--8ビットは、10進法の浮動小数点の拡張機能である``L''を含む、その他の標準的な拡張機能のために予約されています。 
これらの拡張機能が存在しない場合、実装はこれらのビットへの書き込みを無視し、
読み出し時にはゼロの値を提供しなければなりません。 
標準的なソフトウェアでは、これらのビットの内容を保持する必要があります。

\begin{comment}
Floating-point operations use either a static rounding mode encoded in
the instruction, or a dynamic rounding mode held in {\tt frm}.
Rounding modes are encoded as shown in Table~\ref{rm}.  A value of 111
in the instruction's {\em rm} field selects the dynamic rounding mode
held in {\tt frm}.  The behavior of floating-point instructions that
depend on rounding mode when executed with a reserved rounding mode is
{\em reserved}, including both static reserved rounding modes (101--110) and
dynamic reserved rounding modes (101--111).  Some instructions, including
widening conversions, have the {\em rm} field but are nevertheless
mathematically unaffected by the rounding mode; software should set their
{\em rm} field to RNE (000) but implementations must treat the {\em rm}
field as usual (in particular, with regard to decoding legal vs. reserved
encodings).
\end{comment}

浮動小数点演算では、命令にエンコードされているスタティックな丸め込みモードと、
{\tt frm}に保持されている動的な丸め込みモードのいずれかを使用します。
丸めモードは、表~\ref{rm}に示すようにエンコードされます。 
111を指定すると、動的丸め込みモードになります。 
丸めモードに依存する浮動小数点演算命令が予約丸めモードで実行された場合の動作は、
静的予約丸めモード(101--110)と動的予約丸めモード(101--111)の両方を含めて、
{\em 予約済み}となります。 
ソフトウェアはそれらのフィールドを RNE(000)に設定する必要がありますが、
実装では通常どおり(特に、合法なエンコーディングと予約エンコーディングのデコードに関して)に扱わなければなりません。

\begin{table}[htp]
\begin{small}
\begin{center}
\begin{tabular}{ccl}
\hline
\multicolumn{1}{|c|}{Rounding Mode} &
\multicolumn{1}{c|}{Mnemonic} &
\multicolumn{1}{c|}{Meaning} \\
\hline
\multicolumn{1}{|c|}{000} &
\multicolumn{1}{l|}{RNE} &
\multicolumn{1}{l|}{Round to Nearest, ties to Even}\\
\hline
\multicolumn{1}{|c|}{001} &
\multicolumn{1}{l|}{RTZ} &
\multicolumn{1}{l|}{Round towards Zero}\\
\hline
\multicolumn{1}{|c|}{010} &
\multicolumn{1}{l|}{RDN} &
\multicolumn{1}{l|}{Round Down (towards $-\infty$)}\\
\hline
\multicolumn{1}{|c|}{011} &
\multicolumn{1}{l|}{RUP} &
\multicolumn{1}{l|}{Round Up (towards $+\infty$)}\\
\hline
\multicolumn{1}{|c|}{100} &
\multicolumn{1}{l|}{RMM} &
\multicolumn{1}{l|}{Round to Nearest, ties to Max Magnitude}\\
\hline
\multicolumn{1}{|c|}{101} &
\multicolumn{1}{l|}{} &
\multicolumn{1}{l|}{\em Reserved for future use.}\\
\hline
\multicolumn{1}{|c|}{110} &
\multicolumn{1}{l|}{} &
\multicolumn{1}{l|}{\em Reserved for future use.}\\
\hline
\multicolumn{1}{|c|}{111} &
\multicolumn{1}{l|}{DYN} &
\multicolumn{1}{l|}{In instruction's {\em rm} field, selects dynamic rounding mode;}\\
\multicolumn{1}{|c|}{} &
\multicolumn{1}{l|}{} &
\multicolumn{1}{l|}{In Rounding Mode register, {\em reserved}.}\\
\hline
\end{tabular}
\end{center}
\end{small}
\begin{comment}
\caption{Rounding mode encoding.}
\end{comment}
\caption{丸めモードのエンコーディング}
\label{rm}
\end{table}

\begin{commentary}
\begin{comment}
The C99 language standard effectively mandates the provision of a
dynamic rounding mode register.  In typical implementations, writes to
the dynamic rounding mode CSR state will serialize the pipeline.
Static rounding modes are used to implement specialized arithmetic
operations that often have to switch frequently between different
rounding modes.
\end{comment}

C99言語規格では、動的丸めモードのレジスタを用意することが事実上義務付けられています。 
一般的な実装では、動的丸めモードのCSRステートへの書き込みは、パイプラインをシリアル化します。
静的丸めモードは、異なる丸めモードを頻繁に切り替える必要のある特殊な算術演算の実装に使用されます。

\begin{comment}
The ratified version of the F spec mandated that an illegal
instruction exception was raised when an instruction was executed with
a reserved dynamic rounding mode.  This has been weakened to reserved,
which matches the behavior of static rounding-mode instructions.
Raising an illegal instruction exception is still valid behavior when
encountering a reserved encoding, so implementations compatible with
the ratified spec are compatible with the weakened spec.
\end{comment}

批准されたF仕様では、予約された動的丸めモードの命令を実行した場合、
不正な命令の例外を発生させることが義務付けられていました。 
これがreservedに弱められ、静的丸めモードの命令の動作と一致するようになりました。
予約済みのエンコーディングに遭遇したときに不正命令例外を発生させることは有効な動作であるため、
批准された仕様と互換性のある実装は、弱められた仕様とも互換性があります。
\end{commentary}
 
\begin{comment}
The accrued exception flags indicate the exception conditions that
have arisen on any floating-point arithmetic instruction since the
field was last reset by software, as shown in Table~\ref{bitdef}.
The base RISC-V ISA
does not support generating a trap on the setting of a floating-point
exception flag.
\end{comment}

発生した例外フラグは、フィールドがソフトウェアによって最後にリセットされて以来、あらゆる浮動小数点演算命令で発生した例外条件を示しています(表~\ref{bitdef}に示すとおり)。
ベースとなるRISC-V ISAは、浮動小数点例外フラグの設定によるトラップの生成をサポートしていません。

\begin{table}[htp]
\begin{small}
\begin{center}
\begin{tabular}{cl}
\hline
\multicolumn{1}{|c|}{Flag Mnemonic} &
\multicolumn{1}{c|}{Flag Meaning} \\
\hline
\multicolumn{1}{|c|}{NV} &
\multicolumn{1}{c|}{Invalid Operation}\\
\hline
\multicolumn{1}{|c|}{DZ} &
\multicolumn{1}{c|}{Divide by Zero}\\
\hline
\multicolumn{1}{|c|}{OF} &
\multicolumn{1}{c|}{Overflow}\\
\hline
\multicolumn{1}{|c|}{UF} &
\multicolumn{1}{c|}{Underflow}\\
\hline
\multicolumn{1}{|c|}{NX} &
\multicolumn{1}{c|}{Inexact}\\
\hline
\end{tabular}
\end{center}
\end{small}
\caption{Accrued exception flag encoding.}
\label{bitdef}
\end{table}

\begin{commentary}
\begin{comment}
As allowed by the standard, we do not support traps on floating-point
exceptions in the base ISA, but instead require explicit checks of the flags
in software.  We considered adding branches controlled directly by the
contents of the floating-point accrued exception flags, but ultimately chose
to omit these instructions to keep the ISA simple.
\end{comment}
規格で認められているように、ベースISAでは浮動小数点例外のトラップをサポートせず、ソフトウェアでフラグを明示的にチェックすることにしました。
浮動小数点の例外フラグの内容によって直接制御される分岐を追加することも検討しましたが、
最終的にはISAをシンプルに保つためにこれらの命令を省略することにしました。
\end{commentary}

\begin{comment}
\section{NaN Generation and Propagation}
\end{comment}
\section{NaNの生成と伝搬}

\begin{comment}
Except when otherwise stated, if the result of a floating-point operation is
NaN, it is the canonical NaN.  The canonical NaN has a positive sign and all
significand bits clear except the MSB, a.k.a. the quiet bit.  For
single-precision floating-point, this corresponds to the pattern {\tt
0x7fc00000}.
\end{comment}

別段の記載がある場合を除き、浮動小数点演算の結果がNaNの場合、それはcanonical NaNです。
canonicalのNaNは正の符号を持ち、MSB(別名quietビット)を除くすべてのsignificandビットがクリアされています。
単精度浮動小数点の場合、これは{\tt 0x7fc00000}というパターンに相当します。

\begin{commentary}
\begin{comment}
We considered propagating NaN payloads, as is recommended by the standard,
but this decision would have increased hardware cost.  Moreover, since this
feature is optional in the standard, it cannot be used in portable code.
\end{comment}

規格で推奨されているように、NaNペイロードを伝搬させることも検討しましたが、
この決定はハードウェアのコストを増加させることになります。 
また、この機能は規格のオプションであるため、ポータブルコードでは使用できません。

\begin{comment}
Implementors are free to provide a NaN payload propagation scheme as
a nonstandard extension enabled by a nonstandard operating mode.  However, the
canonical NaN scheme described above must always be supported and should be
the default mode.
\end{comment}

実装者は、非標準の動作モードで有効な非標準の拡張機能として、
NaNペイロード伝搬方式を自由に提供できます。 
しかし、上述のcanonical NaNスキームは常にサポートされなければならず、デフォルトのモードであるべきです。
\end{commentary}

\begin{commentary}
\begin{comment}
We require implementations to return the standard-mandated default
values in the case of exceptional conditions, without any further
intervention on the part of user-level software (unlike the Alpha ISA
floating-point trap barriers).  We believe full hardware handling of
exceptional cases will become more common, and so wish to avoid
complicating the user-level ISA to optimize other approaches.
Implementations can always trap to machine-mode software handlers to
provide exceptional default values.
\end{comment}

私たちは、例外的な状況が発生した場合には、ユーザ・レベル・ソフトウェアが一切の介入をすることなく、
標準で定められたデフォルト値を返すように実装することを要求します(Alpha ISAの浮動小数点トラップ・バリアとは異なります)。
私たちは、例外的なケースをハードウェアで完全に処理することがより一般的になると考えているため、
他のアプローチを最適化するためにユーザーレベルのISAを複雑にすることは避けたいと考えています。
実装では、例外的なデフォルト値を提供するために、マシン・モードのソフトウェア・ハンドラーにいつでもトラップすることができます。
\end{commentary}

\begin{comment}
\section{Subnormal Arithmetic}
\end{comment}
\section{サブノーマル演算}

\begin{comment}
Operations on subnormal numbers are handled in accordance with the IEEE
754-2008 standard.
\end{comment}
サブノーマル数に対する演算は、IEEE 754-2008規格に基づいて処理されます。

\begin{comment}
In the parlance of the IEEE standard, tininess is detected after rounding.
\end{comment}
IEEE規格の用語では、丸め後に非常に小さな数が検出されます。

\begin{commentary}
\begin{comment}
Detecting tininess after rounding results in fewer spurious underflow signals.
\end{comment}
丸めた後に非常に小さな数を検出することで、偽のアンダーフロー信号が少なくなります。
\end{commentary}

\begin{comment}
\section{Single-Precision Load and Store Instructions}
\end{comment}
\section{単精度ロードストア命令}

\begin{comment}
Floating-point loads and stores use the same base+offset addressing
mode as the integer base ISA, with a base address in register {\em
  rs1} and a 12-bit signed byte offset.  The FLW instruction loads a
single-precision floating-point value from memory into floating-point
register {\em rd}.  FSW stores a single-precision value from
floating-point register {\em rs2} to memory.
\end{comment}

浮動小数点のロード／ストアは、整数ベースのISAと同じベース+オフセット・アドレッシング・モードを使用し、
{\em rs1}レジスタのベース・アドレスと12ビットの符号付きバイト・オフセットを使用します。 
FLW命令は、メモリから単精度浮動小数点値を浮動小数点レジスタ{\em rd} にロードします。 
FSWは、単精度の浮動小数点値を浮動小数点レジスタ{\em rs2}からメモリに格納します。

\vspace{-0.2in}
\begin{center}
\begin{tabular}{M@{}R@{}F@{}R@{}O}
\\
\instbitrange{31}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{imm[11:0]} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{width} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
12 & 5 & 3 & 5 & 7 \\
offset[11:0] & base & W & dest & LOAD-FP \\
\end{tabular}
\end{center}

\vspace{-0.2in}
\begin{center}
\begin{tabular}{O@{}R@{}R@{}F@{}R@{}O}
\\
\instbitrange{31}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{imm[11:5]} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{width} &
\multicolumn{1}{c|}{imm[4:0]} &
\multicolumn{1}{c|}{opcode} \\
\hline
7 & 5 & 5 & 3 & 5 & 7 \\
offset[11:5] & src & base & W & offset[4:0] & STORE-FP \\
\end{tabular}
\end{center}

\begin{comment}
FLW and FSW are only guaranteed to execute atomically if the effective address
is naturally aligned.
\end{comment}

FLWとFSWは、実効アドレスが自然にアラインされている場合にのみ、アトミックに実行されることが保証されています。

\begin{comment}
FLW and FSW do not modify the bits being transferred; in particular, the
payloads of non-canonical NaNs are preserved.
\end{comment}{

FLWとFSWは転送されるビットを変更しません。特に、非CanonicalなNaNのペイロードは保持されます。

\begin{comment}
As described in Section~\ref{sec:rv32:ldst}, the EEI defines whether
misaligned floating-point loads and stores are handled invisibly or raise
a contained or fatal trap.
\end{comment}

第~\ref{sec:rv32:ldst}に記載されているように、EEI は、
ミスアラインの浮動小数点ロードとストアを見えないように処理するか、
containedか致命的なトラップを発生させるかのどちらかを定義しています。

\begin{comment}
\section{Single-Precision Floating-Point Computational Instructions}
\end{comment}
\section{単精度浮動小数点算術命令}
\label{sec:single-float-compute}

\begin{comment}
Floating-point arithmetic instructions with one or two source operands use the
R-type format with the OP-FP major opcode.  FADD.S and FMUL.S perform
single-precision floating-point addition and multiplication respectively,
between {\em rs1} and {\em rs2}. FSUB.S performs the single-precision
floating-point subtraction of {\em rs2} from {\em rs1}.  FDIV.S performs the
single-precision floating-point division of {\em rs1} by {\em rs2}. FSQRT.S
computes the square root of {\em rs1}.  In each case, the result is written to
{\em rd}.
\end{comment}

1つまたは2つのソースオペランドを持つ浮動小数点演算命令は、
OP-FP メジャーオペコードのRタイプ・フォーマットを使用します。
FADD.SとFMUL.Sは、それぞれ{\em rs1}と{\em rs2}の間で単精度浮動小数点の加算と乗算を行います。
FSUB.S は、単精度浮動小数点で{\em rs1}から{\em rs2}の減算を行います。 
FDIV.S は、単精度浮動小数点で{\em rs1}から{\em rs2}の除算を行います。
FSQRT.S は、{\em rs1} の平方根を計算します。
いずれの場合も、結果は{\em rd}に書き込まれます。

\begin{comment}
The 2-bit floating-point format field {\em fmt} is encoded as shown in
Table~\ref{tab:fmt}.  It is set to {\em S} (00) for all instructions in
the F extension.
\end{comment}

2ビットの浮動小数点フォーマットフィールド{\em fmt}は、表~\ref{tab:fmt}に示すようにエンコードされています。
このフィールドにはF拡張のすべての命令で{\em S}(00)が設定されます。

\begin{table}[htp]
\begin{small}
\begin{center}
\begin{tabular}{|c|c|l|}
\hline
{\em fmt} field &
Mnemonic &
Meaning \\
\hline
00 & S & 32-bit single-precision \\
01 & D & 64-bit double-precision \\
10 & H & 16-bit half-precision \\
11 & Q & 128-bit quad-precision \\
\hline
\end{tabular}
\end{center}
\end{small}
\begin{comment}
\caption{Format field encoding.}
\end{comment}
\caption{フォーマットフィールドのエンコーディング}
\label{tab:fmt}
\end{table}

\begin{comment}
All floating-point operations that perform rounding can select the
rounding mode using the {\em rm} field with the encoding shown in
Table~\ref{rm}.
\end{comment}

丸めを行うすべての浮動小数点演算では、表~\ref{rm}に示すエンコーディングを用いて、
{\em rm}フィールドで丸めモードを選択できます。

\begin{comment}
Floating-point minimum-number and maximum-number instructions FMIN.S and
FMAX.S write, respectively, the smaller or larger of {\em rs1} and {\em rs2}
to {\em rd}.  For the purposes of these instructions only, the value $-0.0$ is
considered to be less than the value $+0.0$.  If both inputs are NaNs, the
result is the canonical NaN.  If only one operand is a NaN, the result is the
non-NaN operand.  Signaling NaN inputs set the invalid operation exception flag,
even when the result is not NaN.
\end{comment}

浮動小数点演算の最小値命令FMIN.Sと最大値命令FMAX.Sは、
それぞれ{\em rs1}と{\em rs2}の小さい方と大きい方を{\em rd}に書き込みます。
これらの命令では、$-0.0$の値は$+0.0$の値よりも小さいとみなされます。
両方の入力がNaNの場合、結果はCanonical NaNとなります。
一方のオペランドのみがNaNの場合、結果は非NaNのオペランドになります。
Signaling NaNの入力では、結果がNaNでなくても、無効な操作の例外フラグが設定されます。

\begin{commentary}
\begin{comment}
Note that in version 2.2 of the F extension, the FMIN.S and FMAX.S
instructions were amended to implement the proposed IEEE 754-201x
minimumNumber and maximumNumber operations, rather than the IEEE 754-2008
minNum and maxNum operations.  These operations differ in their handling of
signaling NaNs.
\end{comment}

なお、F拡張機能のバージョン2.2では、FMIN.S命令およびFMAX.S命令が、
IEEE 754-2008の minNum および maxNum 演算ではなく、
提案されているIEEE 754-201xの minimumNumber および maximumNumber 演算を実装するように修正されています。
これらの演算は、シグナリングNaNの扱いが異なります。
\end{commentary}

\vspace{-0.2in}
\begin{center}
\begin{tabular}{R@{}F@{}R@{}R@{}F@{}R@{}O}
\\
\instbitrange{31}{27} &
\instbitrange{26}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{funct5} &
\multicolumn{1}{c|}{fmt} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{rm} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
5 & 2 & 5 & 5 & 3 & 5 & 7 \\
FADD/FSUB & S & src2 & src1 & RM  & dest & OP-FP  \\
FMUL/FDIV & S & src2 & src1 & RM  & dest & OP-FP  \\
FSQRT     & S & 0    & src  & RM  & dest & OP-FP  \\
FMIN-MAX  & S & src2 & src1 & MIN/MAX & dest & OP-FP  \\
\end{tabular}
\end{center}

\begin{comment}
Floating-point fused multiply-add instructions require a new standard
instruction format.  R4-type instructions specify three source
registers ({\em rs1}, {\em rs2}, and {\em rs3}) and a destination
register ({\em rd}).  This format is only used by the floating-point
fused multiply-add instructions.
\end{comment}

浮動小数点の融合乗算加算命令では、新たな標準命令フォーマットが必要となります。
R4タイプの命令では、3つのソースレジスタ({\em rs1}, {\em rs2}, {\em rs3})と1つの書き込みレジスタ({\em rd})が指定されます。
このフォーマットは、浮動小数点の融合乗算加算命令のみで使用されます。

\begin{comment}
FMADD.S multiplies the values in {\em
rs1} and {\em rs2}, adds the value in {\em rs3}, and writes the final
result to {\em rd}.  FMADD.S computes {\em (rs1$\times$rs2)+rs3}.
\end{comment}

FMADD.Sは、{\em rs1}と{\em rs2}の値を掛け合わせ、{\em rs3}の値を加算し、
その結果を{\em rd}に書き込んでいます。
FMADD.Sは{\em (rs1$\times$rs2)+rs3}を計算します。

\begin{comment}
FMSUB.S multiplies the values in {\em rs1} and {\em rs2}, subtracts
the value in {\em rs3}, and writes the final result to {\em rd}.
FMSUB.S computes {\em (rs1$\times$rs2)-rs3}.
\end{comment}

FMSUB.S は{\em rs1}と{\em rs2}の値を掛け合わせ、{\em rs3}の値を引いて、
その結果を{\em rd}に書き込みます。
FMSUB.S は {\em (rs1$\times$rs2)-rs3} を計算します。

\begin{comment}
FNMSUB.S multiplies the
values in {\em rs1} and {\em rs2}, negates the product, adds the value
in {\em rs3}, and writes the final result to {\em rd}. FNMSUB.S
computes {\em -(rs1$\times$rs2)+rs3}.
\end{comment}

FNMSUB.Sは、{\em rs1}と{\em rs2}の値を掛け合わせ、
その積を符号反転し、{\em rs3}の値を加算して、最終結果を{\em rd}に書き込みます。
FNMSUB.Sは{\em -(rs1$\times$rs2)+rs3}を計算します。

\begin{comment}
FNMADD.S multiplies the values
in {\em rs1} and {\em rs2}, negates the product, subtracts the value
in {\em rs3}, and writes the final result to {\em rd}. FNMADD.S
computes {\em -(rs1$\times$rs2)-rs3}.
\end{comment}

FNMADD.Sは、{\em rs1}と{\em rs2}の値を掛け合わせ、
その積を符号反転して、{\em rs3}の値を引き、その結果を{\em rd}に書き込みます。
FNMADD.Sは、{\em -(rs1$\times$rs2)-rs3}を計算します。

\begin{commentary}
\begin{comment}
The FNMSUB and FNMADD instructions are counterintuitively named, owing to the
naming of the corresponding instructions in MIPS-IV.  The MIPS instructions
were defined to negate the sum, rather than negating the product as the
RISC-V instructions do, so the naming scheme was more rational at the time.
The two definitions differ with respect to signed-zero results.  The RISC-V
definition matches the behavior of the x86 and ARM fused multiply-add
instructions, but unfortunately the RISC-V FNMSUB and FNMADD instruction
names are swapped compared to x86 and ARM.
\end{comment}

FNMSUB命令とFNMADD命令は、MIPS-IVでの対応する命令の命名を受けて、逆に命名されています。
MIPSの命令は、RISC-Vの命令のように積を符号反転するのではなく、和を符号反転するように定義されていたので、
当時はこの命名方法が合理的だったのです。
この2つの定義は、符号付きゼロの結果については異なります。
RISC-Vの定義はx86とARMの融合乗算加算命令の動作と一致していますが、
残念ながらRISC-VのFNMSUBとFNMADDの命令名はx86とARMと比べて入れ替わっています。

\end{commentary}

\vspace{-0.2in}
\begin{center}
\begin{tabular}{R@{}F@{}R@{}R@{}F@{}R@{}O}
\\
\instbitrange{31}{27} &
\instbitrange{26}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{rs3} &
\multicolumn{1}{c|}{fmt} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{rm} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
5 & 2 & 5 & 5 & 3 & 5 & 7 \\
src3 & S & src2 & src1 & RM  & dest & F[N]MADD/F[N]MSUB  \\
\end{tabular}
\end{center}

\begin{commentary}
\begin{comment}
 The fused multiply-add (FMA) instructions consume a large part of the
 32-bit instruction encoding space.  Some alternatives considered were
 to restrict FMA to only use dynamic rounding modes, but static
 rounding modes are useful in code that exploits the lack of product
 rounding.  Another alternative would have been to use rd to provide
 rs3, but this would require additional move instructions in some
 common sequences.  The current design still leaves a large portion of
 the 32-bit encoding space open while avoiding having FMA be
 non-orthogonal.
\end{comment}

FMA(Fused Multiply-Add)命令は、32ビット命令のエンコーディング空間の大部分を消費します。
FMAの使用を動的丸めモードのみに制限することも検討されましたが、静的丸めモードは積の丸め込みができないことを利用したコードでは有用です。
また、rdを使用してrs3を提供するという選択肢もありましたが、この場合、
いくつかの一般的な配列で追加のmove命令が必要になります。
現在の設計では、FMAの非直交性を回避しつつ、32ビットのエンコーディング空間の大部分を空けています。
\end{commentary}

\begin{comment}
The fused multiply-add instructions must set the invalid operation exception flag
when the multiplicands are $\infty$ and zero, even when the addend is a quiet
NaN.
\end{comment}

融合乗算加算命令では、加算値がquiet NaNであっても、乗算値が$\infty$と0の場合は、
無効な演算例外フラグを設定しなければなりません。

\begin{commentary}
\begin{comment}
The IEEE 754-2008 standard permits, but does not require, raising the
invalid exception for the operation \mbox{$\infty\times 0\ +$ qNaN}.
\end{comment}

IEEE 754-2008 規格では、演算\mbox{$\infty\times 0\ +$ qNaN}の際に
無効な例外を発生させることは許可されていますが、必須ではありません。
\end{commentary}

\begin{comment}
\section{Single-Precision Floating-Point Conversion and Move \mbox{Instructions}}
\end{comment}
\section{単精度浮動小数点変換・データ移動\mbox{命令}}

\begin{comment}
Floating-point-to-integer and integer-to-floating-point conversion
instructions are encoded in the OP-FP major opcode space.
FCVT.W.S or FCVT.L.S converts a floating-point number
in floating-point register {\em rs1} to a signed 32-bit or 64-bit
integer, respectively, in integer register {\em rd}.  FCVT.S.W
or FCVT.S.L converts a 32-bit or 64-bit signed integer,
respectively, in integer register {\em rs1} into a floating-point
number in floating-point register {\em rd}. FCVT.WU.S,
FCVT.LU.S, FCVT.S.WU, and FCVT.S.LU variants
convert to or from unsigned integer values.
For XLEN$>32$, FCVT.W[U].S sign-extends the 32-bit result to the
destination register width.
FCVT.L[U].S and FCVT.S.L[U] are RV64-only instructions.
If the rounded result is not representable in the destination format,
it is clipped to the nearest value and the invalid flag is set.
Table~\ref{tab:int_conv} gives the range of valid inputs for FCVT.{\em int}.S
and the behavior for invalid inputs.
\end{comment}

浮動小数点から整数、整数から浮動小数点への変換命令は、
OP-FPメジャー・オペコード空間にエンコードされています。
FCVT.W.SまたはFCVT.L.Sは，浮動小数点レジスタ{\em rs1}内の浮動小数点数を、
整数レジスタ{\em rd}内の符号付き32ビット整数または64ビット整数にそれぞれ変換します。
FCVT.S.W または FCVT.S.L はそれぞれ整数レジスタの 32 ビットまたは 64 ビットの符号付き整数を浮動小数点レジスタの浮動小数点数に変換します。
FCVT.WU.S, FCVT.LU.S, FCVT.S.WU, FCVT.S.LU は、
符号なし整数値との間で変換します。
XLEN$>32$の場合，FCVT.W[U].Sは32ビットの結果を出力レジスタの幅に合わせて符号拡張します。
FCVT.L[U].SとFCVT.S.L[U]はRV64専用の命令です。
丸められた結果が出力形式で表現できない場合は，最も近い値にクリップされ，無効フラグが設定されます．
表~\ref{tab:int_conv}はFCVT.{\em int}.Sの有効な入力範囲および無効な入力値の動作を示しています。

\begin{table}[htp]
\begin{small}
\begin{center}
\begin{tabular}{|l|r|r|r|r|}
\hline
 & FCVT.W.S & FCVT.WU.S & FCVT.L.S & FCVT.LU.S \\
\hline
Minimum valid input (after rounding) & $-2^{31}$ & 0 & $-2^{63}$ & 0 \\
Maximum valid input (after rounding) & $2^{31}-1$ & $2^{32}-1$ & $2^{63}-1$ & $2^{64}-1$ \\
\hline
Output for out-of-range negative input & $-2^{31}$ & 0 & $-2^{63}$ & 0 \\
Output for $-\infty$ & $-2^{31}$ & 0 & $-2^{63}$ & 0 \\
Output for out-of-range positive input & $2^{31}-1$ & $2^{32}-1$ & $2^{63}-1$ & $2^{64}-1$ \\
Output for $+\infty$ or NaN & $2^{31}-1$ & $2^{32}-1$ & $2^{63}-1$ & $2^{64}-1$ \\
\hline
\end{tabular}
\end{center}
\end{small}
\caption{Domains of float-to-integer conversions and behavior for invalid inputs.}
\label{tab:int_conv}
\end{table}

\begin{comment}
All floating-point to integer and integer to floating-point conversion
instructions round according to the {\em rm} field.  A floating-point register
can be initialized to floating-point positive zero using FCVT.S.W {\em rd},
{\tt x0}, which will never set any exception flags.
\end{comment}

すべての浮動小数点から整数、整数から浮動小数点変換命令は、{\em rm}フィールドに従って丸められます。
浮動小数点レジスタは、FCVT.S.W {\em rd}, {\tt x0}を使って浮動小数点の正のゼロに初期化することができますが、
これはいかなる例外フラグもセットしません。

\begin{comment}
All floating-point conversion instructions set the Inexact exception flag if
the rounded result differs from the operand value and the Invalid exception
flag is not set.
\end{comment}

すべての浮動小数点変換命令は、丸められた結果がオペランドの値と異なり、
無効例外フラグが設定されていない場合、不正確例外フラグを設定します。

\vspace{-0.2in}
\begin{center}
\begin{tabular}{R@{}F@{}R@{}R@{}F@{}R@{}O}
\\
\instbitrange{31}{27} &
\instbitrange{26}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{funct5} &
\multicolumn{1}{c|}{fmt} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{rm} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
5 & 2 & 5 & 5 & 3 & 5 & 7 \\
FCVT.{\em int}.{\em fmt} & S & W[U]/L[U] & src & RM  & dest & OP-FP  \\
FCVT.{\em fmt}.{\em int} & S & W[U]/L[U] & src & RM  & dest & OP-FP  \\
\end{tabular}
\end{center}

\begin{comment}
Floating-point to floating-point sign-injection instructions, FSGNJ.S,
FSGNJN.S, and FSGNJX.S, produce a result that takes all bits except
the sign bit from {\em rs1}.  For FSGNJ, the result's sign bit is {\em
  rs2}'s sign bit; for FSGNJN, the result's sign bit is the opposite
of {\em rs2}'s sign bit; and for FSGNJX, the sign bit is the XOR of
the sign bits of {\em rs1} and {\em rs2}.  Sign-injection instructions
do not set floating-point exception flags, nor do they canonicalize
NaNs.  Note, FSGNJ.S {\em rx, ry,
  ry} moves {\em ry} to {\em rx} (assembler pseudoinstruction FMV.S {\em rx,
  ry}); FSGNJN.S {\em rx, ry, ry} moves the negation of {\em ry} to
{\em rx} (assembler pseudoinstruction FNEG.S {\em rx, ry}); and FSGNJX.S {\em rx,
  ry, ry} moves the absolute value of {\em ry} to {\em rx} (assembler
pseudoinstruction FABS.S {\em rx, ry}).
\end{comment}

浮動小数点から浮動小数点への符号注入命令 FSGNJ.S、FSGNJN.S、FSGNJX.S は、
符号ビットを除くすべてのビットを {\em rs1} から取得した結果を生成します。
FSGNJでは、結果の符号ビットが{\em rs2}の符号ビットとなり、
FSGNJNでは、結果の符号ビットが{\em rs2}の符号ビットの反対となり、
FSGNJXでは、符号ビットが{\em rs1}と{\em rs2}の符号ビットのXORとなります。
符号注入命令は、浮動小数点の例外フラグを設定したり、NaNを正規化したりすることはありません。
なお、FSGNJ.S {\em rx, ry, ry}は、{\em ry}を{\em rx}に移動させる命令です。
(アセンブラの擬似命令 FMV.S {\em rx, ry})
FSGNJN.S {\em rx, ry, ry}は、{\em ry}の否定を{\em rx}に移動します
(アセンブルらの疑似命令 FNEG.S {\em rx, ry})。
FSGNJX.S {\em rx, ry, ry}は、{\em ry}の絶対値を{\em rx}に移動します
(アセンブラの擬似命令 FNEG.S {\em rx, ry})。
アセンブラの疑似命令 FABS.S {\em rx, ry}）があります。

\vspace{-0.2in}
\begin{center}
\begin{tabular}{R@{}F@{}R@{}R@{}F@{}R@{}O}
\\
\instbitrange{31}{27} &
\instbitrange{26}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{funct5} &
\multicolumn{1}{c|}{fmt} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{rm} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
5 & 2 & 5 & 5 & 3 & 5 & 7 \\
FSGNJ & S & src2 & src1 & J[N]/JX & dest & OP-FP  \\
\end{tabular}
\end{center}

\begin{commentary}
\begin{comment}
The sign-injection instructions
provide floating-point MV, ABS, and NEG,
as well as supporting a few other operations, including the IEEE copySign
operation and sign manipulation in transcendental math function
libraries.  Although MV, ABS, and NEG only need a single register
operand, whereas FSGNJ instructions need two, it is unlikely most
microarchitectures would add optimizations to benefit from the reduced
number of register reads for these relatively infrequent instructions.
Even in this case, a microarchitecture can simply detect when both
source registers are the same for FSGNJ instructions and only read a
single copy.
\end{comment}

符号注入命令は、浮動小数点のMV、ABS、NEGを提供するほか、
IEEEのcopySign演算や超越数学関数ライブラリでの符号操作など、
いくつかの演算をサポートしています。 
MV、ABS、NEGはレジスタ・オペランドを1つしか必要としないのに対し、FSGNJ命令は2つ必要としますが、
ほとんどのマイクロアーキテクチャが、これらの比較的頻度の低い命令のレジスタリード数の減少から利益を得るための最適化を追加するとは考えられません。
この場合でも、マイクロアーキテクチャは、FSGNJ命令のソースレジスタが両方とも同じであることを単純に検出し、1つのコピーだけを読み取ることができます。

\end{commentary}

\begin{comment}
Instructions are provided to move bit patterns between the
floating-point and integer registers.  FMV.X.W moves the
single-precision value in floating-point register {\em rs1}
represented in IEEE 754-2008 encoding to the lower 32 bits of integer
register {\em rd}.  The bits are not
modified in the transfer, and in particular, the payloads of
non-canonical NaNs are preserved.
For RV64, the higher 32 bits of the destination
register are filled with copies of the floating-point number's sign
bit.
\end{comment}

浮動小数点レジスタと整数レジスタの間でビットパタンを移動させる命令が用意されています。
FMV.X.Wは，IEEE 754-2008エンコーディングで表現された浮動小数点レジスタ{\em rs1}の単精度値を、
整数レジスタ{\em rd}の下位32ビットに移動します。 
移動の際、ビットは変更されず、非Canonical NaNのペイロードは保持されます。
RV64の場合、書き込みレジスタの上位32ビットは、浮動小数点数の符号ビットのコピーで埋められます。

\begin{comment}
FMV.W.X moves the single-precision value encoded in IEEE
754-2008 standard encoding from the lower 32 bits of integer register
{\em rs1} to the floating-point register {\em rd}.  The bits are not
modified in the transfer, and in particular, the payloads of
non-canonical NaNs are preserved.
\end{comment}

FMV.W.Xは、IEEE 754-2008標準エンコーディングでエンコードされた単精度値を、
整数レジスタ{\em rs1}の下位32ビットから浮動小数点レジスタ{\em rd}の下位32ビットに移動します。
転送の際、ビットは変更されず、特に非Canonical NaNのペイロードは保存されます。

\begin{commentary}
\begin{comment}
The FMV.W.X and FMV.X.W instructions were previously called FMV.S.X
and FMV.X.S.  The use of W is more consistent with their semantics as
an instruction that moves 32 bits without interpreting them.  This
became clearer after defining NaN-boxing.  To avoid disturbing
existing code, both the W and S versions will be supported by tools.
\end{comment}

FMV.W.XおよびFMV.X.W命令は、以前はFMV.S.XおよびFMV.X.Sと呼ばれていました。
Wの使用は、32ビットを解釈せずに移動させる命令としての動作と合致しています。 
これは、NaN-boxingを定義した後に明らかになりました。 
既存のコードに影響を与えないように、W版とS版の両方をツールでサポートする予定です。
\end{commentary}

\vspace{-0.2in}
\begin{center}
\begin{tabular}{R@{}F@{}R@{}R@{}F@{}R@{}O}
\\
\instbitrange{31}{27} &
\instbitrange{26}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{funct5} &
\multicolumn{1}{c|}{fmt} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{rm} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
5 & 2 & 5 & 5 & 3 & 5 & 7 \\
FMV.X.W & S & 0    & src  & 000  & dest & OP-FP  \\
FMV.W.X & S & 0    & src  & 000  & dest & OP-FP  \\
\end{tabular}
\end{center}

\begin{commentary}
\begin{comment}
The base floating-point ISA was defined so as to allow implementations
to employ an internal recoding of the floating-point format in
registers to simplify handling of subnormal values and possibly to
reduce functional unit latency.  To this end, the base ISA avoids
representing integer values in the floating-point registers by
defining conversion and comparison operations that read and write the
integer register file directly.  This also removes many of the common
cases where explicit moves between integer and floating-point
registers are required, reducing instruction count and critical paths
for common mixed-format code sequences.
\end{comment}

ベースとなる浮動小数点ISAは、レジスタ内の浮動小数点フォーマットを内部的に再コード化することで、
サブノーマル数の処理を容易にし、場合によっては機能ユニットの待ち時間を短縮できるように定義されています。 
このため、基本ISAでは、整数レジスタ・ファイルを直接読み書きする変換および比較演算を定義することで、
浮動小数点レジスタでの整数値の表現することを避けています。 
これにより、整数レジスタと浮動小数点レジスタ間の明示的な移動が必要となる一般的なケースの多くが取り除かれ、
一般的な混合フォーマットのコード・シーケンスの命令数とクリティカル・パスが削減されます。
\end{commentary}

\begin{comment}
\section{Single-Precision Floating-Point Compare Instructions}
\end{comment}
\section{単精度浮動小数点比較命令}

\begin{comment}
Floating-point compare instructions (FEQ.S, FLT.S, FLE.S) perform the
specified comparison between floating-point registers ($\mbox{\em rs1}
= \mbox{\em rs2}$, $\mbox{\em rs1} < \mbox{\em rs2}$, $\mbox{\em rs1} \leq
\mbox{\em rs2}$) writing 1 to the integer register {\em rd} if the condition
holds, and 0 otherwise.
\end{comment}

浮動小数点比較命令(FEQ.S, FLT.S, FLE.S)は、浮動小数点レジスタ間の比較
($\mbox{\em rs1} = \mbox{\em rs2}$, $\mbox{\em rs1} < \mbox{\em rs2}$, $\mbox{\em rs1} \leq \mbox{\em rs2}$)を行います。
条件が成立する場合は1を、そうでない場合は0を整数レジスタ {\em rs2} に書き込みます。

\begin{comment}
FLT.S and FLE.S perform what the IEEE 754-2008 standard refers to as {\em
signaling} comparisons: that is, they set the invalid operation exception flag
if either input is NaN.  FEQ.S performs a {\em quiet} comparison: it only
sets the invalid operation exception flag if either input is a signaling NaN.
For all three instructions,
the result is 0 if either operand is NaN.
\end{comment}

FLT.SおよびFLE.Sは、IEEE 754-2008規格でいうところの{\em シグナリング}比較を行い、
どちらかの入力がNaNである場合に無効操作例外フラグを設定します。 
FEQ.Sは、どちらかの入力がシグナリングNaNである場合にのみ、無効な操作の例外フラグを設定するという、{\em quiet}比較を行います。
3つの命令とも、どちらかのオペランドがNaNの場合、結果は0となります。

\vspace{-0.2in}
\begin{center}
\begin{tabular}{S@{}F@{}R@{}R@{}F@{}R@{}O}
\\
\instbitrange{31}{27} &
\instbitrange{26}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{funct5} &
\multicolumn{1}{c|}{fmt} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{rm} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
5 & 2 & 5 & 5 & 3 & 5 & 7 \\
FCMP & S & src2 & src1 & EQ/LT/LE & dest & OP-FP  \\
\end{tabular}
\end{center}

\begin{commentary}
\begin{comment}
The F extension provides a $\leq$ comparison, whereas the base ISA provides
a $\geq$ branch comparison.  Because $\leq$ can be synthesized from $\geq$ and
vice-versa, there is no performance implication to this inconsistency, but it
is nevertheless an unfortunate incongruity in the ISA.
\end{comment}

F拡張では$\leq$の比較を行いますが、基本ISAでは$\geq$の分岐比較を行います。 
これは、$\geq$から$\leq$を合成することができるため、性能上の問題はありませんが、残念なことに、ISAの不整合です。
\end{commentary}

\begin{comment}
\section{Single-Precision Floating-Point Classify Instruction}
\end{comment}
\section{単精度浮動小数点分類命令}

\begin{comment}
The FCLASS.S instruction examines the value in floating-point register {\em
rs1} and writes to integer register {\em rd} a 10-bit mask that indicates
the class of the floating-point number.  The format of the mask is
described in Table~\ref{tab:fclass}.  The corresponding bit in {\em rd} will
be set if the property is true and clear otherwise.  All other bits in
{\em rd} are cleared.  Note that exactly one bit in {\em rd} will be set.
FCLASS.S does not set the floating-point exception flags.
\end{comment}

FCLASS.S命令は、浮動小数点レジスタの値を調べて、浮動小数点数の分類を示す10ビットのマスクを整数レジスタに書き込みます。
マスクのフォーマットは、表~\ref{tab:fclass}に記載されています。
{\em rd}の対応するビットは、属性がtrueの場合はセットされ、それ以外の場合はクリアされます。
その他のビットはすべてクリアされます。 なお、正確に1ビットがセットされます。
FCLASS.Sは、浮動小数点の例外フラグを設定しません。

\vspace{-0.2in}
\begin{center}
\begin{tabular}{S@{}F@{}R@{}R@{}F@{}R@{}O}
\\
\instbitrange{31}{27} &
\instbitrange{26}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{funct5} &
\multicolumn{1}{c|}{fmt} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{rm} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
5 & 2 & 5 & 5 & 3 & 5 & 7 \\
FCLASS & S & 0 & src & 001 & dest & OP-FP  \\
\end{tabular}
\end{center}

\begin{table}[htp]
\begin{small}
\begin{center}
\begin{tabular}{|c|l|}
\hline
{\em rd} bit &
Meaning \\
\hline
0 & {\em rs1} is $-\infty$. \\
1 & {\em rs1} is a negative normal number. \\
2 & {\em rs1} is a negative subnormal number. \\
3 & {\em rs1} is $-0$. \\
4 & {\em rs1} is $+0$. \\
5 & {\em rs1} is a positive subnormal number. \\
6 & {\em rs1} is a positive normal number. \\
7 & {\em rs1} is $+\infty$. \\
8 & {\em rs1} is a signaling NaN. \\
9 & {\em rs1} is a quiet NaN. \\
\hline
\end{tabular}
\end{center}
\end{small}
\caption{Format of result of FCLASS instruction.}
\label{tab:fclass}
\end{table}
