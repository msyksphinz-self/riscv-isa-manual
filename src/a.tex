\begin{comment}
\chapter{``A'' Standard Extension for Atomic Instructions, Version 2.1}
\end{comment}
\chapter{アトミック命令のための``A'' 標準拡張, Version 2.1}
\label{atomics}

\begin{comment}
The standard atomic-instruction extension, named ``A'',
contains instructions that atomically
read-modify-write memory to support synchronization between multiple
RISC-V harts running in the same memory space.  The two forms of
atomic instruction provided are load-reserved/store-conditional
instructions and atomic fetch-and-op memory instructions.  Both types
of atomic instruction support various memory consistency orderings
including unordered, acquire, release, and sequentially consistent
semantics.  These instructions allow RISC-V to support the RCsc memory
consistency model~\cite{Gharachorloo90memoryconsistency}.
\end{comment}

``A''と名付けられた標準のアトミック命令拡張には、メモリの読み書きをアトミックに行う命令が含まれており、
同じメモリ空間で動作する複数のRISC-V hart間の同期をサポートしています。
アトミック命令には、Load-reserved/Store-conditional命令と、Atomic fetch-and-op命令の2種類があります。
両タイプのアトミック命令は、unordered、acquire、release, シーケンシャルコンシステンシ動作など、
さまざまなメモリ・コンシステンシの動作をサポートします。 これらの命令により、
RISC-VはRCscメモリコンシステンシモデル~\cite{Gharachorloo90memoryconsistency}をサポートしています。

\begin{commentary}
\begin{comment}
After much debate, the language community and architecture community
appear to have finally settled on release consistency as the standard
memory consistency model and so the RISC-V atomic support is built
around this model.
\end{comment}
多くの議論の末、言語コミュニティとアーキテクチャコミュニティは、
標準的なメモリコンシステンシモデルとしてリリースコンシステンシに最終的に落ち着いたようで、
RISC-Vのアトミックサポートはこのモデルを中心に構築されています。
\end{commentary}

\begin{comment}
\section{Specifying Ordering of Atomic Instructions}
\end{comment}
\section{アトミック命令のオーダリング指定}

\begin{comment}
The base RISC-V ISA has a relaxed memory model, with the FENCE
instruction used to impose additional ordering constraints.  The
address space is divided by the execution environment into memory and
I/O domains, and the FENCE instruction provides options to order
accesses to one or both of these two address domains.
\end{comment}

ベースとなるRISC-V ISAでは、リラックスメモリモデルが採用されており、
FENCE命令を使用して追加の順序制約が課せられています。
アドレス空間は実行環境によってメモリ領域とI/O領域に分けられ、
FENCE命令はこれら2つのアドレス領域の一方または両方へのアクセスを順序付けるオプションを提供します。

\begin{comment}
To provide more efficient support for release
consistency~\cite{Gharachorloo90memoryconsistency}, each atomic
instruction has two bits, {\em aq} and {\em rl}, used to specify
additional memory ordering constraints as viewed by other RISC-V
harts.  The bits order accesses to one of the two address domains,
memory or I/O, depending on which address domain the atomic
instruction is accessing.  No ordering constraint is implied to
accesses to the other domain, and a FENCE instruction should be used
to order across both domains.
\end{comment}

リリースコンシステンシ~\cite{Gharachorloo90memoryconsistency}をより効率的にサポートするために、
各アトミック命令には、他のRISC-V hartから見て追加のメモリ順序制約を指定するための2つのビット、{\em aq} and {\em rl}があります。
これらのビットは、アトミック命令がアクセスしているアドレス領域に応じて、
メモリまたはI/Oの2つのアドレスドメインのいずれかへのアクセスを順序付けます。
もう一方のドメインへのアクセスには順序付けの制約はなく、
両方のドメインに渡って順序付けを行うにはFENCE命令を使用する必要があります。

\begin{comment}
If both bits are clear, no additional ordering constraints are imposed
on the atomic memory operation.  If only the {\em aq} bit is set, the
atomic memory operation is treated as an {\em acquire} access, i.e.,
no following memory operations on this RISC-V hart can be observed
to take place before the acquire memory operation.  If only the {\em
  rl} bit is set, the atomic memory operation is treated as a {\em
  release} access, i.e., the release memory operation cannot be
observed to take place before any earlier memory operations on this
RISC-V hart.  If both the {\em aq} and {\em rl} bits are set, the
atomic memory operation is {\em sequentially consistent} and cannot be
observed to happen before any earlier memory operations or after any
later memory operations in the same RISC-V hart and to the same
address domain.
\end{comment}

両方のビットがクリアの場合、アトミックメモリ操作に追加の順序制約は課されません。
{\em aq}ビットのみがセットされている場合、アトミックメモリは{\em acquire}アクセスとして扱われます。
つまり、acquireアクセスの前に、このRISC-V hart上で次のメモリ操作が行われることはありません。
{\em rl}ビットのみがセットされている場合は、アトミックメモリ操作は、{\em release}アクセスとして扱われます。 
つまり、このRISC-V hartでは、先に行われたメモリ操作の前に、releaseメモリ操作が行われていることは観測できません。 
また、{\em aq}ビットと{\em rl}ビットの両方が設定されている場合、
アトミックなメモリ操作は{\em シーケンシャルコンシステンシ動作}であり、
同じRISC-V hart内の同じアドレスドメインに対して、
先に行われたメモリ操作の前や、後に行われたメモリ操作の後に起こることはありません。

\begin{comment}
\section{Load-Reserved/Store-Conditional Instructions}
\end{comment}
\section{Load-Reserved/Store-Conditional命令}
\label{sec:lrsc}

\vspace{-0.2in}
\begin{center}
\begin{tabular}{R@{}W@{}W@{}R@{}R@{}F@{}R@{}O}
\\
\instbitrange{31}{27} &
\instbit{26} &
\instbit{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{funct5} &
\multicolumn{1}{c|}{aq} &
\multicolumn{1}{c|}{rl} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
5 & 1 & 1 & 5 & 5 & 3 & 5 & 7 \\
LR.W/D & \multicolumn{2}{c}{ordering} & 0   & addr & width & dest & AMO    \\
SC.W/D & \multicolumn{2}{c}{ordering} & src & addr & width & dest & AMO  \\
\end{tabular}
\end{center}

\begin{comment}
Complex atomic memory operations on a single memory word or doubleword are performed
with the load-reserved (LR) and store-conditional (SC) instructions.
LR.W loads a word from the address in {\em rs1}, places the sign-extended
value in {\em rd}, and registers a {\em reservation set}---a set of bytes
that subsumes the bytes in the addressed word.
SC.W conditionally writes a word in {\em rs2} to the address in {\em rs1}: the
SC.W succeeds only if the reservation is still valid and the reservation set
contains the bytes being written.
If the SC.W succeeds, the instruction writes the word in {\em rs2} to memory,
and it writes zero to {\em rd}.
If the SC.W fails, the instruction does not write to memory, and it writes
a nonzero value to {\em rd}.
Regardless of success or failure, executing an SC.W instruction invalidates
any reservation held by this hart.
LR.D and SC.D act analogously on doublewords and are only available on RV64.
For RV64, LR.W and SC.W sign-extend the value placed in {\em rd}.
\end{comment}

Load Reserved(LR)命令とStore Conditional(SC)命令は、
1つのメモリ・ワードまたはダブルワードに対する複雑なアトミック・メモリ操作を行います。
LR.Wは、ワードを{\em rs1}のアドレスからロードし、符号拡張された値を{\em rd}に格納し、
アドレスされたワードのバイトを包含するバイトセットである{\em reservation set}を登録します。
SC.W は条件付きで、{\em rs2}のワードを{\em rs1}に含まれるアドレスに書き込みます。
SC.W が成功した場合、この命令はメモリ上に{\em rs2}のワードを書き込み、{\em rd} には0を書き込みます。
SC.Wが失敗した場合は、メモリへの書き込みは行われず、0以外の値が書き込まれます。
成功、失敗にかかわらず、SC.W命令を実行すると、このhartが持っていたreservationは無効になります。
LR.DとSC.Dはダブルワードに類似した動作をし、RV64でのみ使用可能です。
RV64では、LR.WとSC.Wは{\em rd}に置かれた値を符号拡張します。


\begin{commentary}
\begin{comment}
Both compare-and-swap (CAS) and LR/SC can be used to build lock-free
data structures.  After extensive discussion, we opted for LR/SC for
several reasons: 1) CAS suffers from the ABA problem, which LR/SC
avoids because it monitors all writes to the address rather than
only checking for changes in the data value; 2) CAS would also require
a new integer instruction format to support three source operands
(address, compare value, swap value) as well as a different memory
system message format, which would complicate microarchitectures; 3)
Furthermore, to avoid the ABA problem, other systems provide a
double-wide CAS (DW-CAS) to allow a counter to be tested and
incremented along with a data word. This requires reading five
registers and writing two in one instruction, and also a new larger
memory system message type, further complicating implementations; 4)
LR/SC provides a more efficient implementation of many primitives as
it only requires one load as opposed to two with CAS (one load before
the CAS instruction to obtain a value for speculative computation,
then a second load as part of the CAS instruction to check if value is
unchanged before updating).
\end{comment}

ロックフリーのデータ構造を構築するには、compare-and-swap(CAS)とLR/SCの両方を使用することができます。
議論の結果、いくつかの理由からLR/SCを採用しました。
1)CASにはABA問題があるが、LR/SCはデータ値の変更のみをチェックするのではなく、
アドレスへのすべての書き込みを監視するため、ABA問題を回避できる。
2)CASは、3つのソースオペランド(アドレス、比較値、スワップ値)をサポートするための新しい整数命令フォーマットと、
異なるメモリシステムメッセージフォーマットを必要とするため、マイクロアーキテクチャが複雑になる。
3) さらに、ABAの問題を回避するために、DW-CAS(Double-Wide CAS)を用意して、データワードと一緒にカウンタのテストやインクリメントを行うシステムもあります。
この場合、1つの命令で5つのレジスタを読み出し、2つのレジスタを書き込む必要があり、
また、新たに大きなメモリシステムのメッセージタイプが必要となるため、実装がさらに複雑になります。
4)LR/SCは、CASでは2回のロードが必要である(CAS命令の前に1回ロードして投機的計算のための値を取得し、
CAS命令の一部として2回目のロードを行い、値が変化していないかを確認してから更新する)
のに対し、1回のロードで済むため、多くのプリミティブをより効率的に実装することができます。

\begin{comment}
The main disadvantage of LR/SC over CAS is livelock, which we avoid,
under certain circumstances,
with an architected guarantee of eventual forward progress as
described below.  Another concern is whether the influence of the
current x86 architecture, with its DW-CAS, will complicate porting of
synchronization libraries and other software that assumes DW-CAS is
the basic machine primitive.  A possible mitigating factor is the
recent addition of transactional memory instructions to x86, which
might cause a move away from DW-CAS.
\end{comment}

LR/SCのCASに対する主な欠点はライブロックであるが、後述するように最終的な前進を保証するアーキテクチャにより、
特定の状況下ではライブロックを回避している。
また、DW-CASを持つx86アーキテクチャの影響により、
DW-CASを基本的なマシン・プリミティブとして想定している同期ライブラリ
などのソフトウェアの移植が困難になるのではないかという懸念もある。
しかし、最近x86にトランザクションメモリ命令が追加されたことで、
DW-CASからの脱却が進む可能性がある。

\begin{comment}
More generally, a multi-word atomic primitive is desirable, but there is
still considerable debate about what form this should take, and
guaranteeing forward progress adds complexity to a system.  Our
current thoughts are to include a small limited-capacity transactional
memory buffer along the lines of the original transactional memory
proposals as an optional standard extension ``T''.
\end{comment}

より一般的には、マルチワード・アトミック・プリミティブが望ましいとされていますが、
これがどのような形であるべきかについてはまだ大きな議論があり、
前進を保証することはシステムに複雑さをもたらします。
私たちの現在の考えは、オリジナルのトランザクション・メモリの提案に沿った小さな
限定容量のトランザクション・メモリ・バッファを、オプションの標準拡張機能``T''に含めることです。

\end{commentary}
\begin{comment}
The failure code with value 1 is reserved to encode an unspecified
failure.  Other failure codes are reserved at this time, and portable
software should only assume the failure code will be non-zero.
\end{comment}
値1の失敗コードは、不特定の失敗を表すために予約されています。
その他の失敗コードは現時点では予約済みであり、移植可能なソフトウェアは失敗コードが0以外であることのみを想定する必要があります。

\begin{commentary}
\begin{comment}
We reserve a failure code of 1 to mean ``unspecified'' so that simple
implementations may return this value using the existing mux required
for the SLT/SLTU instructions.  More specific failure codes might be
defined in future versions or extensions to the ISA.
\end{comment}
SLT/SLTU命令に必要な既存のmuxを使って、簡単な実装でこの値を返せるように、
失敗コードの1は「不特定多数」を意味するものとして確保しています。
より具体的な失敗コードは、ISAの将来のバージョンや拡張機能で定義されるかもしれません。
\end{commentary}

\begin{comment}
For LR and SC, the A extension requires that the address held in {\em
  rs1} be naturally aligned to the size of the operand (i.e.,
eight-byte aligned for 64-bit words and four-byte aligned for 32-bit
words).  If the address is not naturally aligned, an address-misaligned
exception or an access-fault exception will be generated.  The access-fault
exception can be generated for a memory access that would otherwise be
able to complete except for the misalignment, if the misaligned access
should not be emulated.
\end{comment}

LRとSCでは、A拡張機能を使用する際に、{\em rs1}に保持されるアドレスがオペランドのサイズに
自然にアラインされていることが必要です(64ビットワードでは8バイトアライン、32ビットワードでは4バイトアラインとなります)。
アドレスが自然にアラインされていない場合は、アドレスミスアライン例外またはアクセスフォルト例外が発生します。
アクセスフォルト例外は、ミスアラインアクセスがエミュレートされるべきでない場合、
ミスアライン発生時を除けば完了するはずのメモリ・アクセスに対して発生することができます。

\begin{commentary}
\begin{comment}
Emulating misaligned LR/SC sequences is impractical in most systems.
\end{comment}

ずれたLR/SCシーケンスをエミュレートすることは、ほとんどのシステムでは現実的ではありません。

\begin{comment}
Misaligned LR/SC sequences also raise the possibility of accessing multiple
reservation sets at once, which present definitions do not provide for.
\end{comment}

また、LR/SCの配列がずれていると、複数の予約セットに一度にアクセスする可能性が出てきますが、現在の定義ではこれを想定していません。
\end{commentary}

\begin{comment}
An implementation can register an arbitrarily large reservation set on each
LR, provided the reservation set includes all bytes of the addressed data word
or doubleword.
An SC can only pair with the most recent LR in program order.
An SC may succeed only if no store from another hart
to the reservation set can be observed to have occurred between the LR
and the SC, and if there is no other SC between the LR and itself in program
order.
An SC may succeed only if no write from a device other than a hart
to the bytes accessed by the LR instruction can be observed to have occurred
between the LR and SC.
Note this LR might have had a different effective address and data size, but
reserved the SC's address as part of the reservation set.
\end{comment}

実装では、データワードまたはダブルワードの全バイトを含む予約セットであれば、
各LRに任意の大きさの予約セットを登録することができます。
SCは、プログラム順に最新のLRとのみペアリングできます。
SCは、LRとSCの間に他のhartから予約セットへのストアが発生していないことが確認でき、
かつ、LRと自身の間にプログラム順に他のSCが存在しない場合にのみ成功します。
SCは、LRとSCの間に、LR命令でアクセスされたバイトへのhart以外のデバイスからの書き込みが
発生していないことが確認できた場合にのみ成功します。
なお、このLRは異なる実効アドレスとデータサイズを持っていたかもしれませんが、
予約セットの一部としてSCのアドレスを予約しています。

\begin{commentary}
\begin{comment}
Following this model, in systems with memory translation, an SC is allowed to
succeed if the earlier LR reserved the same location using an alias with
a different virtual address, but is also allowed to fail if the virtual
address is different.
\end{comment}
このモデルに従うと、メモリトランスレーションを備えたシステムでは、
先のLRが同じ場所を異なる仮想アドレスのエイリアスを使って予約していた場合にはSCは成功しますが、
仮想アドレスが異なる場合には失敗することもあります。
\end{commentary}
\begin{commentary}
\begin{comment}
To accommodate legacy devices and buses, writes from devices other than RISC-V
harts are only required to invalidate reservations when they overlap the bytes
accessed by the LR.  These writes are not required to invalidate the
reservation when they access other bytes in the reservation set.
\end{comment}
レガシーデバイスやバスに対応するため、RISC-V hart以外のデバイスからの書き込みは、
LRでアクセスするバイトと重なった場合にのみ予約を無効にする必要があります。
これらの書き込みは予約セットの他のバイトにアクセスされた場合には無効化する必要がありません。
\end{commentary}

\begin{comment}
The SC must fail if the address is not within the reservation set of the most
recent LR in program order.
The SC must fail if a store to the reservation set from another hart can be
observed to occur between the LR and SC.
The SC must fail if a write from some other device to the bytes accessed by
the LR can be observed to occur between the LR and SC.
(If such a device writes the reservation set but does not write the bytes
accessed by the LR, the SC may or may not fail.)
An SC must fail if there is another SC (to any address) between the LR and the
SC in program order.
The precise statement of the atomicity requirements for successful LR/SC
sequences is defined by the Atomicity Axiom in Section~\ref{sec:rvwmo}.
\end{comment}

SCは、アドレスがプログラム順に直近のLRの予約セット内にない場合、失敗しなければなりません。
LRとSCの間に、他のデバイスから予約セットへのストアが発生した場合、SCは失敗します。
LRとSCの間で、他のデバイスからLRがアクセスするバイトへの書き込みが発生した場合、
SCは失敗しなければなりません(このようなデバイスが予約セットを書き込んでも、
LRがアクセスしたバイトを書き込まない場合、SCは失敗してもしなくてもよい)。
プログラム順にLRとSCの間に別のSCが(任意のアドレスに)存在する場合、SCは失敗しなければならない。
LR/SCシーケンスを成功させるためのアトミック性要件の正確な記述は、
第~\ref{sec:rvwmo}節のアトミック性の原理によって定義されています。

\begin{commentary}
\begin{comment}
The platform should provide a means to determine the size and shape of the
reservation set.
\end{comment}
プラットフォームは、予約セットのサイズと形状を決定する手段を提供する必要があります。

\begin{comment}
A platform specification may constrain the size and shape of the reservation
set.
For example, the Unix platform is expected to require of main memory that the
reservation set be of fixed size, contiguous, naturally aligned, and no
greater than the virtual memory page size.
\end{comment}
プラットフォームの仕様は、予約セットのサイズと形状を制約することがあります。
たとえば、Unixプラットフォームでは、予約セットが固定サイズであること、
連続していること、自然に整列していること、
仮想メモリのページサイズ以下であることをメインメモリに要求すると考えられます。
\end{commentary}

\begin{commentary}
\begin{comment}
A store-conditional instruction to a scratch word of memory should be used
to forcibly invalidate any existing load reservation:
\begin{itemize}
\item during a preemptive context switch, and
\item if necessary when changing virtual to physical address mappings,
  such as when migrating pages that might contain an active reservation.
\end{itemize}
\end{comment}

既存のLoad Reservedを強制的に無効にするには、
メモリのスクラッチワードへのStore-Conditional命令を使用する必要があります:
\begin{itemize}
\item プリエンプティブなコンテキストスイッチの間
\item アクティブな予約を含む可能性のあるページを移行するときなど、
仮想アドレスと物理アドレスのマッピングを変更するときに必要な場合。
\end{itemize}
\end{commentary}

\begin{commentary}
\begin{comment}
The invalidation of a hart's reservation when it executes an LR or SC
imply that a hart can only hold one reservation at a time, and that
an SC can only pair with the most recent LR, and LR with the next
following SC, in program order.  This is a restriction to the
Atomicity Axiom in Section~\ref{sec:rvwmo} that ensures software runs
correctly on expected common implementations that operate in this manner.
\end{comment}
LRやSCを実行したときにhartの予約セットが無効になるということは、
hartは一度に1つの予約しか保持できず、SCは最新のLRと、LRはその次のSCと、
プログラム順にしかペアになれないことを意味します。
これは、第~\ref{sec:rvwmo}節のアトミック性の原理に対する制限であり、
この方法で動作する予想される一般的な実装上でソフトウェアが正しく動作することを保証するものです。
\end{commentary}

\begin{comment}
An SC instruction can never be observed by another RISC-V hart
before the LR instruction that established the reservation.
The LR/SC
sequence can be given acquire semantics by setting the {\em aq} bit on
the LR instruction.  The LR/SC sequence can be given release semantics
by setting the {\em rl} bit on the SC instruction.  Setting the {\em
  aq} bit on the LR instruction, and setting both the {\em aq} and the {\em
  rl} bit on the SC instruction makes the LR/SC sequence sequentially
consistent, meaning that it cannot be reordered with earlier or
later memory operations from the same hart.
\end{comment}

SC命令は、予約セットを確立したLR命令以前に、他のRISC-V hartによって観測されることはありません。
LR/SCシーケンスは、LR命令の{\em aq}ビットを設定することでアクイジションセマンティクスを与えることができる。
また、SC命令の{\em rl}ビットを設定することで、
LR/SCシーケンスにリリースセマンティクスを付与することができます。
LR命令に {\em aq}ビットを設定し、SC命令に{\em aq}ビットと{\em rl}ビットの両方を設定することで、
LR/SCシーケンスは順序的に一貫したものとなり、
同じhartからの前または後のメモリ操作で順序を変更することができなくなります。

\begin{comment}
If neither bit is set on both LR and SC, the LR/SC sequence can be
observed to occur before or after surrounding memory operations from
the same RISC-V hart.  This can be appropriate when the LR/SC
sequence is used to implement a parallel reduction operation.
\end{comment}

LRとSCの両方にどちらのビットも設定されていない場合、LR/SCシーケンスは、
同じRISC-V hart からの周辺のメモリ操作の前または後に発生することが観察できる。
これは、LR/SCシーケンスを使用して並列リダクション動作を実行する場合に適しています。

\begin{comment}
Software should not set the {\em rl} bit on an LR instruction unless the {\em
aq} bit is also set, nor should software set the {\em aq} bit on an SC
instruction unless the {\em rl} bit is also set.  LR.{\em rl} and SC.{\em aq}
instructions are not guaranteed to provide any stronger ordering than those
with both bits clear, but may result in lower performance.
\end{comment}

ソフトウェアは LR命令の{\em aq}ビットが設定されていない場合には LR 命令の{\em rl}ビットを設定してはいけません。
また、{\em rl}ビットがセットされていないSC命令の{\em aq}ビットを設定してはなりません。
LR.{\em rl}およびSC.{\em aq}命令は、
両ビットをクリアした場合よりも強力な順序付けを行うことは保証されていませんが、
結果として性能が低下する可能性があります。

\begin{figure}[h!]
\begin{center}
\begin{comment}
\begin{verbatim}
        # a0 holds address of memory location 
        # a1 holds expected value
        # a2 holds desired value
        # a0 holds return value, 0 if successful, !0 otherwise
    cas:
        lr.w t0, (a0)        # Load original value.
        bne t0, a1, fail     # Doesn't match, so fail.
        sc.w t0, a2, (a0)    # Try to update.
        bnez t0, cas         # Retry if store-conditional failed.
        li a0, 0             # Set return to success.
        jr ra                # Return.
    fail:
        li a0, 1             # Set return to failure.
        jr ra                # Return.
\end{verbatim}
\end{comment}
\begin{verbatim}
        # a0はメモリアドレスを保持している
        # a1は想定する値を持っている
        # a2はアップデートする値を持っている
        # もし成功したらa0は0、そうでなければ0以外を保持する
    cas:
        lr.w t0, (a0)        # オリジナルの値をロードする
        bne t0, a1, fail     # 一致しなければ失敗である
        sc.w t0, a2, (a0)    # アップデートを試行する
        bnez t0, cas         # Store-Conditionalが失敗した場合、再試行する
        li a0, 0             # 成功した場合には0を設定し終了する
        jr ra                # 戻る
    fail:
        li a0, 1             # 1を設定し失敗する
        jr ra                # 戻る
\end{verbatim}
\end{center}
\begin{comment}
\caption{Sample code for compare-and-swap function using LR/SC.}
\end{comment}
\caption{Compare-and-swap関数をLR/SCを使って実現するサンプルコード}
\label{cas}
\end{figure}

\begin{comment}
LR/SC can be used to construct lock-free data structures.  An example
using LR/SC to implement a compare-and-swap function is shown in
Figure~\ref{cas}.  If inlined, compare-and-swap functionality need
only take four instructions.
\end{comment}
LR/SCはロックフリーのデータ構造を構築するために使用することができます。 
LR/SCを使ってcompare-and-swap機能を実装した例を図~\ref{cas}に示します。
インライン化すれば、compare-and-swap機能は4命令で実現できます。

\begin{comment}
\section{Eventual Success of Store-Conditional Instructions}
\end{comment}
\section{Store-Conditional命令の成功にむけて}
\label{sec:lrscseq}

\begin{comment}
The standard A extension defines {\em constrained LR/SC loops}, which have
the following properties:
\vspace{-0.2in}
\begin{itemize}
\parskip 0pt
\itemsep 1pt
\item The loop comprises only an LR/SC sequence and code to retry the sequence
  in the case of failure, and must comprise at most 16 instructions placed
  sequentially in memory.
\item An LR/SC sequence begins with an LR instruction and ends with an SC
  instruction.  The dynamic code executed between the LR and SC instructions
  can only contain instructions from the base ``I'' instruction set, excluding
  loads, stores, backward jumps, taken backward branches, JALR, FENCE,
  and SYSTEM instructions.
  If the ``C'' extension is supported, then compressed
  forms of the aforementioned ``I'' instructions are also permitted.
\item The code to retry a failing LR/SC sequence can contain backwards jumps
  and/or branches to repeat the LR/SC sequence, but otherwise has the same
  constraint as the code between the LR and SC.
\item The LR and SC addresses must lie within a memory region with the
  {\em LR/SC eventuality} property.  The execution environment is responsible
  for communicating which regions have this property.
\item The SC must be to the same effective address and of the same data size as
  the latest LR executed by the same hart.
\end{itemize}
\end{comment}

標準A拡張では、次のような特性を持つ{\em 制限のあるLR/SCループ}を定義しています:
\vspace{-0.2in}
\begin{itemize}
\parskip 0pt
\itemsep 1pt
\item このループは、LR/SCシーケンスと、失敗した場合にシーケンスを再試行するコードのみで構成されており、
最大で16個の命令をメモリ上に順次配置する必要があります。
\item LR/SCシーケンスは、LR命令で始まり、SC命令で終わります。
LR命令とSC命令の間に実行される動的なコードには、基本となる``I''命令セットの命令のみを含めることができ、
ロード、ストア、バックワードジャンプ、逆方向への分岐、
JALR、FENCE、SYSTEMの各命令は含まれません。
``C''エクステンションがサポートされている場合には、前述の``I''命令の圧縮形式も許可されます。
\item 失敗したLR/SCシーケンスを再試行するコードは、
後方ジャンプやLR/SCシーケンスを繰り返すための分岐を含むことができますが、
それ以外はLRとSCの間のコードと同じ制約を持ちます。
\item LRおよびSCのアドレスは、{\em LR/SC eventuality} 特性を持つメモリ領域内になければならない。
どの領域がこの特性を持つかは、実行環境が責任を持って定義する。
\item SCは、同じhartで実行された最新のLRと同じ実効アドレス、同じデータサイズでなければならない。
\end{itemize}

\begin{comment}
LR/SC sequences that do not lie within constrained LR/SC loops are {\em
unconstrained}.  Unconstrained LR/SC sequences might succeed on some attempts
on some implementations, but might never succeed on other implementations.
\end{comment}

制約されたLR/SCループ内にないLR/SCシーケンスに{\em 制約はありません}。
制約のないLR/SC配列は、ある実装では成功するかもしれませんが、
他の実装では絶対に成功しないかもしれません。

\begin{commentary}
\begin{comment}
We restricted the length of LR/SC loops to fit within 64 contiguous
instruction bytes in the base ISA to avoid undue restrictions on instruction
cache and TLB size and associativity.
Similarly, we disallowed other loads and stores within the loops to avoid
restrictions on data-cache associativity in simple implementations that track
the reservation within a private cache.
The restrictions on branches and jumps limit the time that
can be spent in the sequence.  Floating-point operations and integer
multiply/divide were disallowed to simplify the operating system's emulation
of these instructions on implementations lacking appropriate hardware support.
\end{comment}

LR/SCのループの長さは、命令キャッシュやTLBのサイズや連想性に過度な制限がかからないように、
ベースISAの連続した64命令バイト以内に収まるように制限した。
同様に、プライベートキャッシュ内の予約を追跡するような単純な実装では、
データキャッシュの連想性への制約を避けるため、ループ内での他のロードやストアを禁止した。
分岐とジャンプの制限により、シーケンスに費やすことのできる時間が制限されます。
浮動小数点演算と整数の乗除算は、適切なハードウェア・サポートを持たない実装において、
オペレーティング・システムによるこれらの命令のエミュレーションを容易にするために禁止されています。

\begin{comment}
Software is not forbidden from using unconstrained LR/SC sequences, but
portable software must detect the case that the sequence repeatedly fails,
then fall back to an alternate code sequence that does not rely on an
unconstrained LR/SC sequence.  Implementations are permitted to
unconditionally fail any unconstrained LR/SC sequence.
\end{comment}

ソフトウェアが制約のないLR/SCシーケンスを使用することは禁止されていませんが、
ポータブルソフトウェアは、シーケンスが繰り返し失敗する場合を検出し、
制約のないLR/SCシーケンスに依存しない代替コードシーケンスにフォールバックしなければなりません。
実装は、制約のないLR/SCシーケンスを無条件に失敗させることができます。
\end{commentary}

\begin{comment}
If a hart {\em H} enters a constrained LR/SC loop, the execution environment
must guarantee that one of the following events eventually occurs:
\vspace{-0.2in}
\begin{itemize}
\parskip 0pt
\itemsep 1pt
\item {\em H} or some other hart executes a successful SC to the reservation
  set of the LR instruction in {\em H}'s constrained LR/SC loops.
\item Some other hart executes an unconditional store or AMO instruction to
  the reservation set of the LR instruction in {\em H}'s constrained LR/SC
  loop, or some other device in the system writes to that reservation set.
\item {\em H} executes a branch or jump that exits the constrained LR/SC loop.
\item {\em H} traps.
\end{itemize}
\end{comment}

Hart{\em H}が制約付きLR/SCループに入る場合、最終的に以下のいずれかの事象が発生することを実行環境が保証しなければならない:
\vspace{-0.2in}
\begin{itemize}
\parskip 0pt
\itemsep 1pt
\item Hまたは他のhartが、制約付きLR/SCループ内のLR命令の予約セットに対してSCを成功させる。
\item 他のhartが{\em H}の制約付きLR/SCループ内のLR命令の予約セットに対して無条件に
StoreやAMO命令を実行したり、システム内の他のデバイスがその予約セットに書き込みを行う。
\item {\em H} 制約されたLR/SCループを抜ける分岐やジャンプを実行する。
\item {\em H} がトラップを発生させる。
\end{itemize}

\begin{commentary}
\begin{comment}
Note that these definitions permit an implementation to fail an SC instruction
occasionally for any reason, provided the aforementioned guarantee is not
violated.
\end{comment}
これらの定義は、前述の保証に違反しない限り、
実装が何らかの理由でSC命令を時々失敗させることを許可していることに注意してください。
\end{commentary}

\begin{commentary}
\begin{comment}
As a consequence of the eventuality guarantee, if some harts in an execution
environment are executing constrained LR/SC loops, and no other harts or
devices in the execution environment execute an unconditional store or AMO to
that reservation set, then at least one hart will eventually exit its
constrained LR/SC loop.
By contrast, if other harts or devices continue to write to that reservation
set, it is not guaranteed that any hart will exit its LR/SC loop.
\end{comment}

このような保証(eventuality guarantee)の結果として、実行環境の一部のhartが制約付きLR/SCループを実行しており、
実行環境の他のhartやデバイスがその予約セットに対して無条件のストアやAMOを実行していない場合、
少なくとも1つのhartが最終的にその制約付きLR/SCループを抜けることになります。
これに対して、他のhartや機器がその予約セットへの書き込みを継続した場合、
どのhartもそのLR/SCループを抜けることは保証されません。

\begin{comment}
Loads and load-reserved instructions do not by themselves impede the progress
of other harts' LR/SC sequences.
We note this constraint implies, among other things, that loads and
load-reserved instructions executed by other harts (possibly within the same
core) cannot impede LR/SC progress indefinitely.
For example, cache evictions caused by another hart sharing the cache cannot
impede LR/SC progress indefinitely.
Typically, this implies reservations are tracked independently of
evictions from any shared cache.
Similarly, cache misses caused by speculative execution within a hart cannot
impede LR/SC progress indefinitely.
\end{comment}

ロードおよびLoad-Reserved命令は、それ自体が他のhartのLR/SCシーケンスの進行を妨げません。
この制約は、特に、他のhart(場合によっては同一コア内)が実行するロードおよびLoad-Reserved命令が
LR/SCの進行を無期限に妨げることができないことを意味することに注意してください。
例えば、キャッシュを共有している他のhartによって引き起こされるキャッシュの退避は、
LR/SCの進行を無制限に妨げることはできません。
一般的に、これは予約セットが共有キャッシュからの退避とは独立して追跡されることを意味します。
同様に、hart内での投機的な実行によるキャッシュミスも、LR/SCの進行を無期限に妨げることはできません。

\begin{comment}
These definitions admit the possibility that SC instructions may spuriously
fail for implementation reasons, provided progress is eventually made.
\end{comment}
これらの定義は、SC命令が実装上の理由で偽りの失敗をする可能性を認めていますが、最終的にはコードは前進します。
\end{commentary}

\begin{commentary}
\begin{comment}
One advantage of CAS is that it guarantees that some hart eventually
makes progress, whereas an LR/SC atomic sequence could livelock
indefinitely on some systems.  To avoid this concern, we added an
architectural guarantee of livelock freedom for certain LR/SC sequences.
\end{comment}

CASの利点の1つは、LR/SCのアトミックシーケンスがシステムによっては無期限に
ライブロックする可能性があるのに対し、あるhartが最終的に前進することを保証することです。
この懸念を回避するために、特定のLR/SCシーケンスに対してライブロックのないことをアーキテクチャ的に保証しました。

\begin{comment}
Earlier versions of this specification imposed a stronger starvation-freedom
guarantee.  However, the weaker livelock-freedom guarantee is sufficient to
implement the C11 and C++11 languages, and is substantially easier to provide
in some microarchitectural styles.
\end{comment}
この仕様の初期のバージョンでは、より強力なスターベイション・フリーダムの保証が課されていました。
しかし、C11およびC++11言語を実装するには、より弱いライブロック自由度の保証で十分であり、
マイクロアーキテクチャのスタイルによっては、より簡単に提供することができます。
\end{commentary}

\begin{comment}
\section{Atomic Memory Operations}
\end{comment}
\section{アトミックメモリ操作}
\label{sec:amo}

\vspace{-0.2in}
\begin{center}
\begin{tabular}{O@{}W@{}W@{}R@{}R@{}F@{}R@{}R}
\\
\instbitrange{31}{27} &
\instbit{26} &
\instbit{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{funct5} &
\multicolumn{1}{c|}{aq} &
\multicolumn{1}{c|}{rl} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
5 & 1 & 1 & 5 & 5 & 3 & 5 & 7 \\
AMOSWAP.W/D & \multicolumn{2}{c}{ordering} & src & addr & width & dest & AMO  \\
AMOADD.W/D & \multicolumn{2}{c}{ordering} & src & addr & width & dest & AMO  \\
AMOAND.W/D & \multicolumn{2}{c}{ordering} & src & addr & width & dest & AMO  \\
AMOOR.W/D & \multicolumn{2}{c}{ordering} & src & addr & width & dest & AMO  \\
AMOXOR.W/D & \multicolumn{2}{c}{ordering} & src & addr & width & dest & AMO  \\
AMOMAX[U].W/D & \multicolumn{2}{c}{ordering} & src & addr & width & dest & AMO  \\
AMOMIN[U].W/D & \multicolumn{2}{c}{ordering} & src & addr & width & dest & AMO  \\
\end{tabular}
\end{center}

\begin{comment}
\vspace{-0.1in} The atomic memory operation (AMO) instructions perform
read-modify-write operations for multiprocessor synchronization and
are encoded with an R-type instruction format.  These AMO instructions
atomically load a data value from the address in {\em rs1}, place the
value into register {\em rd}, apply a binary operator to the loaded
value and the original value in {\em rs2}, then store the result back
to the original address in {\em rs1}. AMOs can either operate on 64-bit (RV64
only) or 32-bit words in memory.  For RV64, 32-bit AMOs always
sign-extend the value placed in {\em rd}, and ignore the upper 32 bits
of the original value of {\em rs2}.
\end{comment}

AMO(Atomic Memory Operation)命令は、マルチプロセッサの同期をとるために、
リードモディファイ・ライトを行う命令で、Rタイプの命令フォーマットでエンコードされています。 
これらのAMO命令は、データの値をアドレスからアトミックにロードし、その値をレジスタに入れ、
ロードした値と元の値にバイナリ演算子を適用して、
その結果を元のアドレスにストアします。
AMOは、メモリ上の64ビット(RV64のみ)または32ビットのワードを操作することができます。
RV64の場合、32ビットのAMOは、常に{\em rd}に置かれた値を符号拡張し、{\em rs2}の元の値の上位32ビットを無視します。

\begin{comment}
For AMOs, the A extension requires that the address held in {\em rs1}
be naturally aligned to the size of the operand (i.e., eight-byte
aligned for 64-bit words and four-byte aligned for 32-bit words).  If
the address is not naturally aligned, an address-misaligned exception
or an access-fault exception will be generated.  The access-fault exception can be
generated for a memory access that would otherwise be able to complete
except for the misalignment, if the misaligned access should not be
emulated.  The ``Zam'' extension, described in Chapter~\ref{sec:zam},
relaxes this requirement and specifies the semantics of misaligned
AMOs.
\end{comment}

AMOの場合、Aエクステンションでは、{\em rs1}に保持されるアドレスがオペランドのサイズに
自然にアラインされていることが要求されます(64ビットワードでは8バイトアライン、32ビットワードでは4バイトアラインとなります)。
アドレスが自然にアラインされていない場合は、アドレスミスアライン例外またはアクセスフォルト例外が発生します。
アクセスフォルト例外は、ミスアラインアクセスがエミュレートされるべきではない場合に、
ミスアラインドを除けば完了するはずのメモリ・アクセスに対して発生することができます。
第~\ref{sec:zam}節に記載されている``Zam''拡張は、この要件を緩和し、
ミスアラインAMOのセマンティクスを規定しています。

\begin{comment}
The operations supported are swap, integer add, bitwise AND, bitwise
OR, bitwise XOR, and signed and unsigned integer maximum and minimum.
Without ordering constraints, these AMOs can be used to implement
parallel reduction operations, where typically the return value would
be discarded by writing to {\tt x0}.
\end{comment}

対応している演算は、スワップ、整数加算、ビット単位のAND、ビット単位のOR、ビット単位のXOR、
符号付きおよび符号なしの整数の最大値と最小値です。
これらのAMOは、順序の制約がなければ、並列の削減演算を実装するために使用することができます。
通常、戻り値は、{\tt x0}に書き込むことで破棄されます。

\begin{commentary}
\begin{comment}
We provided fetch-and-op style atomic primitives as they scale to
highly parallel systems better than LR/SC or CAS.
A simple microarchitecture can implement AMOs using the LR/SC primitives,
provided the implementation can guarantee the AMO eventually completes.
More complex implementations might also implement AMOs at memory
controllers, and can optimize away fetching the original value when
the destination is {\tt x0}.
\end{comment}
LR/SCやCASよりも高並列システムへの拡張性が高いfetch-and-opスタイルのアトミックプリミティブを提供しました。
単純なマイクロアーキテクチャでは、最終的にAMOが完了することを保証できる実装であれば、
LR/SCプリミティブを用いてAMOを実装することができます。
より複雑な実装では、メモリコントローラにもAMOを実装し、デスティネーションが{\tt x0}の場合に
元の値をフェッチしないように最適化することができます。

\begin{comment}
The set of AMOs was chosen to support the C11/C++11 atomic memory
operations efficiently, and also to support parallel reductions in
memory.  Another use of AMOs is to provide atomic updates to
memory-mapped device registers (e.g., setting, clearing, or toggling
bits) in the I/O space.
\end{comment}

AMOのセットは、C11/C++11のアトミックなメモリー操作を効率的にサポートし、さらにメモリーの並列削減をサポートするために選ばれました。
AMOのもう一つの用途は、I/O空間でメモリマップされたデバイスレジスターのアトミックな更新(ビットの設定、クリア、トグルなど)を行うことです。
\end{commentary}

\begin{comment}
To help implement multiprocessor synchronization, the AMOs optionally
provide release consistency semantics.  If the {\em aq} bit is set,
then no later memory operations in this RISC-V hart can be observed
to take place before the AMO.
Conversely, if the {\em rl} bit is set, then other
RISC-V harts will not observe the AMO before memory accesses
preceding the AMO in this RISC-V hart.  Setting both the {\em aq} and the {\em
rl} bit on an AMO makes the sequence sequentially consistent, meaning that
it cannot be reordered with earlier or later memory operations from the same
hart.
\end{comment}

マルチプロセッサの同期を実現するために、AMOはオプションでリリースコンシステンシセマンティクスを提供しています。 
{\em aq}ビットがセットされている場合、このRISC-V hartでは、AMOの前に行われた後のメモリ操作を観測することはできません。
逆に、{\em rl}ビットがセットされている場合、他のRISC-V hartは、このRISC-V hartにおける
AMOの前のメモリアクセスの前にAMOを観測することはありません。
AMOの{\em aq}と{\em rl}の両方のビットを設定すると、シーケンスが一貫したものになり、
同じhartからの前または後のメモリ操作で順序を変更することができなくなります。

\begin{commentary}
\begin{comment}
The AMOs were designed to implement the C11 and C++11 memory models
efficiently.  Although the FENCE R, RW instruction suffices to
implement the {\em acquire} operation and FENCE RW, W suffices to
implement {\em release}, both imply additional unnecessary ordering as
compared to AMOs with the corresponding {\em aq} or {\em rl} bit set.
\end{comment}

AMOはC11およびC++11のメモリモデルを効率的に実装するために設計されました。
FENCE R, RW命令は、{\em acquire}操作を実行するのに十分であり、
FENCE RW, W命令は {\em release}実行するのに十分ですが、{\em aq}や{\em rl}に
対応するビットが設定されているAMOと比較して、不要な順序付けが行われてしまいます。

\end{commentary}

\begin{comment}
An example code sequence for a critical section guarded by a
test-and-test-and-set spinlock is shown in Figure~\ref{critical}.  Note the
first AMO is marked {\em aq} to order the lock acquisition before the
critical section, and the second AMO is marked {\em rl} to order
the critical section before the lock relinquishment.
\end{comment}

テストアンドテストアンドセットのスピンロックでガードされたクリティカルセクションのコードシーケンスの例を 図~\ref{critical} に示します。
最初のAMOには、クリティカルセクションの前にロックの獲得を指示する{\em aq}が、2番目のAMOには、
ロックの放棄の前にクリティカルセクションを指示する{\em rl}が記されています。

\begin{comment}
\begin{figure}[h!]
\begin{center}
\begin{verbatim}
        li           t0, 1        # Initialize swap value.
    again:
        lw           t1, (a0)     # Check if lock is held.
        bnez         t1, again    # Retry if held.
        amoswap.w.aq t1, t0, (a0) # Attempt to acquire lock.
        bnez         t1, again    # Retry if held.
        # ...
        # Critical section.
        # ...
        amoswap.w.rl x0, x0, (a0) # Release lock by storing 0.
\end{verbatim}
\end{center}
\caption{Sample code for mutual exclusion.  {\tt a0} contains the address of the lock.}
\label{critical}
\end{figure}
\end{comment}

\begin{figure}[h!]
\begin{center}
\begin{verbatim}
        li           t0, 1        # スワップ値の初期化
    again:
        lw           t1, (a0)     # ロックを獲得しているかのチェック
        bnez         t1, again    # ロックをすでに誰かが獲得できていれば再試行
        amoswap.w.aq t1, t0, (a0) # ロックの取得試行
        bnez         t1, again    # ロックが獲得できなければ再試行
        # ...
        # クリティカルセクション
        # ...
        amoswap.w.rl x0, x0, (a0) # 0をストアすることでロック開放
\end{verbatim}
\end{center}
\caption{排他制御のサンプルコード。 {\tt a0}はロックのアドレスを保持している}
\label{critical}
\end{figure}

\begin{commentary}
\begin{comment}
We recommend the use of the AMO Swap idiom shown above for both lock
acquire and release to simplify the implementation of speculative lock
elision~\cite{Rajwar:2001:SLE}.
\end{comment}

投機的Lock Elision~\cite{Rajwar:2001:SLE}の実装を簡略化するために、
ロックの獲得と解放の両方に上記のAMO Swapイディオムを使用することをお勧めします。
\end{commentary}

\begin{comment}
The instructions in the ``A'' extension can also be used to provide
sequentially consistent loads and stores.  A sequentially consistent load can
be implemented as an LR with both {\em aq} and {\em rl} set. A sequentially
consistent store can be implemented as an AMOSWAP that writes the old value to
x0 and has both {\em aq} and {\em rl} set.
\end{comment}

``A''拡張の命令は、シーケンシャルコンシステンシのロードとストアを実現するためにも使用できます。
シーケンシャルコンシステンシのロードは、LRとして実装することができ、{\em aq}と{\em rl}の両方が設定されます。
シーケンシャルコンシステンシのストアは、古い値をx0に書き込むAMOSWAPとして実装することができ、
その際には、{\em aq}と{\em rl}の両方が設定されます。
