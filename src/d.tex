\begin{comment}
\chapter{``D'' Standard Extension for Double-Precision Floating-Point,
Version 2.2}
\end{comment}
\chapter{倍精度浮動小数点のための``D''拡張}

\begin{comment}
This chapter describes the standard double-precision floating-point
instruction-set extension, which is named ``D'' and adds
double-precision floating-point computational instructions compliant
with the IEEE 754-2008 arithmetic standard.  The D extension depends on
the base single-precision instruction subset F.
\end{comment}

本章では、標準倍精度浮動小数点演算命令セットの拡張機能について説明します。
拡張機能は、IEEE 754-2008算術標準に準拠した倍精度浮動小数点演算命令を追加するもので、``D''と名付けられています。 
D拡張は、ベースとなる単精度命令サブセットFに依存します。

\begin{comment}
\section{D Register State}
\end{comment}
\section{Dレジスタステート}

\begin{comment}
The D extension widens the 32 floating-point registers, {\tt f0}--{\tt
  f31}, to 64 bits (FLEN=64 in Figure~\ref{fprs}).  The {\tt f}
registers can now hold either 32-bit or 64-bit floating-point values
as described below in Section~\ref{nanboxing}.
\end{comment}

D拡張機能は、32本の浮動小数点レジスタ{\tt f0}--{\tt f31}を64ビットに拡張するものです(図~\ref{fprs}のFLEN=64)。 
{\tt f}レジスタは以下の~\ref{nanboxing}節で説明する方式に基づいて32ビットまたは64ビットの浮動小数点値を保持することができます。

\begin{commentary}
\begin{comment}
FLEN can be 32, 64, or 128 depending on which of the F, D, and Q
extensions are supported.  There can be up to four different
floating-point precisions supported, including H, F, D, and Q.
\end{comment}
FLENは、F、D、Qのどの拡張子がサポートされているかによって、32、64、128のいずれかになります。
また、H、F、D、Qなど、最大4種類の浮動小数点精度がサポートされています。
\end{commentary}

\begin{comment}
\section{NaN Boxing of Narrower Values}
\end{comment}
\section{小さな値のためのNan Boxing}
\label{nanboxing}

\begin{comment}
When multiple floating-point precisions are supported, then valid
values of narrower $n$-bit types, \mbox{$n<$ FLEN}, are represented in
the lower $n$ bits of an FLEN-bit NaN value, in a process termed
NaN-boxing.  The upper bits of a valid NaN-boxed value must be all 1s.
Valid NaN-boxed $n$-bit values therefore appear as negative quiet NaNs
(qNaNs) when viewed as any wider $m$-bit value, \mbox{$n < m \leq$
  FLEN}.  Any operation that writes a narrower result to an {\tt f}
register must write all 1s to the uppermost FLEN$-n$ bits to yield a
legal NaN-boxed value.
\end{comment}

複数の浮動小数点精度がサポートされている場合、より狭い$n$ビット・型の有効な値(\mbox{$n<$ FLEN})は、
NaN-boxingと呼ばれる処理により、FLENビットのNaN値の下位$n$ビットで表現されます。 
有効なNaNボックス化された値の上位ビットはすべて1でなければなりません。
そのため、NaNボックス化された$n$ビットの有効な値は、より広い$m$ビットの値として見ると、負のquiet NaN(qNaN)として表示されます。 
狭い範囲の結果をレジスタに書き込む操作では、最上位のFLEN$-n$ビットにすべて1を書き込まなければ、
正当なNaNボックス化された値にはなりません。

\begin{commentary}
\begin{comment}
Software might not know the current type of data stored in a
floating-point register but has to be able to save and restore the
register values, hence the result of using wider operations to
transfer narrower values has to be defined.  A common case is for
callee-saved registers, but a standard convention is also desirable for
features including varargs, user-level threading libraries, virtual
machine migration, and debugging.
\end{comment}
ソフトウェアは、浮動小数点レジスタに保存されているデータの現在の型を知らないかもしれませんが、
レジスタの値を保存および復元できなければなりません。
したがって、狭い値を転送するために広い範囲の操作を使用した結果を定義する必要があります。 
一般的なケースとしては、callee-savedレジスタが挙げられますが、varargs、ユーザ・レベルのスレッド・ライブラリ、
仮想マシン・マイグレーション、デバッグなどの機能についても、標準的な規約が望まれます。
\end{commentary}

\begin{comment}
Floating-point $n$-bit transfer operations move external values held
in IEEE standard formats into and out of the {\tt f} registers, and
comprise floating-point loads and stores (FL$n$/FS$n$) and
floating-point move instructions (FMV.$n$.X/FMV.X.$n$).  A narrower
$n$-bit transfer, \mbox{$n<$ FLEN}, into the {\tt f} registers will create a
valid NaN-boxed value.  A narrower $n$-bit transfer out of
the floating-point registers will transfer the lower $n$ bits of the
register ignoring the upper FLEN$-n$ bits.
\end{comment}

浮動小数点の$n$ビット転送は、IEEE規格のフォーマットで保持されている外部の値を{\tt f}レジスタに出し入れするもので、
浮動小数点ロード・ストア(FL$n$/FS$n$)や浮動小数点移動命令(FMV.$n$.X/FMV.X.$n$)などがあります。 
狭い範囲の$n$ビットを{\tt f}レジスタに転送すると、有効なNaNボックス化された値が生成されます。 
また、浮動小数点レジスタからの転送では、下位$n$ビットが転送され上位FLEN$-n$ビットを無視されます。

\begin{comment}
Apart from transfer operations described in the previous paragraph,
all other floating-point operations on narrower $n$-bit operations,
\mbox{$n<$ FLEN}, check if the input operands are correctly NaN-boxed,
i.e., all upper FLEN$-n$ bits are 1.  If so, the $n$ least-significant
bits of the input are used as the input value, otherwise the input
value is treated as an $n$-bit canonical NaN.
\end{comment}

前項の転送演算を除き、$n$ビットの狭義の浮動小数点演算である\mbox{$n<$ FLEN}では、
入力オペランドが正しくNaNボックス化されているかどうか、つまりFLEN$-n$の上位ビットがすべて1であるかどうかによってチェックされます。
そうであれば、入力の$n$ビットの最下位ビットが入力値として使用され、
そうでなければ、入力値は$n$ビットのCanonical NaNとして扱われます。

\begin{commentary}
\begin{comment}
Earlier versions of this document did not define the behavior of
feeding the results of narrower or wider operands into an operation,
except to require that wider saves and restores would preserve the
value of a narrower operand.  The new definition removes this
implementation-specific behavior, while still accommodating both
non-recoded and recoded implementations of the floating-point unit.
The new definition also helps catch software errors by propagating
NaNs if values are used incorrectly.
\end{comment}

このドキュメントの以前のバージョンでは、幅の狭いオペランドまたは幅の広いオペランドの結果を演算に入力する動作は定義されていませんでしたが、
幅の広い保存や復元では幅の狭いオペランドの値を保持することが求められていました。 
新しい定義では、このような実装固有の動作が削除されていますが、
浮動小数点演算ユニットの非コード化およびコード化された実装の両方に対応しています。
また、新しい定義では、値が間違って使用された場合にNaNを伝播させることで、
ソフトウェア・エラーを検出することができます。

\begin{comment}
Non-recoded implementations unpack and pack the operands to IEEE
standard format on the input and output of every floating-point
operation.  The NaN-boxing cost to a non-recoded implementation is
primarily in checking if the upper bits of a narrower operation
represent a legal NaN-boxed value, and in writing all 1s to the upper
bits of a result.
\end{comment}

再コード化を行わない実装では、すべての浮動小数点演算の入力および出力において、
オペランドをIEEE標準フォーマットにアンパックおよびパックします。 
再コード化しない実装におけるNaNボックス化のコストは、
主に、狭義の演算の上位ビットが合法的なNaNボックス化された値を表しているかどうかをチェックすることと、
結果の上位ビットにすべての1を書き込むことにあります。

\begin{comment}
Recoded implementations use a more convenient internal format to
represent floating-point values, with an added exponent bit to allow
all values to be held normalized.  The cost to the recoded
implementation is primarily the extra tagging needed to track the
internal types and sign bits, but this can be done without adding new
state bits by recoding NaNs internally in the exponent field.  Small
modifications are needed to the pipelines used to transfer values in
and out of the recoded format, but the datapath and latency costs are
minimal.  The recoding process has to handle shifting of input
subnormal values for wide operands in any case, and extracting the
NaN-boxed value is a similar process to normalization except for
skipping over leading-1 bits instead of skipping over leading-0 bits,
allowing the datapath muxing to be shared.
\end{comment}

再コード化された実装では、浮動小数点値を表現するために、
より便利な内部フォーマットを使用し、すべての値を正規化して保持できるように指数ビットを追加しています。 
再コード化された実装にかかるコストは、主に内部の型と符号ビットを追跡するために必要な追加のタグ付けですが、
これは指数フィールドでNaNを内部的に再コード化することで、新たなステートビットを追加することなく行うことができます。 
再コード化されたフォーマットとの間で値を転送するためのパイプラインに若干の変更が必要ですが、
データパスとレイテンシーのコストは最小限に抑えられます。 
また、NaNボックス化された値の抽出は、先頭の0ビットをスキップする代わりに先頭の1ビットをスキップすることを除けば、
正規化と同様のプロセスであり、データパスの多重化を共有することができます。
\end{commentary}

\section{Double-Precision Load and Store Instructions}
\label{fld_fsd}

The FLD instruction loads a double-precision floating-point value from
memory into floating-point register {\em rd}.  FSD stores a double-precision
value from the floating-point registers to memory.
\begin{commentary}
The double-precision value may be a NaN-boxed single-precision value.
\end{commentary}

\vspace{-0.2in}
\begin{center}
\begin{tabular}{M@{}R@{}F@{}R@{}O}
\\
\instbitrange{31}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{imm[11:0]} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{width} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
12 & 5 & 3 & 5 & 7 \\
offset[11:0] & base & D & dest & LOAD-FP \\
\end{tabular}
\end{center}

\vspace{-0.2in}
\begin{center}
\begin{tabular}{O@{}R@{}R@{}F@{}R@{}O}
\\
\instbitrange{31}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{imm[11:5]} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{width} &
\multicolumn{1}{c|}{imm[4:0]} &
\multicolumn{1}{c|}{opcode} \\
\hline
7 & 5 & 5 & 3 & 5 & 7 \\
offset[11:5] & src & base & D & offset[4:0] & STORE-FP \\
\end{tabular}
\end{center}

FLD and FSD are only guaranteed to execute atomically if the effective address
is naturally aligned and XLEN$\geq$64.

FLD and FSD do not modify the bits being transferred; in particular, the
payloads of non-canonical NaNs are preserved.

\section{Double-Precision Floating-Point Computational Instructions}

The double-precision floating-point computational instructions are
defined analogously to their single-precision counterparts, but operate on
double-precision operands and produce double-precision results.
\vspace{-0.2in}
\begin{center}
\begin{tabular}{R@{}F@{}R@{}R@{}F@{}R@{}O}
\\
\instbitrange{31}{27} &
\instbitrange{26}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{funct5} &
\multicolumn{1}{c|}{fmt} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{rm} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
5 & 2 & 5 & 5 & 3 & 5 & 7 \\
FADD/FSUB & D & src2 & src1 & RM  & dest & OP-FP  \\
FMUL/FDIV & D & src2 & src1 & RM  & dest & OP-FP  \\
FMIN-MAX  & D & src2 & src1 & MIN/MAX & dest & OP-FP  \\
FSQRT     & D & 0    & src  & RM  & dest & OP-FP  \\
\end{tabular}
\end{center}

\vspace{-0.2in}
\begin{center}
\begin{tabular}{R@{}F@{}R@{}R@{}F@{}R@{}O}
\\
\instbitrange{31}{27} &
\instbitrange{26}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{rs3} &
\multicolumn{1}{c|}{fmt} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{rm} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
5 & 2 & 5 & 5 & 3 & 5 & 7 \\
src3 & D & src2 & src1 & RM  & dest & F[N]MADD/F[N]MSUB  \\
\end{tabular}
\end{center}

\section{Double-Precision Floating-Point Conversion and Move Instructions}

Floating-point-to-integer and integer-to-floating-point conversion
instructions are encoded in the OP-FP major opcode space.
FCVT.W.D or FCVT.L.D converts a double-precision floating-point number
in floating-point register {\em rs1} to a signed 32-bit or 64-bit
integer, respectively, in integer register {\em rd}.  FCVT.D.W
or FCVT.D.L converts a 32-bit or 64-bit signed integer,
respectively, in integer register {\em rs1} into a
double-precision floating-point
number in floating-point register {\em rd}. FCVT.WU.D,
FCVT.LU.D, FCVT.D.WU, and FCVT.D.LU variants
convert to or from unsigned integer values.
For RV64, FCVT.W[U].D sign-extends the 32-bit result.
FCVT.L[U].D and FCVT.D.L[U] are RV64-only instructions.
The range of valid inputs for FCVT.{\em int}.D and
the behavior for invalid inputs are the same as for FCVT.{\em int}.S.

All floating-point to integer and integer to floating-point conversion
instructions round according to the {\em rm} field.  Note FCVT.D.W[U] always
produces an exact result and is unaffected by rounding mode.

\vspace{-0.2in}
\begin{center}
\begin{tabular}{R@{}F@{}R@{}R@{}F@{}R@{}O}
\\
\instbitrange{31}{27} &
\instbitrange{26}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{funct5} &
\multicolumn{1}{c|}{fmt} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{rm} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
5 & 2 & 5 & 5 & 3 & 5 & 7 \\
FCVT.{\em int}.D & D & W[U]/L[U] & src & RM  & dest & OP-FP  \\
FCVT.D.{\em int} & D & W[U]/L[U] & src & RM  & dest & OP-FP  \\
\end{tabular}
\end{center}

The double-precision to single-precision and single-precision to
double-precision conversion instructions, FCVT.S.D and FCVT.D.S, are
encoded in the OP-FP major opcode space and both the source and
destination are floating-point registers.  The {\em rs2} field
encodes the datatype of the source, and the {\em fmt} field encodes
the datatype of the destination.  FCVT.S.D rounds according to the
RM field; FCVT.D.S will never round.

\vspace{-0.2in}
\begin{center}
\begin{tabular}{R@{}F@{}R@{}R@{}F@{}R@{}O}
\\
\instbitrange{31}{27} &
\instbitrange{26}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{funct5} &
\multicolumn{1}{c|}{fmt} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{rm} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
5 & 2 & 5 & 5 & 3 & 5 & 7 \\
FCVT.S.D & S & D & src & RM  & dest & OP-FP  \\
FCVT.D.S & D & S & src & RM  & dest & OP-FP  \\
\end{tabular}
\end{center}

Floating-point to floating-point sign-injection instructions, FSGNJ.D,
FSGNJN.D, and FSGNJX.D are defined analogously to the single-precision
sign-injection instruction.

\vspace{-0.2in}
\begin{center}
\begin{tabular}{R@{}F@{}R@{}R@{}F@{}R@{}O}
\\
\instbitrange{31}{27} &
\instbitrange{26}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{funct5} &
\multicolumn{1}{c|}{fmt} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{rm} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
5 & 2 & 5 & 5 & 3 & 5 & 7 \\
FSGNJ & D & src2 & src1 & J[N]/JX & dest & OP-FP  \\
\end{tabular}
\end{center}

For XLEN$\geq$64 only, instructions are provided to move bit patterns
between the floating-point and integer registers.  FMV.X.D moves the
double-precision value in floating-point register {\em rs1} to a
representation in IEEE 754-2008 standard encoding in integer register
{\em rd}.  FMV.D.X moves the double-precision value encoded in IEEE
754-2008 standard encoding from the integer register {\em rs1} to the
floating-point register {\em rd}.

FMV.X.D and FMV.D.X do not modify the bits being transferred; in particular, the
payloads of non-canonical NaNs are preserved.

\vspace{-0.2in}
\begin{center}
\begin{tabular}{R@{}F@{}R@{}R@{}F@{}R@{}O}
\\
\instbitrange{31}{27} &
\instbitrange{26}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{funct5} &
\multicolumn{1}{c|}{fmt} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{rm} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
5 & 2 & 5 & 5 & 3 & 5 & 7 \\
FMV.X.D & D & 0    & src  & 000  & dest & OP-FP  \\
FMV.D.X & D & 0    & src  & 000  & dest & OP-FP  \\
\end{tabular}
\end{center}

\begin{commentary}
  Early versions of the RISC-V ISA had additional instructions to
  allow RV32 systems to transfer between the upper and lower portions
  of a 64-bit floating-point register and an integer register.
  However, these would be the only instructions with partial register
  writes and would add complexity in implementations with recoded
  floating-point or register renaming, requiring a pipeline read-modify-write
  sequence.  Scaling up to handling quad-precision for RV32 and RV64
  would also require additional instructions if they were to follow
  this pattern.  The ISA was defined to reduce the number of explicit
  int-float register moves, by having conversions and comparisons
  write results to the appropriate register file, so we expect the
  benefit of these instructions to be lower than for other ISAs.

  We note that for systems that implement a 64-bit floating-point unit
  including fused multiply-add support and 64-bit floating-point loads
  and stores, the marginal hardware cost of moving from a 32-bit to
  a 64-bit integer datapath is low, and a software ABI supporting 32-bit
  wide address-space and pointers can be used to avoid growth of
  static data and dynamic memory traffic.
\end{commentary}

\section{Double-Precision Floating-Point Compare Instructions}

The double-precision floating-point compare instructions are
defined analogously to their single-precision counterparts, but operate on
double-precision operands.

\vspace{-0.2in}
\begin{center}
\begin{tabular}{S@{}F@{}R@{}R@{}F@{}R@{}O}
\\
\instbitrange{31}{27} &
\instbitrange{26}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{funct5} &
\multicolumn{1}{c|}{fmt} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{rm} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
5 & 2 & 5 & 5 & 3 & 5 & 7 \\
FCMP & D & src2 & src1 & EQ/LT/LE & dest & OP-FP  \\
\end{tabular}
\end{center}

\section{Double-Precision Floating-Point Classify Instruction}

The double-precision floating-point classify instruction, FCLASS.D, is
defined analogously to its single-precision counterpart, but operates on
double-precision operands.

\vspace{-0.2in}
\begin{center}
\begin{tabular}{S@{}F@{}R@{}R@{}F@{}R@{}O}
\\
\instbitrange{31}{27} &
\instbitrange{26}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{funct5} &
\multicolumn{1}{c|}{fmt} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{rm} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
5 & 2 & 5 & 5 & 3 & 5 & 7 \\
FCLASS & D & 0 & src & 001 & dest & OP-FP  \\
\end{tabular}
\end{center}
