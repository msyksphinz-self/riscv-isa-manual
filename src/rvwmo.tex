\begin{comment}
\chapter{RVWMO Memory Consistency Model, Version 2.0}
\end{comment}
\chapter{RVWMOメモリコンシステンシモデル、Version 2.0}
\label{ch:memorymodel}

\begin{comment}
This chapter defines the RISC-V memory consistency model.
A memory consistency model is a set of rules specifying the values that can be returned by loads of memory.
RISC-V uses a memory model called ``RVWMO'' (RISC-V Weak Memory Ordering) which is designed to provide flexibility for architects to build high-performance scalable designs while simultaneously supporting a tractable programming model.
\end{comment}

この章では、RISC-Vのメモリコンシステンシモデルを定義します。
メモリコンシステンシモデルとは、メモリのロードによって返される値を指定する一連のルールのことです。
RISC-Vでは、RVWMO(RISC-V Weak Memory Ordering)と呼ばれるメモリモデルを採用しています。
このモデルは、アーキテクトが高性能でスケーラブルなデザインを構築するための柔軟性を提供すると同時に、
扱いやすいプログラミングモデルをサポートするように設計されています。

\begin{comment}
Under RVWMO, code running on a single hart appears to execute in order from the perspective of other memory instructions in the same hart, but memory instructions from another hart may observe the memory instructions from the first hart being executed in a different order.
Therefore, multithreaded code may require explicit synchronization to guarantee ordering between memory instructions from different harts.
The base RISC-V ISA provides a FENCE instruction for this purpose, described in Section~\ref{sec:fence}, while the atomics extension ``A'' additionally defines load-reserved/store-conditional and atomic read-modify-write instructions.
\end{comment}

RVWMOでは、1つのhartで実行されているコードは、同じhartの他のメモリ命令から見ると順番通りに実行されているように見えますが、
別のhartのメモリ命令から見ると、最初のhartのメモリ命令が異なる順番で実行されているように見えることがあります。
そのため、マルチスレッドのコードでは、異なるhartのメモリ命令間の順序を保証するために、
明示的な同期が必要になる場合があります。
ベースとなるRISC-V ISAでは、この目的のために、第~\ref{sec:fence}で説明されているFENCE命令が用意されています。
また、アトミック拡張 ``A''では、ロード・リザーブ／ストア・コンディショナルおよび
アトミック・リード・モディファイ・ライト命令が追加で定義されています。

\begin{comment}
The standard ISA extension for misaligned atomics ``Zam'' (Chapter~\ref{sec:zam}) and the standard ISA extension for total store ordering ``Ztso'' (Chapter~\ref{sec:ztso}) augment RVWMO with additional rules specific to those extensions.
\end{comment}

ミスアラインのアトミック操作のための標準ISA拡張機能``Zam'' (第~\ref{sec:zam}章)と
total store orderingのための標準ISA拡張機能``Ztso'' (第~\ref{sec:ztso}章)は、
RVWMOにそれらの拡張機能に固有の追加ルールを加えたものです。

\begin{comment}
The appendices to this specification provide both axiomatic and operational formalizations of the memory consistency model as well as additional explanatory material.
\end{comment}

本仕様書の付録には、メモリコンシステンシモデルの公理的および運用的な公式化と、追加の説明資料が含まれています。

\begin{commentary}
\begin{comment}
  This chapter defines the memory model for regular main memory operations.  The interaction of the memory model with I/O memory, instruction fetches, FENCE.I, page table walks, and SFENCE.VMA is not (yet) formalized.  Some or all of the above may be formalized in a future revision of this specification.  The RV128 base ISA and future ISA extensions such as the ``V'' vector, ``T'' transactional memory, and ``J'' JIT extensions will need to be incorporated into a future revision as well.
\end{comment}
  この章では、通常のメインメモリ操作のためのメモリモデルを定義します。 
メモリモデルとI/Oメモリ、命令フェッチ、FENCE.I、ページテーブルウォーク、SFENCE.VMAとの相互作用は(まだ)公式化されていません。 
この仕様の将来の改訂では、上記の一部またはすべてが正式に定義されるかもしれません。 
RV128の基本ISAと、将来のISA拡張である``V''ベクトル、``T''トランザクションメモリ、``J''JIT拡張を組み込む必要があります。
JITエクステンションなど、将来のISA拡張機能についても、将来の改訂版に盛り込む必要があります。

\begin{comment}
  Memory consistency models supporting overlapping memory accesses of different widths simultaneously remain an active area of academic research and are not yet fully understood.  The specifics of how memory accesses of different sizes interact under RVWMO are specified to the best of our current abilities, but they are subject to revision should new issues be uncovered.
\end{comment}
  異なる幅のメモリアクセスが同時にオーバーラップすることをサポートするメモリコンシステンシモデルは、
学術的にも活発な研究分野であり、まだ完全には解明されていません。 
ここでは、RVWMOの下で異なるサイズのメモリアクセスがどのように相互作用するかについて、
現時点で可能な限り具体的に説明していますが、
新たな問題が明らかになった場合には修正することがあります。
\end{commentary}

\begin{comment}
\section{Definition of the RVWMO Memory Model}
\end{comment}
\section{RVWMOメモリモデルの定義}
\label{sec:rvwmo}

\begin{comment}
The RVWMO memory model is defined in terms of the {\em global memory order}, a total ordering of the memory operations produced by all harts.
In general, a multithreaded program has many different possible executions, with each execution having its own corresponding global memory order.
\end{comment}

RVWMOのメモリモデルは、すべてのhartが行うメモリ操作の総合的な順序である
{\em RVWMOグローバルメモリ順序}で定義されます。
一般的に、マルチスレッドのプログラムにはさまざまな実行方法があり、
各実行方法にはそれぞれ対応するグローバルメモリオーダーがあります。


\begin{comment}
The global memory order is defined over the primitive load and store operations generated by memory instructions.
It is then subject to the constraints defined in the rest of this chapter.
Any execution satisfying all of the memory model constraints is a legal execution (as far as the memory model is concerned).
\end{comment}

グローバルメモリ順序は、メモリ命令によって生成されたプリミティブなロードとストアの操作に対して定義されます。
そして、この章の残りの部分で定義された制約を受けます。
メモリモデルの制約条件をすべて満たす実行は(メモリモデルに関する限り)合法的な実行です。


\begin{comment}
\subsection*{Memory Model Primitives}
\end{comment}
\subsection*{メモリモデルのプリミティブ}

\label{sec:rvwmo:primitives}
\begin{comment}
The {\em program order} over memory operations reflects the order in which the instructions that generate each load and store are logically laid out in that hart's dynamic instruction stream; i.e., the order in which a simple in-order processor would execute the instructions of that hart.
\end{comment}

メモリ操作における{\em プログラム順序}は、ロードやストアを生成する命令が、
そのhartのダイナミックな命令ストリームの中で論理的にレイアウトされた順序を反映しています。
つまり、単純なインオーダプロセッサが、そのhartの命令を実行する順序です。

\begin{comment}
Memory-accessing instructions give rise to {\em memory operations}.
A memory operation can be either a {\em load operation}, a {\em store operation}, or both simultaneously.
All memory operations are single-copy atomic: they can never be observed in a partially-complete state.
\end{comment}

メモリにアクセスするための命令は{\em メモリ操作}を発生させます。
メモリ操作は、{\em ロード操作}、{\em ストア操作}のいずれか、または両方を同時に行うことができます。
すべてのメモリ操作はシングルコピーアトミックであり、部分的に完了した状態では決して観測されません。

\begin{comment}
Among instructions in RV32GC and RV64GC, each aligned memory instruction gives rise to exactly one memory operation, with two exceptions.
First, an unsuccessful SC instruction does not give rise to any memory operations.
Second, FLD and FSD instructions may each give rise to multiple memory operations if XLEN$<$64, as stated in Section~\ref{fld_fsd} and clarified below.
An aligned AMO gives rise to a single memory operation that is both a load operation and a store operation simultaneously.
\end{comment}

RV32GCとRV64GCの命令のうち、各アラインドメモリ命令は、2つの例外を除いて、正確に1つのメモリ操作を生じさせます。
最初の例外は、SC命令が失敗した場合、メモリ操作は発生しません。
次の例外は、FLD命令とFSD命令に関して~\ref{fld_fsd}節で言及し、
以下で明示的に定義するように、XLEN$<$64の場合、複数のメモリ操作が発生します。
アラインドAMOは、ロードとストアの両方を同時に行う単一のメモリ操作を行います。

\begin{commentary}
\begin{comment}
  Instructions in the RV128 base instruction set and in future ISA extensions such as V (vector) and P (SIMD) may give rise to multiple memory operations.  However, the memory model for these extensions has not yet been formalized.
\end{comment}
  RV128の基本命令セットに含まれる命令や、V(ベクトル)やP(SIMD)といった将来のISA拡張に含まれる命令は、
複数のメモリ操作を引き起こす可能性があります。 
しかし、これらの拡張のためのメモリモデルはまだ正式なものではありません。
\end{commentary}

\begin{comment}
A misaligned load or store instruction may be decomposed into a set of component memory operations of any granularity.
An FLD or FSD instruction for which XLEN$<$64 may also be decomposed into a set of component memory operations of any granularity.
The memory operations generated by such instructions are not ordered with respect to each other in program order, but they are ordered normally with respect to the memory operations generated by preceding and subsequent instructions in program order.
The atomics extension ``A'' does not require execution environments to support misaligned atomic instructions at all; however, if misaligned atomics are supported via the ``Zam'' extension, LRs, SCs, and AMOs may be decomposed subject to the constraints of the atomicity axiom for misaligned atomics, which is defined in Chapter~\ref{sec:zam}.
\end{comment}

ミスアラインのロード/ストア命令は、任意の粒度のコンポーネントメモリ操作の集合に分解することができます。
また、XLEN$<$64のFLDまたはFSD命令も、任意の粒度のコンポーネントメモリ操作の集合に分解することができます。
このような命令で生成されたメモリ操作は、プログラム順には互いに並びませんが、
プログラム順に前後の命令で生成されたメモリ操作に対しては正常に並びます。
アトミック拡張``A''は、実行環境がミスアラインアトミック命令をサポートすることを全く必要としません。
しかし``Zam''拡張によってミスアラインアトミックがサポートされている場合には、
第~\ref{sec:zam}章で定義されているミスアラインアトミックのためのアトミック性公理の制約を受けて、
LR、SC、AMOを分解することができます。

\begin{commentary}
\begin{comment}
  The decomposition of misaligned memory operations down to byte granularity facilitates emulation on implementations that do not natively support misaligned accesses.
  Such implementations might, for example, simply iterate over the bytes of a misaligned access one by one.
\end{comment}
  ミスアラインメモリ操作をバイト単位に分解することで、
ミスアラインアクセスをネイティブにサポートしていない実装でのエミュレーションが容易になります。
  このような実装では、例えば、ミスアラインアクセスのバイトを1つずつ繰り返し処理することになります。
\end{commentary}

\begin{comment}
An LR instruction and an SC instruction are said to be {\em paired} if the LR precedes the SC in program order and if there are no other LR or SC instructions in between; the corresponding memory operations are said to be paired as well (except in case of a failed SC, where no store operation is generated).
The complete list of conditions determining whether an SC must succeed, may succeed, or must fail is defined in Section~\ref{sec:lrsc}.
\end{comment}
LR命令とSC命令は、プログラム順にLRがSCに先行し、
その間に他のLR命令やSC命令が存在しない場合、{\em ペアになっている}といいます。
SCが成功するかどうか、成功する可能性があるかどうか、
失敗する可能性があるかどうかの条件は、第~\ref{sec:lrsc}節で定義されています。

\begin{comment}
Load and store operations may also carry one or more ordering annotations from the following set: ``acquire-RCpc'', ``acquire-RCsc'', ``release-RCpc'', and ``release-RCsc''.
An AMO or LR instruction with {\em aq} set has an ``acquire-RCsc'' annotation.
An AMO or SC instruction with {\em rl} set has a ``release-RCsc'' annotation.
An AMO, LR, or SC instruction with both {\em aq} and {\em rl} set has both ``acquire-RCsc'' and ``release-RCsc'' annotations.
\end{comment}

ロードとストア操作には、次のような順序付けのアノテーションを付けることができます: ``acquire-RCpc''、``acquire-RCsc''、``release-RCpc''、``release-RCsc''。
AMOまたはLR命令で{\em aq}が指定されているものは、``acquire-RCsc''のアノテーションが付いています。
AMOまたはLR命令で{\em rl}が指定されているものは、``release-RCsc''のアノテーションが付いています。
AMO,LR,SC命令で、両方の指定を持つものは、``acquire-RCsc''と``release-RCsc''の両方のアノテーションを持ちます。

\begin{comment}
For convenience, we use the term ``acquire annotation'' to refer to an acquire-RCpc annotation or an acquire-RCsc annotation.
Likewise, a ``release annotation'' refers to a release-RCpc annotation or a release-RCsc annotation.
An ``RCpc annotation'' refers to an acquire-RCpc annotation or a release-RCpc annotation.
An ``RCsc annotation'' refers to an acquire-RCsc annotation or a release-RCsc annotation.
\end{comment}

便宜上、``アクワイヤアノテーション''という用語を、acquire-RCpcアノテーションまたはacquire-RCscアノテーションを指すために使用します。
同様に、``リリースアノテーション''とは、release-RCpcアノテーションまたはrelease-RCscアノテーションを指します。
また、``RCpcアノテーション''とは、``acquire-RCpc''アノテーションまたは``release-RCpc''アノテーションを指します。
``RCscアノテーション''とは、acquire-RCscアノテーションまたはrelease-RCscアノテーションを指します。

\begin{commentary}
\begin{comment}
  In the memory model literature, the term ``RCpc'' stands for release consistency with processor-consistent synchronization operations, and the term ``RCsc'' stands for release consistency with sequentially-consistent synchronization operations~\cite{Gharachorloo90memoryconsistency}.
\end{comment}
  メモリモデルの文献では、``RCpc''という用語は、
プロセッサ整合性のある同期操作とのリリースコンシステンシを表し、
``RCsc''という用語は、シーケンシャルコンシステンシのある同期操作とのリリースコンシステンシを表しています~\cite{Gharachorloo90memoryconsistency}。

\begin{comment}
  While there are many different definitions for acquire and release annotations in the literature, in the context of RVWMO these terms are concisely and completely defined by Preserved Program Order rules \ref{ppo:acquire}--\ref{ppo:rcsc}.
\end{comment}
  アクワイヤとリリースのアノテーションについては、様々な定義がありますが、RVWMOのコンテキストでは、
Preserved Program Order rules\ref{ppo:acquire}--\ref{ppo:rcsc}によって簡潔かつ完全に定義されています。

\begin{comment}
  ``RCpc'' annotations are currently only used when implicitly assigned to every memory access per the standard extension ``Ztso'' (Chapter~\ref{sec:ztso}).  Furthermore, although the ISA does not currently contain native load-acquire or store-release instructions, nor RCpc variants thereof, the RVWMO model itself is designed to be forwards-compatible with the potential addition of any or all of the above into the ISA in a future extension.
\end{comment}
  現在、``RCpc''アノテーションは、標準的な拡張機能である''Ztso''(第~\ref{sec:ztso})により、
すべてのメモリアクセスに暗黙的に割り当てられた場合にのみ使用されます。 
さらに、ISAには現在、ネイティブのロード・アクワイア命令やストア・リリース命令、
およびそれらのRCpcバリエーションは含まれていませんが、
RVWMOモデル自体は、将来の拡張でISAに上記のいずれかまたはすべての命令が追加される可能性があることを考慮して、
前方互換性があるように設計されています。
\end{commentary}

\subsection*{Syntactic Dependencies}
\label{sec:memorymodel:dependencies}
The definition of the RVWMO memory model depends in part on the notion of a syntactic dependency, defined as follows.

In the context of defining dependencies, a ``register'' refers either to an entire general-purpose register, some portion of a CSR, or an entire CSR.  The granularity at which dependencies are tracked through CSRs is specific to each CSR and is defined in Section~\ref{sec:csr-granularity}.

Syntactic dependencies are defined in terms of instructions' {\em source registers}, instructions' {\em destination registers}, and the way instructions {\em carry a dependency} from their source registers to their destination registers.
This section provides a general definition of all of these terms; however, Section~\ref{sec:source-dest-regs} provides a complete listing of the specifics for each instruction.

In general, a register $r$ other than {\tt x0} is a {\em source register} for an instruction $i$ if any of the following hold:
\begin{itemize}
  \item In the opcode of $i$, {\em rs1}, {\em rs2}, or {\em rs3} is set to $r$
  \item $i$ is a CSR instruction, and in the opcode of $i$, {\em csr} is set to $r$, unless $i$ is CSRRW or CSRRWI and {\em rd} is set to {\tt x0}
  \item $r$ is a CSR and an implicit source register for $i$, as defined in Section~\ref{sec:source-dest-regs}
  \item $r$ is a CSR that aliases with another source register for $i$
\end{itemize}
Memory instructions also further specify which source registers are {\em address source registers} and which are {\em data source registers}.

In general, a register $r$ other than {\tt x0} is a {\em destination register} for an instruction $i$ if any of the following hold:
\begin{itemize}
  \item In the opcode of $i$, {\em rd} is set to $r$
  \item $i$ is a CSR instruction, and in the opcode of $i$, {\em csr} is set to $r$, unless $i$ is CSRRS or CSRRC and {\em rs1} is set to {\tt x0} or $i$ is CSRRSI or CSRRCI and uimm[4:0] is set to zero.
  \item $r$ is a CSR and an implicit destination register for $i$, as defined in Section~\ref{sec:source-dest-regs}
  \item $r$ is a CSR that aliases with another destination register for $i$
\end{itemize}

Most non-memory instructions {\em carry a dependency} from each of their source registers to each of their destination registers.
However, there are exceptions to this rule; see Section~\ref{sec:source-dest-regs}

Instruction $j$ has a {\em syntactic dependency} on instruction $i$ via destination register $s$ of $i$ and source register $r$ of $j$ if either of the following hold:
\begin{itemize}
  \item $s$ is the same as $r$, and no instruction program-ordered between $i$ and $j$ has $r$ as a destination register
  \item There is an instruction $m$ program-ordered between $i$ and $j$ such that all of the following hold:
    \begin{enumerate}
      \item $j$ has a syntactic dependency on $m$ via destination register $q$ and source register $r$
      \item $m$ has a syntactic dependency on $i$ via destination register $s$ and source register $p$
      \item $m$ carries a dependency from $p$ to $q$
    \end{enumerate}
\end{itemize}

Finally, in the definitions that follow, let $a$ and $b$ be two memory operations, and let $i$ and $j$ be the instructions that generate $a$ and $b$, respectively.

$b$ has a {\em syntactic address dependency} on $a$ if $r$ is an address source register for $j$ and $j$ has a syntactic dependency on $i$ via source register $r$

$b$ has a {\em syntactic data dependency} on $a$ if $b$ is a store operation, $r$ is a data source register for $j$, and $j$ has a syntactic dependency on $i$ via source register $r$

$b$ has a {\em syntactic control dependency} on $a$ if there is an instruction $m$ program-ordered between $i$ and $j$ such that $m$ is a branch or indirect jump and $m$ has a syntactic dependency on $i$.

\begin{commentary}
  Generally speaking, non-AMO load instructions do not have data source registers, and unconditional non-AMO store instructions do not have destination registers.  However, a successful SC instruction is considered to have the register specified in {\em rd} as a destination register, and hence it is possible for an instruction to have a syntactic dependency on a successful SC instruction that precedes it in program order.
\end{commentary}

\subsection*{Preserved Program Order}
The global memory order for any given execution of a program respects some but not all of each hart's program order.
The subset of program order that must be respected by the global memory order is known as {\em preserved program order}.

\newcommand{\ppost}{$b$ is a store, and $a$ and $b$ access overlapping memory addresses}
\newcommand{\ppofence}{There is a FENCE instruction that orders $a$ before $b$}
\newcommand{\ppoacquire}{$a$ has an acquire annotation}
\newcommand{\pporelease}{$b$ has a release annotation}
\newcommand{\pporcsc}{$a$ and $b$ both have RCsc annotations}
\newcommand{\ppoamoforward}{$a$ is generated by an AMO or SC instruction, $b$ is a load, and $b$ returns a value written by $a$}
\newcommand{\ppoaddr}{$b$ has a syntactic address dependency on $a$}
\newcommand{\ppodata}{$b$ has a syntactic data dependency on $a$}
\newcommand{\ppoctrl}{$b$ is a store, and $b$ has a syntactic control dependency on $a$}
\newcommand{\ppopair}{$a$ is paired with $b$}
\newcommand{\ppordw}{$a$ and $b$ are loads, $x$ is a byte read by both $a$ and $b$, there is no store to $x$ between $a$ and $b$ in program order, and $a$ and $b$ return values for $x$ written by different memory operations}
\newcommand{\ppoaddrdatarfi}{$b$ is a load, and there exists some store $m$ between $a$ and $b$ in program order such that $m$ has an address or data dependency on $a$, and $b$ returns a value written by $m$}
\newcommand{\ppoaddrpo}{$b$ is a store, and there exists some instruction $m$ between $a$ and $b$ in program order such that $m$ has an address dependency on $a$}
%\newcommand{\ppoctrlcfence}{$a$ and $b$ are loads, $b$ has a syntactic control dependency on $a$, and there exists a {\tt fence.i} between the branch used to form the control dependency and $b$ in program order}
%\newcommand{\ppoaddrpocfence}{$a$ is a load, there exists an instruction $m$ which has a syntactic address dependency on $a$, and there exists a {\tt fence.i} between $m$ and $b$ in program order}

The complete definition of preserved program order is as follows (and note that AMOs are simultaneously both loads and stores):
memory operation $a$ precedes memory operation $b$ in preserved program order (and hence also in the global memory order) if $a$ precedes $b$ in program order, $a$ and $b$ both access regular main memory (rather than I/O regions), and any of the following hold:

\begin{itemize}
  \item Overlapping-Address Orderings:
    \begin{enumerate}
      \item\label{ppo:->st} \ppost
      \item\label{ppo:rdw} \ppordw
      \item\label{ppo:amoforward} \ppoamoforward
    \end{enumerate}
  \item Explicit Synchronization
    \begin{enumerate}[resume]
      \item\label{ppo:fence} \ppofence
      \item\label{ppo:acquire} \ppoacquire
      \item\label{ppo:release} \pporelease
      \item\label{ppo:rcsc} \pporcsc
      \item\label{ppo:pair} \ppopair
    \end{enumerate}
  \item Syntactic Dependencies
    \begin{enumerate}[resume]
      \item\label{ppo:addr} \ppoaddr
      \item\label{ppo:data} \ppodata
      \item\label{ppo:ctrl} \ppoctrl
    \end{enumerate}
  \item Pipeline Dependencies
    \begin{enumerate}[resume]
      \item\label{ppo:addrdatarfi} \ppoaddrdatarfi
      \item\label{ppo:addrpo} \ppoaddrpo
      %\item\label{ppo:ctrlcfence} \ppoctrlcfence
      %\item\label{ppo:addrpocfence} \ppoaddrpocfence
    \end{enumerate}
\end{itemize}

\subsection*{Memory Model Axioms}

An execution of a RISC-V program obeys the RVWMO memory consistency model only if there exists a global memory order conforming to preserved program order and satisfying the {\em load value axiom}, the {\em atomicity axiom}, and the {\em progress axiom}.

\newcommand{\loadvalueaxiom}{
  Each byte of each load $i$ returns the value written to that byte by the store that is the latest in global memory order among the following stores:
  \begin{enumerate}
    \item Stores that write that byte and that precede $i$ in the global memory order
    \item Stores that write that byte and that precede $i$ in program order
  \end{enumerate}
}

\newcommand{\atomicityaxiom}{If $r$ and $w$ are paired load and store operations generated by aligned LR and SC instructions in a hart $h$, $s$ is a store to byte $x$, and $r$ returns a value written by $s$, then $s$ must precede $w$ in the global memory order, and there can be no store from a hart other than $h$ to byte $x$ following $s$ and preceding $w$ in the global memory order.}

\newcommand{\progressaxiom}{No memory operation may be preceded in the global memory order by an infinite sequence of other memory operations.}

\paragraph{Load Value Axiom}
\label{rvwmo:ax:load}
\loadvalueaxiom

\paragraph{Atomicity Axiom}
\label{rvwmo:ax:atom}
\atomicityaxiom

\begin{commentary}
  The \nameref{rvwmo:ax:atom} theoretically supports LR/SC pairs of different widths and to mismatched addresses, since implementations are permitted to allow SC operations to succeed in such cases.  However, in practice, we expect such patterns to be rare, and their use is discouraged.
\end{commentary}

\paragraph{Progress Axiom}
\label{rvwmo:ax:prog}
\progressaxiom

\input{dep-table}
